# -*- coding: utf-8 -*-
import configparser
import fnmatch
import getpass
import glob
import logging
import os
import re
import string
import subprocess

import delia_commons
import polib
import redis
from delia_preprocessor.deliaobject import DeliaObject
from delia_tokenizer import token
from delia_tokenizer.tokenize import get_token, get_type

from delia_mlg import consts, tools

log = logging.getLogger(__name__)

all_update_re = (
    re.compile('At revision (\d+).'),
    re.compile('Updated to revision (\d+).'),
    re.compile('to r(\d+).'),
)

commit_re = re.compile('Committed revision (\d+)\.')

args_re = re.compile('\{(\d+)\}')


def count_alpha(msgid):
    return sum(c.isalpha() for c in args_re.sub('', msgid))


class CheckoutBackend:
    def __init__(self, root, username, password, svn_binary='svn'):
        self.root = root
        self.username = username
        self.password = password
        self.svn_binary = svn_binary

    def execute(self, subcommand, args, auth=True):
        env = os.environ.copy()
        env['LANG'] = 'en_US.UTF-8'
        command = [
            self.svn_binary,
            # '--trust-server-cert', not available on neptune
        ]
        if auth:
            command.extend([
                '--non-interactive',
                '--username', self.username,
                '--password', self.password,
                '--no-auth-cache',
            ])
        command.append(subcommand)
        command.extend(args)
        cwd = self.root if os.path.exists(self.root) else os.getcwd()
        return subprocess.check_output(command, stderr=subprocess.PIPE, env=env, cwd=cwd).decode('utf-8')

    def update(self, paths, revision=None):
        args = []
        if revision is not None:
            args.extend(['-r', str(revision)])
        args.extend(paths)
        output = self.execute('update', args)
        log.debug('svn update:\n%s', output)
        revisions = []
        for update_re in all_update_re:
            for m in update_re.finditer(output):
                revisions.append(int(m.group(1)))
        if not revisions:
            raise ValueError('failed to get revision from:\n%s' % output)
        return max(revisions)

    def revert(self, paths):
        self.execute('revert', paths, auth=False)

    def commit(self, message, paths):
        actual_paths = []
        for path in paths:
            if not os.path.isabs(path):
                path = os.path.join(self.root, path)
            if os.path.exists(path):
                actual_paths.append(path)
        if not actual_paths:
            # Nothing to commit
            return None
        args = ['-m', message]
        args.extend(actual_paths)
        output = self.execute('commit', args)
        log.debug('svn commit:\n%s', output)
        m = commit_re.search(output)
        if not m:
            # Nothing to commit
            return None
        return int(m.group(1))

    def add(self, paths):
        try:
            self.execute('add', paths, auth=False)
        except subprocess.CalledProcessError:
            pass

    def checkout(self, url):
        if os.path.exists(self.root):
            raise ValueError('checkout already exists: %s' % self.root)
        self.execute('checkout', (url, self.root))


class POFileWrapper:
    def __init__(self, path, lang):
        self.path = os.path.normpath(os.path.abspath(path))
        self.lang = lang
        kwargs = {'encoding': 'utf-8', 'wrapwidth': 0}
        if os.path.exists(self.path):
            self.pofile = polib.pofile(self.path, **kwargs)
            actual_lang = self.pofile.metadata.get('Language')
            if actual_lang is None:
                self.pofile.metadata['Language'] = self.lang
            elif actual_lang != self.lang:
                raise ValueError('language mismatch: %s expected, got %s' % (self.lang, actual_lang))
        else:
            self.pofile = polib.POFile(fpath=self.path, **kwargs)
            self.pofile.metadata['MIME-Version'] = '1.0'
            self.pofile.metadata['Content-Type'] = 'text/plain; charset=utf-8'
            self.pofile.metadata['Content-Transfer-Encoding'] = '8bit'
            self.pofile.metadata['Language'] = self.lang

    def save(self, sort=True):
        if sort:
            pattern = re.compile('([0-9]+)')
            convert = lambda c: int(c) if c.isdigit() else c.lower()
            alphanum_key = lambda e: [convert(c) for c in pattern.split(e.msgid)]
            self.pofile.sort(key=alphanum_key)
        d = os.path.dirname(self.path)
        if not os.path.isdir(d):
            os.makedirs(d)
        self.pofile.save()

    def __getattr__(self, item):
        return getattr(self.pofile, item)

    def __iter__(self):
        return iter(self.pofile)

    def __len__(self):
        return len(self.pofile)


class SourceBackend:
    def __init__(self, checkout_backend):
        self.checkout_backend = checkout_backend

    def languages(self):
        return set([lang for lang in os.listdir(self.checkout_backend.root) if
                    os.path.isdir(os.path.join(self.checkout_backend.root, lang)) and lang not in ('.svn', '.git', 'templates')])

    def get_procedure_path(self, procedure_name, lang):
        return os.path.join(self.checkout_backend.root, lang, '%s_%s.po' % (tools.as_basename(procedure_name), lang))

    def get_procedure_paths(self, procedure_name):
        return set([self.get_procedure_path(procedure_name, lang) for lang in self.languages()])

    def get_procedures_paths(self, procedure_names):
        procedure_paths = set()
        for procedure_name in procedure_names:
            procedure_paths.update(self.get_procedure_paths(procedure_name))
        return procedure_paths

    def update_procedure(self, procedure_name, revision=None):
        procedure_paths = self.get_procedure_paths(procedure_name)
        self.checkout_backend.revert(procedure_paths)
        return self.checkout_backend.update(procedure_paths, revision=revision)

    def update_procedures(self, procedure_names, revision=None):
        procedure_paths = self.get_procedures_paths(procedure_names)
        self.checkout_backend.revert(procedure_paths)
        return self.checkout_backend.update(procedure_paths, revision=revision)

    def commit_procedure(self, procedure_name, username=None):
        message = 'commit %s POs by %s' % (procedure_name, username if username else getpass.getuser())
        procedure_paths = self.get_procedure_paths(procedure_name)
        self.checkout_backend.add(procedure_paths)
        return self.checkout_backend.commit(message, procedure_paths)

    def commit_procedures(self, procedure_names, username=None):
        message = 'commit POs by %s' % (username if username else getpass.getuser(),)
        procedure_paths = self.get_procedures_paths(procedure_names)
        self.checkout_backend.add(procedure_paths)
        return self.checkout_backend.commit(message, procedure_paths)

    def get_procedure_po(self, procedure_name, lang):
        return POFileWrapper(self.get_procedure_path(procedure_name, lang), lang)

    def get_global_po(self, lang):
        return POFileWrapper(self.get_procedure_path(consts.schema_name, lang), lang)

    def get_force_po(self, lang):
        return POFileWrapper(self.get_procedure_path('force', lang), lang)

    def scan_all(self):
        for lang in self.languages():
            for po in self.scan_lang(lang):
                yield po

    def scan_lang(self, lang):
        global_po_path = self.get_procedure_path(consts.schema_name, lang)
        for path in glob.glob(os.path.join(self.checkout_backend.root, lang, '*_%s.po' % lang)):
            if path != global_po_path:
                yield POFileWrapper(path, lang)

    def get_blacklist(self):
        blacklist = set()
        blacklist_path = os.path.join(self.checkout_backend.root, 'templates', 'blacklist.pot')
        if os.path.isfile(blacklist_path):
            po = polib.pofile(blacklist_path, encoding='utf-8')
            for entry in po:
                blacklist.add(entry.msgid)
        return blacklist


french_lowercase = string.ascii_lowercase + 'àâçèéêîôùû'

french_bad_encoded = [c.encode('utf-8').decode('latin1') for c in 'àâçèéêîôùûÀÂÇÈÉÊÎÔÙÛ']


class SanityBackend:

    def __init__(self, blacklist=None):
        self.blacklist = blacklist or set()
        self.blacklist_lower = [msgid.lower() for msgid in self.blacklist]

    def has_valid_msgid(self, msgid):
        # Check blacklist
        if msgid.lower() in self.blacklist_lower or msgid.strip().lower() in self.blacklist_lower:
            return False
        # Check length
        if len(msgid) < consts.msgid_min_length:
            return False
        # Check number of alpha
        if count_alpha(msgid) < consts.msgid_min_alpha:
            return False
        # debug from Monkey, type.debug (">>> ")
        for prefix in ('<<', 'Branch#', '>>> '):
            if msgid.startswith(prefix):
                return False
        # Check encoding
        # TODO: delete when fixed
        for c in french_bad_encoded:
            if c in msgid:
                return False
        # TODO: check that no \t or \r ?
        for c in msgid.lower():
            if c in french_lowercase:
                return True
        return False

    def has_valid_msgstr(self, lang, msgid, msgstr):
        # TODO: check that no \t or \r ?
        # TODO: check that if msgid ends with \n, both ends with \n
        return self.has_valid_msgid(msgid) \
               and msgstr \
               and msgstr.strip() != '' \
               and len(msgid) == len(msgstr) \
               and self.has_valid_args(msgid, msgstr) \
               and (lang != consts.adl_lang or msgstr == '')

    def has_valid_args(self, msgid, msgstr):
        msgid_args = sorted(args_re.findall(msgid))
        msgstr_args = sorted(args_re.findall(msgstr))
        return msgid_args == msgstr_args

    def fix_msgstr(self, msgid, msgstr):
        len_msgid = len(msgid)
        len_msgstr = len(msgstr)
        fixed = False
        if len_msgid > len_msgstr:
            msgstr += ' ' * (len_msgid - len_msgstr)
            fixed = True
        elif len_msgid < len_msgstr and msgstr[len_msgid:].replace(' ', '') == '':
            msgstr = msgstr[:len_msgid]
            fixed = True
        return fixed, msgstr

    def sanitize(self, lang, msgid, msgstr):
        fixed, msgstr = self.fix_msgstr(msgid, msgstr)
        if not self.has_valid_msgstr(lang, msgid, msgstr):
            return None
        return msgstr

    def clean_po(self, po):
        changed = False
        entries = []
        for entry in po:
            if not self.has_valid_msgid(entry.msgid):
                entries.append(entry)
                changed = True
            elif entry.translated() and not self.has_valid_msgstr(po.lang, entry.msgid, entry.msgstr):
                fixed, new_msgstr = self.fix_msgstr(entry.msgid, entry.msgstr)
                if not self.has_valid_msgstr(po.lang, entry.msgid, new_msgstr):
                    entry.msgstr = ''
                else:
                    entry.msgstr = new_msgstr
                changed = True
        for entry in entries:
            po.remove(entry)
        return changed


class DataBackend:
    def get(self, msgid, lang):
        raise NotImplementedError('get')

    def keys(self, pattern, lang):
        raise NotImplementedError('keys')

    def escape(self, msgid):
        raise NotImplementedError('escape')


class RedisBackend(DataBackend):
    def __init__(self, url):
        self.cx = redis.StrictRedis.from_url(url)

    def get(self, msgid, lang):
        msgstr = self.cx.hget(msgid.encode('utf-8'), lang.encode('utf-8'))
        if msgstr is not None:
            return msgstr.decode('utf-8')
        return msgstr

    def keys(self, pattern, lang):
        for msgid in self.cx.keys(pattern.encode('utf-8')):
            yield msgid.decode('utf-8'), None

    def scan_iter(self):
        for key in self.cx.scan_iter():
            key_u = key.decode('utf-8')
            values = self.cx.hgetall(key)
            values_u = dict([(k.decode('utf-8'), v.decode('utf-8')) for k, v in values.items()])
            yield key_u, values_u

    def escape(self, msgid):
        escaped_msgid = msgid
        for c in ('*', '?', '[', ']'):
            escaped_msgid = escaped_msgid.replace(c, '\\' + c)
        return escaped_msgid


class GlobalPOBackend(DataBackend):
    def __init__(self, source_backend, sanity_backend):
        self.cache = {}
        for lang in source_backend.languages():
            cache_lang = {}
            self.cache[lang] = cache_lang
            cache_strip = {}
            for entry in source_backend.get_global_po(lang):
                cache_lang[entry.msgid] = entry.msgstr
                msgid_strip = entry.msgid.strip()
                if msgid_strip != entry.msgid:
                    msgstr_strip = sanity_backend.sanitize(lang, msgid_strip, entry.msgstr.strip())
                    if msgstr_strip:
                        cache_strip[msgid_strip] = msgstr_strip
            for msgid, msgstr in cache_strip.items():
                if msgid not in cache_lang:
                    cache_lang[msgid] = msgstr

    def get(self, msgid, lang):
        if lang not in self.cache:
            return None
        return self.cache[lang].get(msgid, None)

    def keys(self, pattern, lang):
        if lang in self.cache:
            pattern_re = re.compile(fnmatch.translate(pattern))
            for msgid, msgstr in self.cache[lang].items():
                if pattern_re.match(msgid):
                    yield msgid, msgstr

    def escape(self, msgid):
        return glob.escape(msgid)


class TranslationBackend:
    def __init__(self, data_backend, sanity_backend, force_backend):
        self.data_backend = data_backend
        self.sanity_backend = sanity_backend
        self.force_backend = force_backend

    def translate_po(self, po, force=False, lookup=False):
        changed = self.sanity_backend.clean_po(po)
        for entry in po:
            if (force and entry.translated() and consts.PIN not in entry.comment and consts.PIN not in entry.tcomment) \
                    or (not entry.translated() and not entry.obsolete and not 'fuzzy' in entry.flags):
                if self.translate_po_entry(entry, po.lang, lookup=lookup):
                    changed = True
        return changed

    def translate_po_entry(self, entry, lang, lookup=False):
        msgstr = self.translate_msgid(entry.msgid, lang, lookup=lookup)
        if msgstr:
            entry.msgstr = msgstr
        return msgstr is not None

    def translate_msgid(self, msgid, lang, lookup=False):
        if lang == consts.adl_lang:
            return
        if count_alpha(msgid) < consts.msgid_min_alpha_auto_translate:  # Do not translate automatically, too dangerous. Let users edit POs.
            return
        msgstr = self.force_backend.get(msgid, lang) or self.data_backend.get(msgid, lang)
        if msgstr is not None:
            msgstr = self.sanity_backend.sanitize(lang, msgid, msgstr)
        if msgstr is None:
            msgstr = self.alt_msgid_match(msgid, msgid.strip(), lang)
        if msgstr is None and lookup:
            msgstr = self.alt_msgid_search(msgid, lang)
        return msgstr

    def alt_msgid_search(self, msgid, lang):
        # Get patterns
        escaped_msgid = self.data_backend.escape(msgid)
        patterns = [
            # escaped_msgid.strip() + ' *',
            # '* ' + escaped_msgid.strip(),
            # '* ' + escaped_msgid.strip() + ' *',
            '*' + escaped_msgid.strip() + '*',
        ]
        # Iterate on patterns
        for pattern in patterns:
            # Get the keys matching the pattern
            for alt_msgid, alt_msgstr in self.data_backend.keys(pattern, lang):
                # Check if the found key match the the original key
                msgstr = self.alt_msgid_match(msgid, alt_msgid, lang, alt_msgstr)
                if msgstr is not None:
                    return msgstr
        # Nothing found
        return None

    def alt_msgid_match(self, msgid, alt_msgid, lang, alt_msgstr=None):
        # Count right spaces and left spaces
        right_len = len(msgid) - len(msgid.rstrip())
        left_len = len(msgid) - len(msgid.lstrip())
        # Check if the found key match the the original key
        if alt_msgid.strip() == msgid.strip():
            # Get the candidate translation if not provided
            if alt_msgstr is None:
                alt_msgstr = self.data_backend.get(alt_msgid, lang)
            # Check if found a translation
            if alt_msgstr is not None:
                # Check the sanity of the stripped version
                msgstr = self.sanity_backend.sanitize(lang, alt_msgid.strip(), alt_msgstr.strip())
                # If OK, pad
                if msgstr is not None:
                    return ' ' * left_len + msgstr + ' ' * right_len
        # Nothing
        return None


class ConfigBackend:
    REDIS = 'REDIS'
    SUBVERSION = 'SUBVERSION'

    def __init__(self, path):
        if not os.path.exists(path):
            raise ValueError('does not exist: %s' % path)
        self.config = configparser.ConfigParser()
        self.config.read(path, encoding='utf-8')

    @property
    def redis_url(self):
        return self.config[self.REDIS]['URL']

    @property
    def svn_checkout(self):
        return self.config[self.SUBVERSION]['CHECKOUT']

    @property
    def svn_username(self):
        return self.config[self.SUBVERSION]['USERNAME']

    @property
    def svn_password(self):
        return self.config[self.SUBVERSION]['PASSWORD']

    @property
    def svn_binary(self):
        return self.config.get(self.SUBVERSION, 'BINARY', fallback='svn')


class UntranslatedBackend:
    def __init__(self, sanity_backend):
        self.sanity_backend = sanity_backend

    def walk(self, root):
        procedures = {}
        for root, dirs, files in os.walk(root):
            for name in files:
                path = os.path.join(root, name)
                with open(path, 'r', encoding='utf-8') as fd:
                    for line in fd:
                        line = line.strip()
                        parts = line.split(',', 2)
                        if len(parts) != 3:
                            log.error('invalid line: %r', line)
                        else:
                            procedure, lang, msgid = parts
                            procedure = procedure.lower().replace('_', '.')
                            if msgid[0] != '"' or msgid[-1] != '"':
                                log.error('invalid msgid: %r', msgid)
                            else:
                                msgid = msgid[1:-1]
                                if self.sanity_backend.has_valid_msgid(msgid):
                                    if procedure not in procedures:
                                        procedures[procedure] = set()
                                    procedures[procedure].add(msgid)
        return procedures


class GtTranslateBackend:
    def __init__(self, sanity_backend):
        self.sanity_backend = sanity_backend

    def parse(self, project_path, procedure_name):
        msgids = set()
        try:
            ctx = delia_commons.Context()
            ctx.initialize(project_path)
            procedure = DeliaObject(procedure_name)
            scanner = procedure.scan_all()
            for lexeme in scanner:
                if get_type(*lexeme) == token.mag_name:
                    if get_token(*lexeme).lower() in ('gt.translate', 'gt.translate.2'):
                        for lexeme in scanner:
                            if get_type(*lexeme) not in (token.comment, token.WS):
                                break
                        if get_type(*lexeme) == token.LPAREN:
                            for lexeme in scanner:
                                if get_type(*lexeme) not in (token.comment, token.WS):
                                    break
                            if get_type(*lexeme) == token.quoted_string:
                                msgid = get_token(*lexeme)[1:-1].rstrip()  # RT makes a rstrip when callling gettext
                                if self.sanity_backend.has_valid_msgid(msgid):
                                    msgids.add(msgid)
        except Exception:
            log.exception('failed to tokenize %s', procedure_name)
        return msgids


class FrameBackend:
    def __init__(self, sanity_backend):
        self.sanity_backend = sanity_backend

    def parse_all(self, project_path, procedure_name):
        project_config = configparser.ConfigParser()
        project_config.read(os.path.join(project_path, 'project.cfg'))
        encoding = 'iso-8859-1' if project_config.getint('schema', 'version') <= 2009 else 'utf-8'
        msgids = set()
        frames_paths = os.path.join(project_path, 'adl', 'src', 'gra', 'java', tools.as_basename(procedure_name), 'frm_*.java')
        for frame_path in glob.glob(frames_paths):
            msgids.update(self.parse(frame_path, encoding))
        return msgids

    def parse(self, frame_path, encoding):
        msgids = set()
        with open(frame_path, 'r', encoding=encoding) as frame_fd:
            for line in frame_fd.read().splitlines():
                if 'setText' in line or 'setToolTipText' in line or 'setBeanText' in line or 'setTitle' in line:
                    start = line.find('("')
                    stop = line.rfind('")')
                    msgid = line[start + 2: stop].replace('\\n', '\n').replace('\\"', '"')
                    if self.sanity_backend.has_valid_msgid(msgid):
                        msgids.add(msgid)
        return msgids


class ForceBackend:
    def __init__(self, source_backend, sanity_backend):
        self.sanity_backend = sanity_backend
        self.cache = {}
        for lang in source_backend.languages():
            cache_lang = {}
            self.cache[lang] = cache_lang
            for entry in source_backend.get_force_po(lang):
                msgid_strip = entry.msgid.strip()
                if msgid_strip not in cache_lang:
                    cache_lang[msgid_strip] = set()
                cache_lang[msgid_strip].add(entry.msgstr.strip())

    def get(self, msgid, lang):
        if lang not in self.cache:
            return None
        msgid_strip = msgid.strip()
        if msgid_strip not in self.cache[lang]:
            return None
        msgid_lstrip = msgid.lstrip()
        msgstrs = sorted([m for m in self.cache[lang][msgid_strip] if len(m) <= len(msgid_lstrip)], key=lambda m: len(m), reverse=True)
        if len(msgstrs) == 0:
            return None
        msgstr = msgstrs[0]
        left_len = len(msgid) - len(msgid_lstrip)
        return self.sanity_backend.sanitize(lang, msgid, ' ' * left_len + msgstr)

    def force_po(self, po):
        changed = False
        for entry in po:
            msgstr = self.get(entry.msgid, po.lang)
            if msgstr:
                entry.msgstr = msgstr
                changed = True
        return changed
