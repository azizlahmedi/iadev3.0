from delia_parser import types, ast, pictures
from delia_codegen.utils import adl_name_to_py_name
from delia_codegen.codeblock import CodeBlockNames
from delia_codegen.convert_type import do_convert


class Frames:

    def gen_FrameFormat(self, node):
        # Don't care about it.
        self.gen_unused(node)

        pass

    def gen_Frame(self, node):
        self.gen_unused(node)

        if not node.used:
            return

        frame_format_location = node.frame_format_location
        frame_area = node.frame_area
        frame_data_names = node.frame_data_names
        frame_name = adl_name_to_py_name(node.name)

        self.set_src(self.source[CodeBlockNames.FRAME], node)

        self.src.newline("_frames['{name}'] = AdlFrame(".format(name=frame_name))
        self.src.indent()
        self.src.newline("name='{name}',".format(name=frame_name))

        if frame_area:
            self.src.newline("area=(")
            self.src.write(self.resolve(frame_area.first_line))
            self.src.write(", ")
            self.src.write(self.resolve(frame_area.last_line))
            self.src.write("),")

        got_array = False

        fields_list = []
        for name in frame_data_names:

            if isinstance(name.type, types.Array):
                got_array = True
                continue

            _type = name.type
            _picture = name.definition.picture.picture

            if _type is types.Integer():
                datatype = 'integer'
                size = _picture._get_size()
                total, decimal_digits = _picture.get_digits()
                integer_digits = total - decimal_digits
                subtype = '({size}, {integer_digits})'.format(
                    size=size,
                    integer_digits=integer_digits,
                )

            elif _type is types.Decimal():
                datatype = 'decimal'
                size = _picture._get_size()
                total, decimal_digits = _picture.get_digits()
                integer_digits = total - decimal_digits
                if _picture._get_point() == 'V':
                    decimal_pos = decimal_digits
                else:
                    decimal_pos = None
                subtype = '({size}, {integer_digits}, {decimal_digits}, {decimal_pos})'.format(
                    size=size,
                    integer_digits=integer_digits,
                    decimal_digits=decimal_digits,
                    decimal_pos=decimal_pos,
                )

            elif _type is types.Date():
                datatype = 'date'

                if isinstance(_picture, pictures.UnknownPicture):
                    size = self.get_date_default_size()
                    date_fmt = self.get_date_default_fmt()
                    empty_is_default = False
                else:
                    size = _picture.size
                    date_fmt = _picture.normal_form(ignore_ws=True)
                    empty_is_default = _picture.empty_is_default()

                subtype = "({size}, '{date_fmt}', {empty_is_default})".format(
                    size=size,
                    date_fmt=date_fmt,
                    empty_is_default=empty_is_default,
                )

            elif _type is types.String():
                datatype = 'str'
                size = _picture.size
                subtype = '{size}'.format(
                    size=size,
                )
            else:
                raise NotImplementedError("Not supported type: ", input.type)

            default = self.get_default_value(name, force_literal_value=True)

            # Get default value as string.
            to_type = types.String()
            to_pict = pictures.UnknownPicture()

            from_type = _type
            from_pict = _picture

            convert_function = []
            convert_function = do_convert(self,
                                          to_type,
                                          to_pict,
                                          from_type,
                                          from_pict,
                                          convert_function,
                                          default_decimal_sep=True)
            expression = []
            for (header, _) in reversed(convert_function):
                if header is not None:
                    expression.append(header)

            expression.append(default)

            for (_, footer) in convert_function:
                if footer is not None:
                    expression.append(footer)

            default_as_str = "".join(expression)

            fields_list.append("('{}', '{}', {}, {}, {}, {},)".format(
                adl_name_to_py_name(name), datatype, subtype, default, default_as_str, f"self.data_descs['{self.dd_names[adl_name_to_py_name(name)]}']"))

        if len(fields_list):
            self.src.newline("fields=(")
            self.src.indent()
            for field in fields_list:
                self.src.newline("%s," % field)
            self.src.dedent()
            self.src.newline("),")

        if got_array:

            self.src.newline("arrays=(")
            self.src.indent()

            frame_array_data_names = [name for name in frame_data_names if isinstance(name.type, types.Array)]
            for name in frame_array_data_names:
                self.src.newline("OrderedDict((")
                self.src.indent()

                array_def = self.array_definition_to_dict(name)
                for key, val in array_def.items():
                    if key == 'fields':
                        self.src.newline("('fields', (")
                        self.src.indent()
                        for field in val:
                            self.src.newline("%s," % (field))
                        self.src.dedent()
                        self.src.newline(")),")
                    else:
                        self.src.newline("('%s', %s)," % (key, val))

                self.src.dedent()
                self.src.newline(")),")

            self.src.dedent()
            self.src.newline("),")

        if len(node.help_msg):

            self.src.newline("helpmsg=OrderedDict((")
            self.src.indent()

            for key, field_help_msg in node.help_msg.items():
                self.src.newline("(")
                if isinstance(key, tuple):
                    array_name = key[0]
                    field_name = key[1]
                    self.src.write("'%s.%s'" % (adl_name_to_py_name(array_name), adl_name_to_py_name(field_name)))
                else:
                    self.src.write("'%s'" % adl_name_to_py_name(key))
                self.src.write(", ")
                self.src.write(self.get_concatenated_string(field_help_msg, force_literal_value=True))
                self.src.write(",),")

            self.src.dedent()
            self.src.newline(")),")

        # Optional frame.format (Not used by the RT, transmit via the protocol to the client)
        if frame_format_location and \
                frame_format_location.definition.frame_format_def != []:

            self.src.newline("frame_format=(")
            self.src.indent()
            for line in frame_format_location.definition.frame_format_def:
                self.src.newline("\"\"\"%s\"\"\"," % line)
            self.src.dedent()
            self.src.newline("),")

            self.src.newline("frame_format_order=(")
            for name in frame_data_names:
                self.src.write("'%s', " % adl_name_to_py_name(name))
            self.src.write("),")

        self.src.dedent()
        self.src.newline(")")
        self.src.newline()

    def gen_Display(self, node):
        frames = node.frame_names
        self.src.newline("with AdlDisplay(")
        self.src.write("frames=(")
        for frame in frames:
            self.src.write("_frames['%s'], " % adl_name_to_py_name(frame.value))
        self.src.write(")")
        self.src.write(") as (")
        self.src.write(", ".join([adl_name_to_py_name(scope) for scope in node.scopes]))
        self.src.write(", ):")
        self.src.indent()

        self.visit(node.stmts)
        self.src.dedent()

    def gen_FunctionKey(self, node):
        self.gen_unused(node)

        if not node.used:
            return

        func_name = adl_name_to_py_name(node.name)
        is_globally = node.is_globally
        stmts = node.stmts

        self.set_src(self.source[CodeBlockNames.FUNCTION_KEYS], node)

        self.src.newline("def %s(" % func_name)
        if not is_globally:
            self.src.write("frame_stack, frames_stack_ns")
        else:
            self.src.write("*args")
        self.src.write("):")

        self.src.indent()

        self.src.stop_gen_locations()
        # Add locals variables to the procedure which can be assigned in the body of the function.
        self.src.add(self.source[CodeBlockNames.LOCAL])
        self.src.start_gen_locations()

        self.visit(stmts)

        self.src.dedent()
        self.src.newline()

    def gen_Input(self, node):
        for field in node.field_names:

            is_array_id = isinstance(field, ast.ArrayId)

            if is_array_id:
                self.src.newline("adl_input_array_field(")
            else:
                self.src.newline("adl_input_field(")

            self.src.write("frames_stack_ns=[%s]" % ', '.join(adl_name_to_py_name(frame) for frame in node.frame_stack))
            self.src.write(", frame=_frames['%s']" % adl_name_to_py_name(field.scope.name))
            self.src.write(", frame_stack=(")
            for frame in node.frame_stack:
                self.src.write("_frames['%s'], " % adl_name_to_py_name(frame))
            self.src.write(")")

            self.src.write(", field_name='%s'" % adl_name_to_py_name(field.name))

            if is_array_id:

                # TODO: rework
                self.src.write(", array_name='%s'" % adl_name_to_py_name(field.array_definition.name))

                self.src.write(", index=")

                lower_bound = field.array_definition.lower_bound
                upper_bound = field.array_definition.upper_bound
                self.array_index(field.index.index, field.check_subscripts, lower_bound, upper_bound)

            if node.functions_key:
                self.src.write(", function_keys_dict=_function_keys_dict")
                self.src.write(", active_function_keys=(")
                for function_key in node.functions_key:
                    self.src.write('"%s", ' % adl_name_to_py_name(function_key.name))
                self.src.write(")")

            if node.echo:
                self.src.write(", echo=True")
            else:
                self.src.write(", echo=False")

            self.src.write(f",)")
