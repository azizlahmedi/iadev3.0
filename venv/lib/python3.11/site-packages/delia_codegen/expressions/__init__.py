from delia_codegen.expressions.gen_operations import Operation
from delia_codegen.expressions.gen_comparisons import Comparison
from delia_codegen.expressions.gen_builtins import Builtin
from delia_codegen.expressions.gen_conversion_tests import ConversionTest

from delia_codegen.utils import adl_name_to_py_name
from delia_codegen.convert_type import convert_type

from delia_parser import ast
from delia_parser import types
from delia_parser.scope import AdlDynScope, WhereRoutineScope

import re


class Expressions(Operation,
                  Comparison,
                  ConversionTest,
                  Builtin,
                  ):

    def gen_Not(self, node):
        self.src.write("not (")
        self.visit(node.left)
        self.src.write(")")

    def gen_Nothing(self, node):
        self.src.newline("pass")

    def get_thousand_sep_parameter(self):
        return "thousand_sep=procedure._digit_separator[0]"

    def get_decimal_sep_parameter(self):
        return "decimal_sep=procedure._digit_separator[1]"

    def gen_Name(self, node):
        if str(node.value) == '_temp':
            self.src.write("_temp")
        else:
            self.src.write(adl_name_to_py_name(node.value))

    @convert_type
    def gen_ConstantRef(self, node):
        self.src.write("constants.%s" % adl_name_to_py_name(node.name.value))

    @convert_type
    def gen_Id(self, node):
        if isinstance(node.scope, AdlDynScope):
            self.src.write("adl_get_ns_with_field_from_frames_stack_ns(procedure, frames_stack_ns, '{field_name}').{field_name}".format(
                           field_name=adl_name_to_py_name(node.name)))
        elif isinstance(node.definition, ast.Constant):
            self.gen_ConstantRef(node)
        elif isinstance(node.scope, WhereRoutineScope):
            self.src.write("%s" % adl_name_to_py_name(node.name))
        elif node.scope is None:
            self.src.write("%s" % adl_name_to_py_name(node.name))
        else:
            self.src.write("%s.%s" % (adl_name_to_py_name(node.scope),
                                      adl_name_to_py_name(node.name)))

    @convert_type
    def gen_ReturningFunction(self, node):
        self.src.write("%s._result" % adl_name_to_py_name(node.definition.scope))

    @convert_type
    def gen_ArrayId(self, node):
        tab_py_name = adl_name_to_py_name(node.array_definition.name)
        py_name = adl_name_to_py_name(node.name)
        py_scope = adl_name_to_py_name(node.scope)

        lower_bound = node.array_definition.lower_bound
        upper_bound = node.array_definition.upper_bound
        check = node.array_definition.check_subscripts

        if isinstance(node.scope, AdlDynScope):
            self.src.write("adl_get_ns_with_field_from_frames_stack_ns(procedure, frames_stack_ns, '{tab_name}').{tab_name}.{field_name}".format(
                           tab_name=tab_py_name, field_name=py_name))
        else:
            self.src.write("%s.%s.%s" % (py_scope, tab_py_name, py_name))

        if isinstance(node.index, ast.ArrayIndexTo):
            self.src.write("[")
            self.array_index(node.index.lower, check, lower_bound, upper_bound)
            self.src.write(":")
            self.array_index(node.index.upper, check, lower_bound, upper_bound, is_upper_bound=True)
            self.src.write("]")
        elif isinstance(node.index, ast.ArrayIndexAll):
            self.src.write("[:]")
        else:
            self.src.write("[")
            self.array_index(node.index.index, check, lower_bound, upper_bound)
            self.src.write("]")

    def convert_str_to_year_month_day(self, value):
        val_size = len(value)
        if val_size == len("YYMMDD"):
            year = 1900 + int(value[:2])
            month = int(value[2:4])
            day = int(value[4:])
        elif val_size == len("YYYYMMDD"):
            year = int(value[:4])
            month = int(value[4:6])
            day = int(value[6:])
        return year, month, day

    def convert_str_to_date(self, value):
        year, month, day = self.convert_str_to_year_month_day(value)
        return f"_date(year={year}, month={month}, day={day})"

    @convert_type
    def gen_Date(self, node):
        self.src.write(self.convert_str_to_date(str(node.value)))

    def get_date_min(self, force_literal_value=False):
        if force_literal_value:
            return "_date(year=1752, month=9, day=14)"
        else:
            return "_DATE_MIN"

    def get_date_max(self, force_literal_value=False):
        if force_literal_value:
            return "_date(year=9999, month=12, day=31)"
        else:
            return "_DATE_MAX"

    def get_date_default_fmt(self):
        return "%Y%m%d"

    def get_date_default_size(self):
        return 8

    def add_String(self, value, force_literal_value=False):

        def str_id_generator(val):

            if not val.strip():
                # IDs for literals containing spaces.
                str_id = "_STR_SPACES_%03d" % len(val)
            else:
                # IDs for others literals.
                str_id = re.sub('[^0-9a-zA-Z]+', '_', val)
                str_id = "_STR_%s" % str_id
                if len(str_id) > 20:
                    str_id = str_id[:20]

            # Check the ID is uniq.
            count = 0
            while str_id in self.str_literals.values():
                if count == 0:
                    str_id += "_ID_0000"
                else:
                    str_id = str_id[:-4] + "%04d" % count
                count += 1
            return str_id

        # Add cotes for escape characters.
        if self.not_use_literal_value:
            val = '"%s"' % value.replace('"', r'\"').replace('\\', '\\\\').replace(r'\\"', r'\"')
        else:
            val = '_("%s")' % value.replace('"', r'\"').replace('\\', '\\\\').replace(r'\\"', r'\"')

        if force_literal_value or self.force_literal_value:
            return val

        if val in self.str_literals:
            literal_name = self.str_literals[val]
        else:
            literal_name = str_id_generator(value)
            self.str_literals[val] = literal_name
        return "%s" % literal_name

    @convert_type
    def gen_String(self, node):
        self.src.write(self.add_String(node.value))

    def gen_ConcatenatedString(self, node):
        for cste in node.values:
            self.visit(cste)
            if cste != node.values[-1]:
                self.src.write(" + ")

    def gen_ControlCharacter(self, node):
        if node.token.startswith("@"):
            if node.token.lower() in ("@cr", "@ff",):
                self.src.write('"%s"' % node.value)
            else:
                try:
                    asci_elm = node.token[1:].lstrip('0')
                    if asci_elm == '':
                        value = 0
                    else:
                        value = int(asci_elm)
                except Exception:
                    raise NotImplementedError("{}".format(node))
                else:
                    self.src.write("chr(%d)" % value)
        else:
            raise NotImplementedError("{}".format(node))

    @convert_type
    def gen_Integer(self, node):
        self.src.write("%d" % int(node.value))

    def add_Decimal(self, value, force_literal_value=False):

        def dec_id_generator(val):
            return "_DEC_%s" % (val.replace('.', '_').replace('-', 'm').replace('+', 'p'),)

        val = "Decimal('%s')" % value
        if force_literal_value or self.force_literal_value:
            return val

        if val in self.num_literals:
            literal_name = self.num_literals[val]
        else:
            literal_name = dec_id_generator(value)
            self.num_literals[val] = literal_name
        return literal_name

    @convert_type
    def gen_Decimal(self, node):
        self.src.write(self.add_Decimal(node.value))

    @convert_type
    def gen_Float(self, node):
        self.src.write(self.add_Decimal(node.value.replace('E', 'e')))

    @convert_type
    def gen_Double(self, node):
        self.src.write(self.add_Decimal(node.value.replace('D', 'e')))

    @convert_type
    def gen_Boolean(self, node):
        self.src.write("%s" % node.value.title())
