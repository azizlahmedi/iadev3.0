from delia_parser import types, ast
from delia_parser.ast import CallingFunction
from delia_parser.builtins import builtins


class Comparison:

    def left_operand(self, left, right):
        if right.type is types.String() or left.type is types.String():
            is_string_comparison = True
            do_strip_left = True
        else:
            is_string_comparison = False
            do_strip_left = False

        # Compare with default value of right operand if left operand is DEFAULT
        if isinstance(left, ast.Default):

            if is_string_comparison:

                if isinstance(right, ast.Id):
                    if self.is_default_declared(right):
                        self.src.write(self.get_default_value(right))
                    else:
                        self.src.write("''")
                        do_strip_left = False

                elif isinstance(right, ast.ImplicitSelect):

                    if self.is_default_declared(right.field_name):
                        self.src.write(self.get_default_value(right.field_name))
                    else:
                        self.src.write("''")
                        do_strip_left = False

                else:
                    self.src.write("''")
                    do_strip_left = False

            else:

                if isinstance(right, ast.Id):
                    self.src.write(self.get_default_value(right))

                elif isinstance(right, ast.ImplicitSelect):
                    self.src.write(self.get_default_value(right.field_name))

                elif isinstance(right, ast.Expr):

                    if right.type is types.Date():
                        self.src.write(self.get_date_min(force_literal_value=False))

                    elif isinstance(right.type, types.Numeric):
                        self.src.write("0")

        elif isinstance(left, (ast.Literal, ast.Id)):
            self.visit(left)
        else:
            self.src.write("(")
            self.visit(left)
            self.src.write(")")

        if do_strip_left:
            if isinstance(left, ast.Literal) and not left.conversion_types:
                literal = self.resolve(left)
                if literal is not None and not str(literal).endswith(' '):
                    do_strip_left = False

        if do_strip_left:
            self.src.write(".rstrip()")

    def right_operand(self, left, right):
        if right.type is types.String() or left.type is types.String():
            is_string_comparison = True
            do_strip_right = True
        else:
            is_string_comparison = False
            do_strip_right = False

        # Compare with default value of left operand if right operand is DEFAULT
        if isinstance(right, ast.Default):

            if is_string_comparison:

                if isinstance(left, ast.Id):
                    if self.is_default_declared(left):
                        self.src.write(self.get_default_value(left))
                    else:
                        self.src.write("''")
                        do_strip_right = False

                elif isinstance(left, ast.ImplicitSelect):

                    if self.is_default_declared(left.field_name):
                        self.src.write(self.get_default_value(left.field_name))
                    else:
                        self.src.write("''")
                        do_strip_right = False

                else:
                    self.src.write("''")
                    do_strip_right = False

            else:

                if isinstance(left, ast.Id):
                    self.src.write(self.get_default_value(left))

                elif isinstance(left, ast.ImplicitSelect):
                    self.src.write(self.get_default_value(left.field_name))

                elif isinstance(left, ast.Expr):

                    if left.type is types.Date():
                        self.src.write(self.get_date_min(force_literal_value=False))

                    elif isinstance(left.type, types.Numeric):
                        self.src.write("0")

        elif isinstance(right, (ast.Literal, ast.Id)):
            self.visit(right)
        else:
            self.src.write("(")
            self.visit(right)
            self.src.write(")")

        if do_strip_right:
            if isinstance(right, ast.Literal) and not right.conversion_types:
                literal = self.resolve(right)
                if literal is not None and not str(literal).endswith(' '):
                    do_strip_right = False

        if do_strip_right:
            self.src.write(".rstrip()")

    def gen_Eq(self, node):
        self.left_operand(node.left, node.right)
        self.src.write(' == ')
        self.right_operand(node.left, node.right)

    def gen_Ge(self, node):
        self.left_operand(node.left, node.right)
        self.src.write(' >= ')
        self.right_operand(node.left, node.right)

    def gen_Gt(self, node):
        self.left_operand(node.left, node.right)
        self.src.write(' > ')
        self.right_operand(node.left, node.right)

    def gen_Le(self, node):
        self.left_operand(node.left, node.right)
        self.src.write(' <= ')
        self.right_operand(node.left, node.right)

    def gen_Lt(self, node):
        self.left_operand(node.left, node.right)
        self.src.write(' < ')
        self.right_operand(node.left, node.right)

    def gen_Ne(self, node):
        self.left_operand(node.left, node.right)
        self.src.write(' != ')
        self.right_operand(node.left, node.right)

    def contains_a_function(self, node):
        if isinstance(node, CallingFunction) and str(node.name) not in builtins:
            return True
        elif node is not None and hasattr(node, "__iter__"):
            for child in node:
                if self.contains_a_function(child):
                    return True

        return False

    def gen_And(self, node):
        assert(node.left.type is types.Boolean())
        assert(node.right.type is types.Boolean())
        if self.contains_a_function(node):
            self.src.write('adl_and(')
            self.left_operand(node.left, node.right)
            self.src.write(', ')
            self.right_operand(node.left, node.right)
            self.src.write(')')
        else:
            self.left_operand(node.left, node.right)
            self.src.write(' and ')
            self.right_operand(node.left, node.right)

    def gen_Or(self, node):
        assert(node.left.type is types.Boolean())
        assert(node.right.type is types.Boolean())
        if self.contains_a_function(node):
            self.src.write('adl_or(')
            self.left_operand(node.left, node.right)
            self.src.write(', ')
            self.right_operand(node.left, node.right)
            self.src.write(')')
        else:
            self.left_operand(node.left, node.right)
            self.src.write(' or ')
            self.right_operand(node.left, node.right)

    def gen_Eqv(self, node):
        assert(node.left.type is types.Boolean())
        assert(node.right.type is types.Boolean())
        self.left_operand(node.left, node.right)
        self.src.write(' == ')
        self.right_operand(node.left, node.right)

    def gen_Xor(self, node):
        assert(node.left.type is types.Boolean())
        assert(node.right.type is types.Boolean())
        self.left_operand(node.left, node.right)
        self.src.write(' ^ ')
        self.right_operand(node.left, node.right)

    def extended_comparison(self, node):
        exp_left = node.exps[0].left
        exp_right = node.exps[0].right
        self.left_operand(exp_left, exp_right)
        self.src.write(", [")
        for exp in node.exps:
            self.src.write("(")
            if isinstance(exp, ast.Eq):
                self.src.write("'=', ")
            elif isinstance(exp, ast.Ne):
                self.src.write("'!=', ")
            elif isinstance(exp, ast.Ge):
                self.src.write("'>=', ")
            elif isinstance(exp, ast.Gt):
                self.src.write("'>', ")
            elif isinstance(exp, ast.Le):
                self.src.write("'<=', ")
            elif isinstance(exp, ast.Lt):
                self.src.write("'<', ")
            else:
                raise
            self.right_operand(exp.left, exp.right)
            self.src.write(")")
            self.src.write(", ")
        self.src.write("])")

    def gen_ExtendedComparisonAnd(self, node):
        if self.contains_a_function(node):
            self.src.write("adl_ext_and(")
            self.extended_comparison(node)
        else:
            for i, exp in enumerate(node.exps):
                if i != 0:
                    self.src.write(" and ")
                self.visit(exp)

    def gen_ExtendedComparisonOr(self, node):
        if self.contains_a_function(node):
            self.src.write("adl_ext_or(")
            self.extended_comparison(node)
        else:
            for i, exp in enumerate(node.exps):
                if i != 0:
                    self.src.write(" or ")
                self.visit(exp)
