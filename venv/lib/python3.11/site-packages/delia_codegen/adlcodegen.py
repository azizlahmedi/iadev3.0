# -*- coding: utf-8 -*-
import datetime
import json
import logging
from collections import OrderedDict
from operator import itemgetter

import dateutil.parser
import dateutil.tz
from delia_tokenizer.ctokenize import (ScannerFromString,
                                       ScannerFromFile)

from delia_commons.exceptions import (
    UnusedDeclarations,
    UnusedDeclaration)

import delia_commons
from delia_codegen.assignments import Assignments
from delia_codegen.codeblock import (CodeBlock,
                                     CodeBlockNames,
                                     Locations)
from delia_codegen.collector import Collector
from delia_codegen.controlflow import ControlFlow
from delia_codegen.controls import Controls
from delia_codegen.convert_type import do_convert
from delia_codegen.declarations import Declarations
from delia_codegen.expressions import Expressions
from delia_codegen.interfaces import Interfaces
from delia_codegen.mapper import Mapper
from delia_codegen.queries import Queries
from delia_codegen.screens import Screens
from delia_codegen.utils import adl_name_to_py_name
from delia_commons.exceptions import DeliaError
from delia_commons.exceptions import (SemanticErrors,
                                      SemanticWarnings)
from delia_parser import types, ast, pictures
from delia_parser import validate, annotate
from delia_parser.compile_context import CompileContext
from delia_parser.parser import parse, gen_ast
from delia_parser.visitor import walk
from delia_preprocessor import scan
from delia_commons.errors import ErrorCode, get_error_msg


logger = logging.getLogger('delia.codegen')


def logthis(level):
    def _decorator(fn):
        def _decorated(*arg, **kwargs):
            logger.log(level, "calling '%s'(%r,%r)", fn.__name__, arg, kwargs)
            ret = fn(*arg, **kwargs)
            logger.log(
                level,
                "called '%s'(%r,%r) got return value: %r",
                fn.__name__,
                arg,
                kwargs,
                ret)
            return ret

        return _decorated

    return _decorator


def compile_file(filepath, schema_tree=None, compile_ctx=None, proc_name=None):
    if compile_ctx is None:
        compile_ctx = CompileContext(root=ast.Root())
    scanner = ScannerFromFile(filepath)
    gen = Procedure(compile_ctx, scanner)
    gen.compile(schema_tree, proc_name=proc_name)
    if compile_ctx.mapping_enabled:
        return gen.get_code(), gen.get_mapping()
    else:
        return gen.get_code(), None


def compile(source, schema_tree=None, compile_ctx=None, proc_name=None):
    if not compile_ctx:
        compile_ctx = CompileContext(root=ast.Root())
    scanner = ScannerFromString(source)
    gen = Procedure(compile_ctx, scanner)
    gen.compile(schema_tree, proc_name=proc_name)
    code = gen.get_code()
    if compile_ctx.mapping_enabled:
        mapping = gen.get_mapping()
    else:
        mapping = None
    if compile_ctx.with_unused_warns:
        warns = gen.warns
    else:
        warns = None
    return code, mapping, warns


def compile_schema_file(filepath, compile_ctx=None):
    if compile_ctx is None:
        compile_ctx = CompileContext(root=ast.Root())
    scanner = ScannerFromFile(filepath)
    gen = Schema(compile_ctx, scanner)
    return gen.get_tree()


def compile_schema(source, compile_ctx=None):
    if compile_ctx is None:
        compile_ctx = CompileContext(root=ast.Root())
    scanner = ScannerFromString(source)
    gen = Schema(compile_ctx, scanner)
    return gen.get_tree()


def gen_schema_file(filepath, compile_ctx=None):
    if compile_ctx is None:
        compile_ctx = CompileContext(root=ast.Root())
    scanner = ScannerFromFile(filepath)
    gen = Schema(compile_ctx, scanner)
    gen.compile()
    return gen.get_code()


def gen_schema(source, compile_ctx=None):
    if compile_ctx is None:
        compile_ctx = CompileContext(root=ast.Root())
    scanner = ScannerFromString(source)
    gen = Schema(compile_ctx, scanner)
    gen.compile()
    return gen.get_code()


class AbstractCompileProcedure:
    def __init__(self, compile_ctx, scanner):
        self.compile_ctx = compile_ctx
        self.scanner = scanner
        self.code = None
        self.warns = None
        self.mapper = None

    def _get_tree(self):
        tokens = scan(
            self.scanner,
            self.scanner.path,
            files=self.compile_ctx.files,
            acros=self.compile_ctx.macros)
        parser = gen_ast.Parser(verbose=False)
        parse(self.compile_ctx, tokens=iter(tokens), parser=parser)
        return self.compile_ctx.ast

    def compile(self, schema_tree=None):
        pass  # implemented by subclass

    def get_code(self):
        return self.code

    def get_mapping(self):
        if self.mapper:
            return self.mapper.get()
        else:
            return None


class Procedure(AbstractCompileProcedure):
    def compile(self, schema_tree=None, proc_name=None):
        tree = self._get_tree().procedure
        gen = ProcedureCodeGenerator(self.compile_ctx)
        gen.run(tree, schema_tree, proc_name=proc_name)
        if self.compile_ctx.mapping_enabled:
            gen.gen_mapping()
            self.mapper = gen.get_mapper()
        self.code = gen.get_code()
        self.warns = gen.warns


class Schema(AbstractCompileProcedure):
    def get_tree(self):
        return self._get_tree().schema

    def compile(self):
        tree = self._get_tree().schema
        gen = SchemaCodeGenerator(self.compile_ctx)
        gen.run(tree)
        self.code = gen.get_code()


class CodeGeneratorBackend(Assignments,
                           Declarations,
                           ControlFlow,
                           Controls,
                           Expressions,
                           Queries,
                           Interfaces,
                           Screens):
    """Defines basic code generator for ADL
    This class is an abstract base class.
    """

    def __init__(self, compile_ctx, visit=None):
        self.compile_ctx = compile_ctx
        self.in_report_decl = False
        self.in_schema = False
        self.got_schema = False
        self.gen_schema_only = False
        self.to_validate = self.compile_ctx.to_validate
        self.gen_not_used = self.compile_ctx.gen_not_used
        self.metadata = self.deserialize_metadata(self.compile_ctx.jmetadata)

        self.visit = visit
        self.src = None
        if self.compile_ctx.mapping_enabled:
            self.mapper = Mapper(macro=self.compile_ctx.macro_list, file=self.compile_ctx.files, absolute=self.compile_ctx.mapping_absolute)
        self.warns = UnusedDeclarations()

    def gen_unused(self, node):
        if not node.used and not self.in_schema and self.compile_ctx.files.index(node.path) <= 3:
            e = UnusedDeclaration(ErrorCode.DECLARATION_UNUSED, get_error_msg(ErrorCode.DECLARATION_UNUSED, type_=node.__class__.__name__, name=node.name),
                                  node.path, node.lineno, node.column)
            self.warns.add_warn(e)

    def set_src(self, src, node=None):
        self.src = src

    def get_src(self):
        return self.src

    def deserialize_metadata(self, jmetadata):
        if jmetadata is None:
            metadata = {}
        else:
            metadata = json.loads(jmetadata)

        if "COMPILE_DATETIME" not in [key.upper() for key in metadata]:
            metadata["COMPILE_DATETIME"] = datetime.datetime.now(dateutil.tz.tzlocal()).isoformat()
        else:
            try:
                dateutil.parser.parse(metadata["COMPILE_DATETIME"])
            except ValueError:
                raise DeliaError("Date compile must be string in ISO 8601 format")

        if "COMPILER_VERSION" not in [key.upper() for key in metadata]:
            metadata["COMPILER_VERSION"] = delia_commons.__version__

        if "COMPATIBILITY_VERSION" not in [key.upper() for key in metadata]:
            metadata["COMPATIBILITY_VERSION"] = delia_commons.__compatibility_version__

        metadata['CALLED_PROCEDURES'] = []

        return metadata

    def validate(self, tree, proc_name=None):
        if not hasattr(self, "validation_visitor"):
            setattr(self, "validation_visitor", validate.Validator(self.compile_ctx, proc_name=proc_name))
        else:
            self.validation_visitor.proc_name = proc_name
        walk(tree, self.validation_visitor)

    def annotate(self, tree):
        if not hasattr(self, "annotation_visitor"):
            setattr(self, "annotation_visitor", annotate.Annotator(self.compile_ctx))
        walk(tree, self.annotation_visitor)

    def annotate_and_validate(self, node, proc_name=None):
        self.annotate(node)
        try:
            self.validate(node, proc_name)
        except SemanticErrors as err:
            """
            errors = err.get_last_errors()
            for error in errors:
               print(error)
            """
            raise err
        # Only catch warnings, error shall block the code generation
        except SemanticWarnings as warn:
            # Clean warnings for the next validation
            warn.clear_warn()

    @logthis(logging.DEBUG)
    def gen_Procedure(self, node):
        if self.gen_schema_only:
            return

        receiving_parameters = node.receiving_parameters
        returning_parameters = node.returning_parameters
        if self.compile_ctx.mapping_enabled:
            self.mapper.proc_name = self.proc_name
            self.mapper.schema_name = self.schema_name if self.got_schema else None
            self.mapper.set_metadata(self.metadata)

        if not self.got_schema:
            self.force_literal_value = False
            self.not_use_literal_value = False
            self.dd_dict = dict() # data description dictionary
            self.dd_names = dict() # data description names dictionary
            self.collector = Collector()
            self.num_literals = {}
            self.str_literals = {}
            self.codeblocks()

        self.constants = set()
        self.set_src(self.source[CodeBlockNames.ROOT], node)
        self.src.add(self.source[CodeBlockNames.HEADER])

        self.src.newline("class Procedure(AdlProcedure):")
        self.src.indent()
        self.src.newline("procedure_name = '%s'" % self.proc_name)
        if self.got_schema:
            self.src.newline("schema_name = '%s'" % self.schema_name)
        else:
            self.src.newline("schema_name = None")
        self.src.newline()

        self.src.add(self.source[CodeBlockNames.METADATA])
        self.src.newline()

        if receiving_parameters:
            self.src.newline("def is_procargs_valid(self, procargs=[]):")
            self.src.indent()
            self.src.add(self.source[CodeBlockNames.RECEIVING_PARAMS_VALIDITY])
            self.src.dedent()
            self.src.newline()

        self.src.set_locations(node.locations)
        self.src.newline("def body(self, procargs=[]):")
        self.src.indent()

        self.src.newline("_rrun = self.rrun")
        self.src.newline("_abort = self.abort")
        self.src.newline("_returning = self.returning")
        self.src.newline("_logout = self.logout")
        self.src.newline("_type = self.type")
        self.src.newline("_type_to_terminal = self.type_to_terminal")
        self.src.newline("_type_to_message_area = self.type_to_message_area")
        self.src.newline("_wait = self.wait")
        self.src.newline("_pause = self.pause")
        self.src.newline("_pause_for_input = self.pause_for_input")
        self.src.newline("_vms_to_unix = self.vms_to_unix")
        self.src.newline("_load_fli = self.load_fli")
        self.src.newline("_data_descs = self.data_descs")
        self.src.newline("_frames = self.frames")
        self.src.newline("_relations = self.relations")
        self.src.newline("_sources = self.sources")
        self.src.newline("_insert = self.insert")
        self.src.newline("_update = self.update")
        self.src.newline("_delete = self.delete")
        self.src.newline("_delete_viakey = self.delete_viakey")
        self.src.newline("_select = self.select")
        self.src.newline("if hasattr(self, 'select_join'):")
        self.src.indent()
        self.src.newline("_select_join = self.select_join")
        self.src.dedent()
        self.src.newline("_select_viakey = self.select_viakey")
        self.src.newline("_foreach = self.foreach")
        self.src.newline("_foreach_join = self.foreach_join")
        self.src.newline()

        self.src.newline("#  L I T E R A L S")
        self.src.newline("_ = self.literal")
        self.src.add(self.source[CodeBlockNames.LITERAL])
        self.src.newline()

        self.src.newline("#  N A M E S P A C E S")
        self.src.add(self.source[CodeBlockNames.NS])
        self.src.add(self.source[CodeBlockNames.FUNCTION_NS])
        self.src.newline()

        self.src.newline("#  C O N T R O L S")
        self.src.newline("procedure._users_language = self._users_language = ")
        self.src.write(self.add_String('ENGLISH'))
        self.src.newline("procedure._date_language = self._date_language = ")
        self.src.write(self.add_String('ENGLISH'))
        self.src.newline("procedure._digit_separator = self._digit_separator = ',.'")
        self.src.add(self.source[CodeBlockNames.CONTROL])
        self.src.newline()

        self.write_codeblocks(CodeBlockNames.CONSTANT_NS, "#  C O N S T A N T S")
        self.write_codeblocks(CodeBlockNames.CONSTANT)
        self.write_codeblocks(CodeBlockNames.FIELD, "# F I E L D S")
        self.write_codeblocks(CodeBlockNames.ARRAY, "# A R R A Y S")
        self.write_codeblocks(CodeBlockNames.FLI, "# F L I S")
#         self.write_codeblocks(CodeBlockNames.FUNCTION, "#  F U N C T I O N S")
        self.src.newline("#  F U N C T I O N S")
        self.src.add(self.source[CodeBlockNames.FUNCTION])

        self.write_codeblocks(CodeBlockNames.FUNCTION_KEYS, "#  F U N C T I O N S . K E Y")
        self.write_codeblocks(CodeBlockNames.FUNCTION_KEYS_DICT)
        self.write_codeblocks(CodeBlockNames.REPORT_DECLARATION, "#  R E P O R T S")
        self.write_codeblocks(CodeBlockNames.REPORT_INSTANCE)

        self.src.newline("#  B O D Y", no_locations=True)
        self.src.newline("self._start()", no_locations=True)
        self.src.add(self.source[CodeBlockNames.BODY])
        self.src.stop_gen_locations()
        self.src.dedent()

        self.src.newline()
        self.src.newline("#  D A T A  D E S C R I P T I O N")
        self.src.newline("def data_desc(self):")
        self.src.indent()
        self.src.newline("_data_descs = self.data_descs")
        self.src.add(self.source[CodeBlockNames.DATA_DESC])
        self.src.dedent()

        self.src.newline()
        self.src.newline("#  S C H E M A")
        self.src.newline("def schema(self):")
        self.src.indent()
        self.src.newline("_relations = self.relations")
        self.src.add(self.source[CodeBlockNames.RELATION])
        self.src.dedent()

        self.src.newline("#  Q U E R I E S")
        self.src.newline("def queries(self):")
        self.src.indent()
        self.src.newline("_ = self.literal")
        self.src.newline("_relations = self.relations")
        self.src.add(self.source[CodeBlockNames.RELATION_LOCAL])
        self.write_codeblocks(CodeBlockNames.INSERT, "# I N S E R T")
        self.write_codeblocks(CodeBlockNames.ALTER, "# A L T E R")
        self.write_codeblocks(CodeBlockNames.DELETE, "# D E L E T E")
        self.write_codeblocks(CodeBlockNames.DELETE_VIA_KEY, "# D E L E T E - V I A K E Y")
        self.write_codeblocks(CodeBlockNames.SELECT, "# S E L E C T")
        self.write_codeblocks(CodeBlockNames.SELECT_JOIN, "# S E L E C T - J O I N")
        self.write_codeblocks(CodeBlockNames.SELECT_VIA_KEY, "# S E L E C T - V I A K E Y")
        self.write_codeblocks(CodeBlockNames.FOR_EACH, "# F O R E A C H")
        self.write_codeblocks(CodeBlockNames.FOR_EACH_JOIN, "# F O R E A C H - J O I N")
        self.src.dedent()

        self.src.newline("#  S C R E E N")
        self.src.newline("def screen(self):")
        self.src.indent()
        self.src.newline("_ = self.literal")
        self.src.newline("_frames = self.frames")
        self.src.add(self.source[CodeBlockNames.FRAME])
        self.src.dedent()

        self.src.newline()
        self.src.newline("#  S O U R C E")
        self.src.newline("def source(self):")
        self.src.indent()
        self.src.newline("_ = self.literal")
        self.src.newline("_sources = self.sources")
        self.src.add(self.source[CodeBlockNames.SOURCE])
        self.src.dedent()
        self.src.newline()

        self.src.dedent()
        self.build_header()

        # Create fields for input/output parameters if not defined in the schema.
        for param in receiving_parameters:
            if param not in node.params_in_schema:
                self.visit(param)

        for param in returning_parameters:
            if param not in node.params_in_schema:
                # returning parameters declared in the receiving parameters.
                if isinstance(param, ast.Name) and param.definition in receiving_parameters:
                    continue
                else:
                    self.visit(param)

        self.visit(node.decls)

        self.set_src(self.source[CodeBlockNames.BODY])

        self.receiving_parameters(receiving_parameters)

        self.visit(node.stmts)

        self.src.newline()
        self.src.newline("self._finish()")
        self.return_at_the_end(returning_parameters)

        self.build_namespaces()
        self.build_functions_key_dict(node)
        self.build_literals()
        self.build_constants()
        self.build_queries()
        self.build_metadata()

    def gen_Schema(self, node):

        self.got_schema = True

        self.force_literal_value = False
        self.not_use_literal_value = False
        self.dd_dict = dict()
        self.dd_names = dict()
        self.collector = Collector()
        self.num_literals = {}
        self.str_literals = {}
        self.codeblocks()

        if self.gen_schema_only:
            self.set_src(self.source[CodeBlockNames.ROOT], node)
            self.src.add(self.source[CodeBlockNames.HEADER])

            self.build_header_schema()

            self.src.newline("class Schema(AdlSchema):")
            self.src.indent()
            self.src.newline("schema_name = '%s'" % self.schema_name)
            self.src.newline()

            self.src.set_locations(node.locations)

            self.src.newline("#  S C H E M A")
            self.src.newline("def schema(self):")
            self.src.indent()
            self.src.newline("_relations = self.relations")
            self.src.add(self.source[CodeBlockNames.RELATION])
            self.src.dedent()
        self.visit(node.decls)

    def write_codeblocks(self, codeblock_name, comment=None):
        if comment is not None:
            self.src.newline(comment)
        self.src.add(self.source[codeblock_name])
        self.src.newline()

    def build_header_schema(self):
        self.source[CodeBlockNames.HEADER].code.append("# -*- coding: utf-8 -*-")
        self.source[CodeBlockNames.HEADER].newline()

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.core import AdlSchema")
        self.source[CodeBlockNames.HEADER].newline("from adl.lang.rsb import AdlRelation")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline()
        self.source[CodeBlockNames.HEADER].newline()

    def codeblocks(self):
        self.source = {}
        for block in CodeBlockNames:
            self.source[block] = CodeBlock()

    def build_header(self):
        self.source[CodeBlockNames.HEADER].code.append("# -*- coding: utf-8 -*-")
        self.source[CodeBlockNames.HEADER].newline()

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.core import AdlProcedure")
        self.source[CodeBlockNames.HEADER].newline(
            "from adl.lang.namespace import NamespaceFactory, FunctionNamespaceFactory")

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.builtin import *")

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.format import (")
        self.source[CodeBlockNames.HEADER].indent()
        self.source[CodeBlockNames.HEADER].newline("adl_date_format,")
        self.source[CodeBlockNames.HEADER].newline("adl_numeric_format,")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline(")")

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.data_description import (")
        self.source[CodeBlockNames.HEADER].indent()
        self.source[CodeBlockNames.HEADER].newline("StringDataDescription,")
        self.source[CodeBlockNames.HEADER].newline("DateDataDescription,")
        self.source[CodeBlockNames.HEADER].newline("IntegerDataDescription,")
        self.source[CodeBlockNames.HEADER].newline("DecimalDataDescription,")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline(")")

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.parse import (")
        self.source[CodeBlockNames.HEADER].indent()
        self.source[CodeBlockNames.HEADER].newline("adl_decimal_parse,")
        self.source[CodeBlockNames.HEADER].newline("adl_integer_parse,")
        self.source[CodeBlockNames.HEADER].newline("adl_date_parse,")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline(")")

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.test import (")
        self.source[CodeBlockNames.HEADER].indent()
        self.source[CodeBlockNames.HEADER].newline("adl_test_int_is_num,")
        self.source[CodeBlockNames.HEADER].newline("adl_test_dec_is_num,")
        self.source[CodeBlockNames.HEADER].newline("adl_test_int_is_str,")
        self.source[CodeBlockNames.HEADER].newline("adl_test_dec_is_str,")
        self.source[CodeBlockNames.HEADER].newline("adl_test_num_is_date,")
        self.source[CodeBlockNames.HEADER].newline("adl_test_str_is_int,")
        self.source[CodeBlockNames.HEADER].newline("adl_test_str_is_dec,")
        self.source[CodeBlockNames.HEADER].newline("adl_test_str_is_date,")
        self.source[CodeBlockNames.HEADER].newline("adl_test_date_is_num,")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline(")")

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.lazy import (")
        self.source[CodeBlockNames.HEADER].indent()
        self.source[CodeBlockNames.HEADER].newline("adl_decimal_format_lz,")
        self.source[CodeBlockNames.HEADER].newline("adl_integer_format_lz,")
        self.source[CodeBlockNames.HEADER].newline("adl_decimal_parse_lz,")
        self.source[CodeBlockNames.HEADER].newline("adl_test_dec_is_str_lz,")
        self.source[CodeBlockNames.HEADER].newline("adl_test_str_is_dec_lz,")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline(")")

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.label import (")
        self.source[CodeBlockNames.HEADER].indent()
        self.source[CodeBlockNames.HEADER].newline("Label,")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline(")")

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.io import (")
        self.source[CodeBlockNames.HEADER].indent()
        self.source[CodeBlockNames.HEADER].newline("adl_file_exists,")
        self.source[CodeBlockNames.HEADER].newline("adl_file_delete,")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline(")")

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.queries import (")
        self.source[CodeBlockNames.HEADER].indent()
        self.source[CodeBlockNames.HEADER].newline("InnerJoin,")
        self.source[CodeBlockNames.HEADER].newline("LeftOuterJoin,")
        self.source[CodeBlockNames.HEADER].newline("RightOuterJoin,")
        self.source[CodeBlockNames.HEADER].newline("FullOuterJoin,")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline(")")

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.source import (")
        self.source[CodeBlockNames.HEADER].indent()
        self.source[CodeBlockNames.HEADER].newline("AdlSource,")
        self.source[CodeBlockNames.HEADER].newline("ForEachSource,")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline(")")

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.report import AdlReport")

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.array import AdlArray")
        self.source[CodeBlockNames.HEADER].newline("from adl.lang.rsb import AdlRelation")
        self.source[CodeBlockNames.HEADER].newline("from adl.lang.frame import (")
        self.source[CodeBlockNames.HEADER].indent()
        self.source[CodeBlockNames.HEADER].newline("AdlFrame,")
        self.source[CodeBlockNames.HEADER].newline("AdlDisplay,")
        self.source[CodeBlockNames.HEADER].newline("adl_clear_frame,")
        self.source[CodeBlockNames.HEADER].newline("adl_clear_frame_with_stack,")
        self.source[CodeBlockNames.HEADER].newline("adl_restore_frame,")
        self.source[CodeBlockNames.HEADER].newline("adl_restore_frame_with_stack,")
        self.source[CodeBlockNames.HEADER].newline("adl_input_field,")
        self.source[CodeBlockNames.HEADER].newline("adl_input_array_field,")
        self.source[CodeBlockNames.HEADER].newline("adl_field_update,")
        self.source[CodeBlockNames.HEADER].newline("adl_field_update_with_stack,")
        self.source[CodeBlockNames.HEADER].newline("adl_array_field_update,")
        self.source[CodeBlockNames.HEADER].newline("adl_array_field_update_with_stack,")
        self.source[CodeBlockNames.HEADER].newline("adl_get_ns_with_field_from_frames_stack_ns,")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline(")")

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.accept import adl_accept")

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.math import (")
        self.source[CodeBlockNames.HEADER].indent()
        self.source[CodeBlockNames.HEADER].newline("adl_modulo,")
        self.source[CodeBlockNames.HEADER].newline("adl_sqrt,")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline(")")

        self.source[CodeBlockNames.HEADER].newline("from adl.lang.comparator import (")
        self.source[CodeBlockNames.HEADER].indent()
        self.source[CodeBlockNames.HEADER].newline("adl_and,")
        self.source[CodeBlockNames.HEADER].newline("adl_or,")
        self.source[CodeBlockNames.HEADER].newline("adl_ext_and,")
        self.source[CodeBlockNames.HEADER].newline("adl_ext_or,")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline(")")

        self.source[CodeBlockNames.HEADER].newline("from collections import OrderedDict")
        self.source[CodeBlockNames.HEADER].newline("from datetime import (")
        self.source[CodeBlockNames.HEADER].indent()
        self.source[CodeBlockNames.HEADER].newline("date as _date,")
        self.source[CodeBlockNames.HEADER].newline("timedelta as _timedelta,")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline(")")

        self.source[CodeBlockNames.HEADER].newline("from decimal import (")
        self.source[CodeBlockNames.HEADER].indent()
        self.source[CodeBlockNames.HEADER].newline("Context,")
        self.source[CodeBlockNames.HEADER].newline("Decimal,")
        self.source[CodeBlockNames.HEADER].newline("getcontext,")
        self.source[CodeBlockNames.HEADER].newline("localcontext,")
        self.source[CodeBlockNames.HEADER].newline("ROUND_HALF_UP,")
        self.source[CodeBlockNames.HEADER].newline("ROUND_DOWN,")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline(")")
        self.source[CodeBlockNames.HEADER].newline("getcontext().prec = 30")
        self.source[CodeBlockNames.HEADER].newline("getcontext().rounding = ROUND_HALF_UP")

        self.source[CodeBlockNames.HEADER].newline("truncateContext = Context(")
        self.source[CodeBlockNames.HEADER].indent()
        self.source[CodeBlockNames.HEADER].newline("prec=getcontext().prec,")
        self.source[CodeBlockNames.HEADER].newline("rounding=ROUND_DOWN,")
        self.source[CodeBlockNames.HEADER].dedent()
        self.source[CodeBlockNames.HEADER].newline(")")
        self.source[CodeBlockNames.HEADER].newline()
        self.source[CodeBlockNames.HEADER].newline()

    def build_namespaces(self):
        self.source[CodeBlockNames.NS].newline("_names = (")
        self.source[CodeBlockNames.NS].indent()
        for pos, array in enumerate(sorted(self.collector.arrays)):
            if pos % 10 == 0:
                self.source[CodeBlockNames.NS].newline()
            else:
                self.source[CodeBlockNames.NS].write(" ")
            self.source[CodeBlockNames.NS].write("'%s'," % array)
        for pos, field in enumerate(sorted(self.collector.fields + ['_users_language', '_date_language', '_digit_separator'])):
            if pos % 10 == 0:
                self.source[CodeBlockNames.NS].newline()
            else:
                self.source[CodeBlockNames.NS].write(" ")
            self.source[CodeBlockNames.NS].write("'%s'," % field)
        self.source[CodeBlockNames.NS].dedent()
        self.source[CodeBlockNames.NS].newline(")")
        self.source[CodeBlockNames.NS].newline()
        self.source[CodeBlockNames.NS].newline("procedure = NamespaceFactory('{proc}', _names).maker()".format(proc=self.proc_name))

    def build_literals(self):
        self.source[CodeBlockNames.LITERAL].newline(
            "%s = %s" % (self.get_date_min(), self.get_date_min(force_literal_value=True)))
        self.source[CodeBlockNames.LITERAL].newline(
            "%s = %s" % (self.get_date_max(), self.get_date_max(force_literal_value=True)))

        for val, literal_name in sorted(self.num_literals.items(), key=itemgetter(1)):
            self.source[CodeBlockNames.LITERAL].newline("%s = %s" % (literal_name, val))
        for val, literal_name in sorted(self.str_literals.items(), key=itemgetter(1)):
            self.source[CodeBlockNames.LITERAL].newline("%s = %s" % (literal_name, val))

    def build_constants(self):

        self.source[CodeBlockNames.CONSTANT_NS].newline("_constants_names = (")
        self.source[CodeBlockNames.CONSTANT_NS].indent()
        for pos, constant_name in enumerate(sorted(self.constants)):
            if pos % 10 == 0:
                self.source[CodeBlockNames.CONSTANT_NS].newline()
            else:
                self.source[CodeBlockNames.CONSTANT_NS].write(" ")
            self.source[CodeBlockNames.CONSTANT_NS].write("'%s'," % constant_name)
        self.source[CodeBlockNames.CONSTANT_NS].dedent()
        self.source[CodeBlockNames.CONSTANT_NS].newline(")")
        self.source[CodeBlockNames.CONSTANT_NS].newline()
        self.source[CodeBlockNames.CONSTANT_NS].newline("constants = NamespaceFactory('Constants', _constants_names).maker()".format())

    def build_metadata(self):
        src = self.source[CodeBlockNames.METADATA]
        src.newline("metadata = {")
        src.indent()
        metadata = OrderedDict(sorted(self.metadata.items()))
        for key, data in metadata.items():
            src.newline("{!r}: {!r},".format(key, data))
        src.dedent()
        src.newline("}")

    def build_functions_key_dict(self, node):
        self.set_src(self.source[CodeBlockNames.FUNCTION_KEYS_DICT], node)
        self.src.newline("_function_separator = chr(27)")
        self.src.newline("_function_keys_dict = ")

        procedure_scope = node.scope

        functions_key_global = procedure_scope.functions_key_global
        functions_key_local = procedure_scope.functions_key_local
        functions_key_dict = OrderedDict()

        for function_key in filter(lambda fk: fk.used, functions_key_global + functions_key_local):
            func_name = adl_name_to_py_name(function_key.name)
            key = function_key.sequence

            assert (isinstance(key, (ast.String, ast.ConstantRef)))

            while not isinstance(key, ast.String):
                if isinstance(key, ast.ConstantRef):
                    key = key.definition.value
                    continue
                break

            assert (isinstance(key, ast.String))
            assert (isinstance(key, ast.Literal))

            if str(key) not in functions_key_dict:
                functions_key_dict[str(key)] = [func_name]
            else:
                functions_key_dict[str(key)].append(func_name)

        if not functions_key_dict:
            self.src.write("{}")
        else:
            self.src.write("{")
            self.src.indent()
            for key, func_list in functions_key_dict.items():
                self.src.newline("(_function_separator")
                self.src.write(" + ")
                self.src.write(self.add_String(key))
                self.src.write("): (")
                for func in func_list:
                    self.src.write("%s, " % func)
                self.src.write("),")
            self.src.dedent()
            self.src.newline("}")

    def receiving_parameters(self, receiving_parameters):

        # Check param validity
        count_params = len(receiving_parameters)
        if count_params > 0:
            src_valid = self.source[CodeBlockNames.RECEIVING_PARAMS_VALIDITY]
            src_valid.newline("if len(procargs) == 0:")
            src_valid.indent()
            src_valid.newline("return True")
            src_valid.dedent()
            src_valid.newline("elif len(procargs) != %d:" % count_params)
            src_valid.indent()
            src_valid.newline("return False")
            src_valid.dedent()
            src_valid.newline("else:")
            src_valid.indent()

            all_parameters_are_string = not any(
                param for param in receiving_parameters if param.type is not types.String())
            if all_parameters_are_string:
                src_valid.newline("return True")
            else:
                src_valid.newline("try:")
                src_valid.indent()

                for pos, param in enumerate(receiving_parameters):

                    from_type = types.String()
                    from_pict = pictures.UnknownPicture()

                    to_type = param.definition.type
                    to_pict = param.definition.picture.picture

                    if to_type is types.String():
                        continue

                    convert_function = []
                    convert_function = do_convert(self,
                                                  to_type,
                                                  to_pict,
                                                  from_type,
                                                  from_pict,
                                                  convert_function,
                                                  strict=False,
                                                  default_decimal_sep=True)

                    src_valid.newline()

                    for (header, _) in reversed(convert_function):
                        if header is not None:
                            src_valid.write(header)

                    src_valid.write("procargs[%d]" % pos)

                    for (_, footer) in convert_function:
                        if footer is not None:
                            src_valid.write(footer)

                src_valid.dedent()
                src_valid.newline("except:")
                src_valid.indent()
                src_valid.newline("return False")
                src_valid.dedent()
                src_valid.newline("return True")
                src_valid.dedent()

            # Convert param from string
            self.src.newline("if len(procargs) != 0:")
            self.src.indent()

            for pos, param in enumerate(receiving_parameters):

                param_py_name = adl_name_to_py_name(param.definition.name)

                # Implicit conversion of input parameters
                from_type = types.String()
                from_pict = pictures.UnknownPicture()

                to_type = param.definition.type
                to_pict = param.definition.picture.picture

                convert_function = []
                convert_function = do_convert(self,
                                              to_type,
                                              to_pict,
                                              from_type,
                                              from_pict,
                                              convert_function,
                                              strict=False)

                self.src.newline("procedure.%s = " % adl_name_to_py_name(param_py_name))

                for (header, _) in reversed(convert_function):
                    if header is not None:
                        self.src.write(header)

                self.src.write("procargs[%d]" % pos)

                for (_, footer) in convert_function:
                    if footer is not None:
                        self.src.write(footer)

            self.src.dedent()

    def return_at_the_end(self, returning_parameters):

        self.src.stop_gen_locations()
        self.src.newline("return ")

        self.src.write("[")

        for param in returning_parameters:

            # Stringify ouptut parameters
            from_type = param.definition.type
            from_pict = param.definition.picture.picture

            to_type = types.String()
            to_pict = pictures.UnknownPicture()

            convert_function = []
            convert_function = do_convert(self,
                                          to_type,
                                          to_pict,
                                          from_type,
                                          from_pict,
                                          convert_function)

            for (header, _) in reversed(convert_function):
                if header is not None:
                    self.src.write(header)

            self.src.write("procedure.%s" % adl_name_to_py_name(param.definition.name))

            for (_, footer) in convert_function:
                if footer is not None:
                    self.src.write(footer)

            if param != returning_parameters[-1]:
                self.src.write(", ")

        self.src.write("]")

    def get_code(self):
        return self.source[CodeBlockNames.ROOT].flatten()

    def gen_mapping(self):
        self.source[CodeBlockNames.ROOT].gen_mapping(self.mapper)

    def get_mapping(self):
        self.gen_mapping()
        return self.mapper.get()

    def get_mapper(self):
        return self.mapper


class ProcedureCodeGenerator(CodeGeneratorBackend):
    def locations_handler(self, locations):
        Locations().set_locations(locations)

    def run(self, tree, schema_tree, verbose=False, proc_name=None):
        self.proc_name = adl_name_to_py_name(tree.name)

        if schema_tree is not None:
            if self.to_validate:
                self.annotate_and_validate(schema_tree)
            else:
                self.annotate(schema_tree)

        if self.to_validate:
            self.annotate_and_validate(tree, proc_name=proc_name)
        else:
            self.annotate(tree)

        if self.compile_ctx.mapping_enabled:
            locations_handler = self.locations_handler
        else:
            locations_handler = None

        if schema_tree is not None:
            self.in_schema = True
            self.schema_name = adl_name_to_py_name(schema_tree.name)
            walk(schema_tree, self, prefix='gen_', verbose=verbose, locations_handler=locations_handler)
        self.in_schema = False
        walk(tree, self, prefix='gen_', verbose=verbose, locations_handler=locations_handler)


class SchemaCodeGenerator(CodeGeneratorBackend):
    def locations_handler(self, locations):
        if self.get_src():
            self.get_src().set_locations(locations)

    def run(self, schema_tree, verbose=False):
        self.gen_schema_only = True
        if self.to_validate:
            self.annotate_and_validate(schema_tree)
        else:
            self.annotate(schema_tree)

        if self.compile_ctx.mapping_enabled:
            locations_handler = self.locations_handler
        else:
            locations_handler = None

        self.in_schema = True
        self.schema_name = adl_name_to_py_name(schema_tree.name)
        walk(schema_tree, self, prefix='gen_', verbose=verbose, locations_handler=locations_handler)
        self.in_schema = False
