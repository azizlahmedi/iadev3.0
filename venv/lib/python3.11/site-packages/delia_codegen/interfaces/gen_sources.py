from delia_codegen.utils import adl_name_to_py_name
from delia_codegen.convert_type import do_convert
from delia_codegen.codeblock import CodeBlockNames
from delia_parser import ast, types, pictures


class Source:
    list_complex_conditions = []

    def log_DELIA_3356(self, node):
        import os
        from delia_commons import default_delia_path
        if node.locations not in self.list_complex_conditions:
            open(os.path.join(default_delia_path, "list_complex_conditions.log"), "at").write(f"{node.locations} {self.proc_name}\n")
            self.list_complex_conditions.append(node.locations)

    def gen_SourceInputId(self, node):
        self.gen_Id(node)

    def gen_next_fields(self, query_name, source_pyname, using_input_list):
        self.src.newline("%s.getNextFields(%s"
                         % (query_name, source_pyname))
        self.src.write(", using=(")
        for using in using_input_list:
            if isinstance(using, ast.SourceInputId):
                self.src.write("'%s', " % adl_name_to_py_name(using.name))
            elif isinstance(using, ast.SourceInputArrayId):
                self.src.write("(")
                self.src.write("'%s', " % adl_name_to_py_name(using.array_definition.name))
                self.src.write("'%s', " % adl_name_to_py_name(using.name))
                lower_bound = using.array_definition.lower_bound
                upper_bound = using.array_definition.upper_bound
                self.array_index(using.index.index, using.check_subscripts, lower_bound, upper_bound)
                self.src.write("), ")
        self.src.write("))")

    def gen_Source(self, node):
        self.gen_unused(node)

        if not node.used:
            return

        self.set_src(self.source[CodeBlockNames.SOURCE], node)
        source_name = str(node.name)
        source_pyname = adl_name_to_py_name(node.name)
        self.src.newline("_sources['%s'] = AdlSource(" % source_pyname)
        self.src.indent()

        self.src.newline("name='%s'," % source_name)

        # TODO:
        prompt = node.prompt

        for attr in node.attributes:

            if isinstance(attr, ast.SourceFixedForm):
                self.src.newline("kind='fixed',")

            elif isinstance(attr, ast.SourceFreeForm):
                self.src.newline("kind='free',")

            elif isinstance(attr, ast.SourceSeparator):
                self.src.newline("separator='%s'," % str(attr.value))

            elif isinstance(attr, ast.SourceInport):
                # Don't care ?
                pass

            elif isinstance(attr, ast.SourceInvalids):
                # Don't care ?
                pass

            elif isinstance(attr, ast.SourceLineLength):
                # Don't care ?
                pass

            elif isinstance(attr, ast.SourceBinaryForm):
                # Don't care ?
                pass

        input_Ids = [_input for _input in node.input_set if isinstance(_input, ast.SourceInputId)]
        input_ArrayIds = [_input for _input in node.input_set if isinstance(_input, ast.SourceInputArrayId)]

        if input_Ids:

            self.src.newline("fields=(")
            self.src.indent()

            for _input in input_Ids:

                if _input.input_picture is not None:
                    _picture = _input.input_picture.picture.picture
                    _type = _input.input_picture.type
                    _default = self.get_default_from_picture(_type, _input.input_picture.picture, force_literal_value=True)
                else:
                    _picture = _input.definition.picture.picture
                    _type = _input.type
                    _default = self.get_default_value(_input, force_literal_value=True)

                if _type is types.Integer():
                    datatype = 'integer'
                    size = _picture._get_size()
                    total, decimal_digits = _picture.get_digits()
                    integer_digits = total - decimal_digits
                    subtype = '({size}, {integer_digits})'.format(
                        size=size,
                        integer_digits=integer_digits,
                    )

                elif _type is types.Decimal():
                    datatype = 'decimal'
                    size = _picture._get_size()
                    total, decimal_digits = _picture.get_digits()
                    integer_digits = total - decimal_digits
                    if _picture._get_point() == 'V':
                        decimal_pos = decimal_digits
                    else:
                        decimal_pos = None
                    thousand_sep_count = _picture.picture.count(',')

                    subtype = '({size}, {integer_digits}, {decimal_digits}, {decimal_pos}, {thousand_sep_count})'.format(
                        size=size,
                        integer_digits=integer_digits,
                        decimal_digits=decimal_digits,
                        decimal_pos=decimal_pos,
                        thousand_sep_count=thousand_sep_count,
                    )

                elif _type is types.Date():
                    datatype = 'date'

                    if isinstance(_picture, pictures.UnknownPicture):
                        size = self.get_date_default_size()
                        date_fmt = self.get_date_default_fmt()
                        empty_is_default = False
                    else:
                        size = _picture.size
                        date_fmt = _picture.normal_form(ignore_ws=True)
                        empty_is_default = _picture.empty_is_default()

                    subtype = "({size}, '{date_fmt}', {empty_is_default})".format(
                        size=size,
                        date_fmt=date_fmt,
                        empty_is_default=empty_is_default,
                    )

                elif _type is types.String():
                    datatype = 'str'
                    size = _picture.size
                    subtype = '{size}'.format(
                        size=size,
                    )
                else:
                    raise NotImplementedError("Not supported type: ", input.type)

                self.src.newline("('{}', '{}', {}, {}, {}),".format(
                    adl_name_to_py_name(_input.name), datatype, subtype, _default, f"self.data_descs['{self.dd_names[adl_name_to_py_name(_input.name)]}']"))

            self.src.dedent()
            self.src.newline("),")

        if input_ArrayIds:

            self.src.newline("arrays=(")
            self.src.indent()

            for _input in input_ArrayIds:

                self.src.newline("OrderedDict((")
                self.src.indent()

                array_def = self.array_definition_to_dict(_input.array_definition)
                for key, val in array_def.items():
                    if key == 'fields':
                        self.src.newline("('fields', (")
                        self.src.indent()
                        for field in val:
                            self.src.newline("%s," % (field))
                        self.src.dedent()
                        self.src.newline(")),")
                    else:
                        self.src.newline("('%s', %s)," % (key, val))

                self.src.dedent()
                self.src.newline(")),")

            self.src.dedent()
            self.src.newline("),")

        self.src.newline("using=(")

        for _input in node.inputs:

            if isinstance(_input, ast.SourceInputId):
                self.src.write("'%s', " % adl_name_to_py_name(_input.name))

            elif isinstance(_input, ast.SourceInputArrayId):
                self.src.write("(")
                self.src.write("'%s', " % adl_name_to_py_name(_input.array_definition.name))
                self.src.write("'%s', " % adl_name_to_py_name(_input.name))
                lower_bound = _input.array_definition.lower_bound
                upper_bound = _input.array_definition.upper_bound
                self.array_index(_input.index.index, _input.check_subscripts, lower_bound, upper_bound)
                self.src.write("), ")

            else:  # Stop when CONDITIONAL ON is met.
                break

        self.src.write("),")

        self.src.dedent()
        self.src.newline(')')
        self.src.newline()

    def gen_SourceConditional(self, node):
        cond = node.cond
        input_cases = node.input_cases
        input_else = node.input_else

        source_name = node.source_name
        source_pyname = adl_name_to_py_name(source_name)
        query_name = "_query_%s" % source_pyname
        if isinstance(cond, (ast.Literal, ast.Id)):
            temp = cond
        else:
            self.src.stop_gen_locations()
            temp = ast.Name("_temp")
            self.src.newline("_temp = ")
            self.visit(cond)
            self.src.start_gen_locations()

        start = True
        for case_stmt in input_cases:

            if start:
                self.src.newline("if ")
            else:
                self.src.newline("elif ")
            start = False

            if len(case_stmt.case_labels) == 1:
                self.visit(temp)
                self.src.write(" == ")
                self.visit(case_stmt.case_labels[0])
            else:
                self.visit(temp)
                self.src.write(" in (")
                for case_label in case_stmt.case_labels:
                    self.visit(case_label)
                    self.src.write(", ")
                self.src.write(")")
            self.src.write(":")

            self.src.indent()

            using_input_list = []
            if len(case_stmt.inputs) == 0 or \
               len(case_stmt.inputs) == 1 and isinstance(case_stmt.inputs[0], ast.ControlCharacter):
                self.src.newline("pass")
            else:
                for _input in case_stmt.inputs:
                    if isinstance(_input, (ast.SourceInputId, ast.SourceInputArrayId)):
                        using_input_list.append(_input)
                    elif isinstance(_input, ast.SourceConditional):
                        if using_input_list:
                            self.log_DELIA_3356(node)
                            self.gen_next_fields(query_name, source_pyname, using_input_list)
                        for using_input in using_input_list:
                            if isinstance(using_input, ast.SourceInputId):
                                self.check_conversion(using_input)
                        using_input_list = []

                        self.visit(_input)
                else:
                    if using_input_list:
                        self.gen_next_fields(query_name, source_pyname, using_input_list)
                    for using_input in using_input_list:
                        if isinstance(using_input, ast.SourceInputId):
                            self.check_conversion(using_input)

            self.src.dedent()

        if input_else and \
                not (len(input_else) == 1 and isinstance(input_else[0], ast.ControlCharacter)):
            self.src.newline("else:")
            self.src.indent()

            using_input_list = []
            for _input in input_else:
                if isinstance(_input, (ast.SourceInputId, ast.SourceInputArrayId)):
                    using_input_list.append(_input)
                elif isinstance(_input, ast.SourceConditional):
                    if using_input_list:
                        self.log_DELIA_3356(node)
                        self.gen_next_fields(query_name, source_pyname, using_input_list)
                    for using_input in using_input_list:
                        if isinstance(using_input, ast.SourceInputId):
                            self.check_conversion(using_input)
                    using_input_list = []

                    self.visit(_input)
            else:
                if using_input_list:
                    self.gen_next_fields(query_name, source_pyname, using_input_list)
                for using_input in using_input_list:
                    if isinstance(using_input, ast.SourceInputId):
                        self.check_conversion(using_input)

            self.src.dedent()

    def for_each_source(self, node):
        source = node.relation_name
        source_adl_name = str(source)
        source_python_name = adl_name_to_py_name(source_adl_name)
        py_scope = adl_name_to_py_name(node.scope)
        query_name = "_query_%s" % source_python_name

        definition = source.definition
        source_location = node.source_location
        inputs = definition.inputs

        # Start the report
        if node.report_names is not None:
            for report in node.report_names:
                self.report_begin(report)

        # FOR EACH statement.
        self.src.newline("%s = ForEachSource" % query_name)

        # Path of the source file.
        self.src.write("(")
        self.src.write("path=")
        self.visit(source_location)
        self.src.write(", source=_sources['%s']" % source_python_name)
        self.src.write(", %s" % self.get_thousand_sep_parameter())
        self.src.write(", %s" % self.get_decimal_sep_parameter())
        self.src.write(")")

        self.src.newline("for %s in %s" % (py_scope, query_name))

        self.src.write(".fetchMany():")

        self.src.indent()

        if node.report_names is not None:
            for report in node.report_names:
                self.report_start(report)
        generated_try = False
        start = True
        using_input_list = []
        for _input in inputs:
            if start and isinstance(_input, ast.SourceInputId):
                self.check_conversion(_input)
            elif not start and isinstance(_input, (ast.SourceInputId, ast.SourceInputArrayId)):
                using_input_list.append(_input)
            elif isinstance(_input, ast.SourceConditional):
                if not generated_try:
                    self.src.newline("try:")
                    self.src.indent()
                    generated_try = True
                if using_input_list:
                    self.gen_next_fields(query_name, source_python_name, using_input_list)
                    self.log_DELIA_3356(node)
                for using_input in using_input_list:
                    if isinstance(using_input, ast.SourceInputId):
                        self.check_conversion(using_input)
                using_input_list = []

                self.visit(_input)

                start = False
        else:
            if using_input_list:
                if not generated_try:
                    self.src.newline("try:")
                    self.src.indent()
                    generated_try = True
                self.gen_next_fields(query_name, source_python_name, using_input_list)
            for using_input in using_input_list:
                if isinstance(using_input, ast.SourceInputId):
                    self.check_conversion(using_input)

        if generated_try:
            self.src.dedent()
            self.src.newline("except:")
            self.src.indent()
            self.src.newline("continue")
            self.src.dedent()

        # Body of the FOR EACH statement.
        self.visit(node.stmts)

        self.src.dedent()

        # End the report
        if node.report_names is not None:
            for report in node.report_names:
                self.report_end(report)

    def check_conversion(self, _input):
        if _input.input_picture is not None:

            self.src.newline()
            self.visit(_input)
            self.src.write(" = ")

            from_pict = _input.input_picture.picture.picture
            from_type = _input.input_picture.type

            to_pict = _input.definition.picture.picture
            to_type = _input.type

            convert_function = []
            convert_function = do_convert(self,
                                          to_type,
                                          to_pict,
                                          from_type,
                                          from_pict,
                                          convert_function)

            for (header, _) in reversed(convert_function):
                if header is not None:
                    self.src.write(header)

            self.visit(_input)

            for (_, footer) in convert_function:
                if footer is not None:
                    self.src.write(footer)
