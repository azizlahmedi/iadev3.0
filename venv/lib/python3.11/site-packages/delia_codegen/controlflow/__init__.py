import os
from delia_parser import ast, types
from delia_codegen.utils import adl_name_to_py_name
from delia_codegen.controlflow.gen_labels import Labels
from collections import namedtuple
from decimal import Decimal
from datetime import date as _date


Definition = namedtuple('definition', ['type', 'picture'])


class ControlFlow(Labels):

    def gen_profile_function(self, stmt):
        src_path = stmt.path.replace('<','').replace('>','')
        if stmt.macro_stack:
            macro, macro_adl_lineno, _, _ = stmt.macro_stack[-1]
            fct_name = f"_M_{adl_name_to_py_name(self.compile_ctx.macro_list[macro])}_{macro_adl_lineno}__{adl_name_to_py_name(os.path.basename(src_path))}_{stmt.lineno}"
        else:
            fct_name = f"{adl_name_to_py_name(os.path.basename(src_path))}_{stmt.lineno}"
  
        self.src.newline(f"def {fct_name}():")
        self.src.indent()
        return fct_name

    def gen_macro_to_function(self, node):
        if len(node):
            if self.compile_ctx.macro_to_function_enabled and node.in_macro:
                macro, _, _, _ = node.macro_infos
                macro_name = '_M_' + adl_name_to_py_name(self.compile_ctx.macro_list[macro])
                self.src.newline(f"def {macro_name}():")
                self.src.indent()

            for stmt in node:
                self.visit(stmt)
            if self.compile_ctx.macro_to_function_enabled and node.in_macro:
                self.src.dedent()
                self.src.newline(f"{macro_name}()")
        else:
            self.src.newline("pass")

    def gen_struct_stmt_to_function(self, node):
        if node.in_macro:
            macro, _, _, _ = node.macro_infos
            macro_name = '_M_' + adl_name_to_py_name(self.compile_ctx.macro_list[macro])
            self.src.newline(f"def {macro_name}():")
            self.src.indent()

        if len([e for e in node if isinstance(e, ast.StructStmt)]) > 1:
            level1_fct_name = self.gen_profile_function(node)

        for stmt in node:
            if isinstance(stmt, ast.StructStmt):
                level2_fct_name = self.gen_profile_function(stmt)

            self.visit(stmt)

            if isinstance(stmt, ast.StructStmt):
                self.src.dedent()
                self.src.newline(f"{level2_fct_name}()")

        if len([e for e in node if isinstance(e, ast.StructStmt)]) > 1:
            self.src.dedent()
            self.src.newline(f"{level1_fct_name}()")
           
        if node.in_macro:
            self.src.dedent()
            self.src.newline(f"{macro_name}()")


    def gen_Stmts(self, node):
        if len(node):
            if self.compile_ctx.struct_stmt_to_function_enabled:
                self.gen_struct_stmt_to_function(node)
            elif self.compile_ctx.macro_to_function_enabled:
                self.gen_macro_to_function(node)
            else:
                for stmt in node:
                    self.visit(stmt)
        else:
            self.src.newline("pass")

    def gen_CompileDirective(self, node):
        self.visit(node.stmts_to_compile)

    def gen_Conditional(self, node):
        cond = node.cond
        case_stmts = node.case_stmts
        else_stmt = node.else_stmt

        if isinstance(cond, (ast.Literal, ast.Id)):
            self.src.newline()
            temp = cond
        else:
            definition = Definition(type=cond.type, picture=cond.picture)
            temp = ast.Name('_temp')
            temp.definition = definition

            self.src.newline()
            self.visit(temp)
            self.src.write(" = ")
            self.visit(cond)

        for case_stmt in case_stmts:
            self.src.stop_gen_locations()
            if case_stmt is case_stmts[0]:
                self.src.newline("if ")
            else:
                self.src.newline("elif ")

            for case_label in case_stmt.case_labels:

                self.left_operand(temp, case_label)
                self.src.write(' == ')
                self.right_operand(temp, case_label)

                if case_label is not case_stmt.case_labels[-1]:
                    self.src.write(" or ")

            self.src.write(":")

            self.src.start_gen_locations()
            self.src.indent()
            self.visit(case_stmt.stmts)
            self.src.dedent()

        if else_stmt and not (len(else_stmt) == 1 and isinstance(else_stmt[0], ast.Nothing)):
            self.src.newline("else:")
            self.src.indent()
            self.visit(else_stmt)
            self.src.dedent()

    def gen_DoWhile(self, node):
        stmts = node.stmts
        cond = node.cond
        self.src.newline("while True:")
        self.src.indent()
        self.visit(stmts)
        self.src.newline("if not (")
        self.visit(cond)
        self.src.write("):")
        self.src.indent()
        self.src.newline("break", no_locations=True)
        self.src.dedent()
        self.src.dedent()

    def gen_WhileDo(self, node):
        stmts = node.stmts
        cond = node.cond
        self.src.newline("while ")
        self.visit(cond)
        self.src.write(":")
        self.src.indent()
        self.visit(stmts)
        self.src.dedent()

    def gen_If(self, node):
        cond = node.cond
        then_stmts = node.then_else_clause.then_stmts
        else_stmts = node.then_else_clause.else_stmts

        if (isinstance(cond, (ast.Eq, ast.Ne)) and
                (isinstance(cond.left, ast.Literal) or
                 (isinstance(cond.left, ast.Id) and isinstance(cond.left.definition, ast.Constant))) and
                not cond.left.conversion_types and
                (isinstance(cond.right, ast.Literal) or
                 (isinstance(cond.right, ast.Id) and isinstance(cond.right.definition, ast.Constant))) and
                not cond.right.conversion_types):

            left_value = self.resolve(cond.left)
            right_value = self.resolve(cond.right)

            if cond.left.type is types.String():
                assert(cond.right.type is types.String())
                res = str(left_value).rstrip() == str(right_value).rstrip()

            elif cond.left.type is types.Date():
                assert(cond.right.type is types.Date())
                expr = "{left} == {right}".format(left=self.convert_str_to_date(str(left_value)),
                                                  right=self.convert_str_to_date(str(right_value)))
                res = eval(expr)

            else:
                assert(isinstance(cond.left.type, types.Numeric))
                assert(isinstance(cond.right.type, types.Numeric))
                res = Decimal(str(left_value)) == Decimal(str(right_value))

            if res is True:
                if isinstance(cond, ast.Eq):
                    cond_true = True
                else:
                    cond_true = False
            else:
                if isinstance(cond, ast.Ne):
                    cond_true = True
                else:
                    cond_true = False

            if cond_true:
                if then_stmts:
                    self.visit(then_stmts)
                else:
                    self.src.newline("pass")
            else:
                if else_stmts:
                    self.visit(else_stmts)
                else:
                    self.src.newline("pass")

        else:
            self.src.newline("if ")
            self.visit(cond)
            self.src.write(":")
            self.src.indent()
            self.visit(then_stmts)
            self.src.dedent()
            if else_stmts and not (len(else_stmts) == 1 and isinstance(else_stmts[0], ast.Nothing)):
                self.src.newline("else:")
                self.src.indent()
                self.visit(else_stmts)
                self.src.dedent()
