#!/usr/bin/env python

import argparse
import compileall
import logging
import os
import py_compile
import sys
import warnings
import traceback

import delia_commons
from delia_codegen.adlcodegen import (compile_file, compile_schema_file,
                                      gen_schema_file)
from delia_codegen.mapper import Mapper
from delia_commons import exceptions as delia_exceptions
from delia_commons.log_filter import ErrorFilter
from delia_parser import ast
from delia_parser.compile_context import CompileContext

logger = logging.getLogger('delia.codegen')

STACK_SIZE = 2 ** 25


def compile_schema(args=sys.argv[1:]):
    sys.setrecursionlimit(10 ** 6)
    sys.tracebacklimit = None
    parser = argparse.ArgumentParser(prog='deliac', description=delia_commons.description)
    parser.add_argument('--version', action='version', version=delia_commons.__version__)
    parser.add_argument('--compatibility-version', action='version', version=delia_commons.__compatibility_version__)
    parser.add_argument('-s', '--schema_name',
                        action='store',
                        dest='schema_name',
                        help='schema name',
                        metavar='name')
    parser.add_argument('-p', '--project_path',
                        action='store',
                        dest='project_path',
                        help='project path',
                        metavar='path')
    parser.add_argument('-o', '--output_dir',
                        action='store',
                        dest='output_dir',
                        help='output_dir',
                        metavar='directory')
    parser.add_argument('-f', '--file_path',
                        action='store',
                        dest='file_path',
                        help='procedure file path',
                        metavar='path')
    parser.add_argument('-b', '--bytecode',
                        action='store_true',
                        dest='bytecode',
                        default=False,
                        help='generate python bytecode')
    args = parser.parse_args(args)

    if args.file_path is None and args.project_path is None:
        parser.error('Missing REQUIRED parameters: project path not given')

    if args.file_path is None and args.schema_name is None:
        parser.error('Missing REQUIRED parameters: schemma name not given')

    if args.output_dir is None:
        output_dir = os.environ.get('MAGNUM_MAGPY_DIRECTORY', None)
    else:
        output_dir = args.output_dir

    if output_dir is None and args.bytecode:
        parser.error('--bytecode requires an output directory')
    if args.bytecode and 'win' not in sys.platform:
        import resource
        try:
            resource.setrlimit(resource.RLIMIT_STACK, (STACK_SIZE, STACK_SIZE))
        except ValueError:
            warnings.warn('failed to increase stack size')

    if args.project_path is not None:
        project_path = args.project_path
    else:
        assert (args.file_path.index('adl') > 0)
        project_path = args.file_path[:args.file_path.index('.adl')]

    delia_commons.Context().initialize(project_path)

    if args.file_path is not None:
        schema_path = args.file_path
        if args.schema_name is None:
            schema_name = os.path.splitext(os.path.basename(schema_path))[0].replace('_', '.')
    else:
        if args.schema_name is None:
            schema_name = delia_commons.Context().schema_name
        else:
            schema_name = args.schema_name
        schema_path = delia_commons.DeliaFile(delia_commons.Context(), True, args.schema_name).path

    if output_dir is not None:
        output_path = os.path.join(output_dir, schema_name.replace('.', '_') + '.py')
    else:
        output_path = None

    logger.debug("Compile project_path='{}' schema='{}' schema_path='{}' output_path='{}'".format(
        project_path, schema_name, schema_path, output_path
    ))

    compile_ctx = CompileContext(root=ast.Root())
    compile_ctx.gen_not_used = True
    code = gen_schema_file(schema_path, compile_ctx=compile_ctx)

    if output_path is None:
        print(code)
    else:
        with open(output_path, 'w', encoding='utf-8') as output_file:
            output_file.write(code)
        if args.bytecode:
            pyc_output_path = output_path + 'c'
            py_compile.compile(output_path, cfile=pyc_output_path)
            if not os.path.isfile(pyc_output_path):
                sys.exit(1)

    sys.exit(0)


def deliac(args=sys.argv[1:]):
    sys.setrecursionlimit(10 ** 6)
    sys.tracebacklimit = None
    parser = argparse.ArgumentParser(prog='deliac', description=delia_commons.description)
    parser.add_argument('--version', action='version', version=delia_commons.__version__)
    parser.add_argument('--compatibility-version', action='version', version=delia_commons.__compatibility_version__)
    parser.add_argument('-n', '--proc_name',
                        action='store',
                        dest='proc_name',
                        help='procedure name',
                        metavar='name')
    parser.add_argument('-s', '--schema_name',
                        action='store',
                        dest='schema_name',
                        help='schema name',
                        metavar='name')
    parser.add_argument('-p', '--project_path',
                        action='store',
                        dest='project_path',
                        help='project path',
                        metavar='path')
    parser.add_argument('-o', '--output_dir',
                        action='store',
                        dest='output_dir',
                        help='output_dir',
                        metavar='directory')
    parser.add_argument('-f', '--file_path',
                        action='store',
                        dest='file_path',
                        help='procedure file path',
                        metavar='path')
    parser.add_argument('-b', '--bytecode',
                        action='store_true',
                        dest='bytecode',
                        default=False,
                        help='generate python bytecode')
    parser.add_argument('-j', '--jmetadata',
                        action="store",
                        type=str,
                        default='{}',
                        help='procedure info metadata(json format)')
    parser.add_argument('-m', '--mapping',
                        nargs="?",
                        type=str,
                        choices=["relatif", "absolute"],
                        dest='mapping',
                        default=False,
                        help='generate mapping with absolute or relatif path by default relatif path is used')
    parser.add_argument('--error-format',
                        dest='error_format',
                        action='store',
                        default='default',
                        choices=delia_exceptions.SUPPORTED_ERROR_FORMAT,
                        help='error output format')
    parser.add_argument('--ignore-errors',
                        metavar='errors',
                        default='',
                        nargs='*',
                        dest='ignored_errors_list',
                        help='skip errors and warnings')
    parser.add_argument('-t', '--macro-to-function',
                        action='store_true',
                        dest='macro_to_function',
                        default=False,
                        help='generate macros as a function')

    parser.add_argument('-z', '--struct-stmt-to-function',
                        action='store_true',
                        dest='struct_stmt_to_function',
                        default=False,
                        help='generate struct statement as a function')

    args = parser.parse_args(args)

    if args.ignored_errors_list:
        main_filter = ErrorFilter()
        main_filter.add_errors(args.ignored_errors_list)

    if args.file_path is None and args.project_path is None:
        parser.error('Missing REQUIRED parameters: project path not given')

    if args.file_path is None and args.proc_name is None:
        parser.error('Missing REQUIRED parameters: procedure name not given')

    if args.output_dir is None:
        output_dir = os.environ.get('MAGNUM_MAGPY_DIRECTORY', None)
    else:
        output_dir = args.output_dir

    if output_dir is None and args.bytecode:
        parser.error('--bytecode requires an output directory')

    if args.bytecode and 'win' not in sys.platform:
        import resource
        try:
            resource.setrlimit(resource.RLIMIT_STACK, (STACK_SIZE, STACK_SIZE))
        except ValueError:
            warnings.warn('failed to increase stack size')

    if args.project_path is not None:
        project_path = args.project_path
    else:
        project_path = os.path.split(args.file_path)[0]

    if args.file_path is not None:
        if not os.path.isabs(args.file_path):
            args.file_path = os.path.join(os.getcwd(), args.file_path)
        proc_path = args.file_path
        if args.proc_name is None:
            proc_name = os.path.splitext(os.path.basename(proc_path))[0].replace('_', '.')
        else:
            proc_name = args.proc_name
    else:
        proc_name = args.proc_name
        ctx_singleton = delia_commons.Context()
        ctx_singleton.initialize(project_path)
        proc_path = delia_commons.DeliaFile(ctx_singleton, True, args.proc_name).path

    delia_exceptions.error_format = args.error_format

    try:
        delia_commons.Context().initialize(project_path)
    except delia_exceptions.ContextException:
        sys.exit(1)


    if output_dir is not None:
        output_path = os.path.join(output_dir, proc_name.replace('.', '_') + '.py')
    else:
        output_path = None

    if args.schema_name is None:
        schema_name = delia_commons.Context().schema_name
    else:
        schema_name = args.schema_name

    schema_path = delia_commons.DeliaFile(delia_commons.Context(), True, schema_name).path

    logger.debug("Compile project_path='{}' schema='{}' schema_path='{}' procedure='{}' procedure_path='{}' output_path='{}'".format(
        project_path, schema_name, schema_path, proc_name, proc_path, output_path
    ))

    mapping_absolute = True
    if args.mapping != False:
        if args.mapping == "relatif":
            mapping_absolute = False
        args.mapping = True

    compile_ctx = CompileContext(root=ast.Root())
    compile_ctx.mapping_enabled = args.mapping
    compile_ctx.mapping_absolute = mapping_absolute
    compile_ctx.macro_to_function_enabled = args.macro_to_function
    compile_ctx.struct_stmt_to_function_enabled = args.struct_stmt_to_function
    compile_ctx.jmetadata = args.jmetadata

    try:
        code, mapping = compile_file(proc_path, schema_tree=compile_schema_file(schema_path, compile_ctx=compile_ctx),
                                     compile_ctx=compile_ctx, proc_name=proc_name)
        if args.mapping:
            mapping_output_path = os.path.join(output_dir, proc_name.replace('.', '_') + '.map.gz')
            Mapper.save(mapping, mapping_output_path)

    except delia_exceptions.DeliaException as e:
        sys.exit(1)
    except delia_exceptions.DeliaExceptions as e:
        sys.exit(1)
    except Exception as e:
        logger.error(e, exc_info=True)
        print(f"{traceback.format_exc()}")
        sys.exit(1)

    if output_path is None:
        print(code)
    else:
        try:
            with open(output_path, 'w', encoding='utf-8') as output_file:
                output_file.write(code)
            if args.bytecode:
                pyc_output_path = output_path + 'c'
                py_compile.compile(output_path, cfile=pyc_output_path)
                if not os.path.isfile(pyc_output_path):
                    msg_err = f"Compiled Python file '{pyc_output_path}' was not generated"
                    logger.error(msg_err)
                    print(msg_err)
                    sys.exit(1)
        except Exception as e:
            logger.error(e, exc_info=True)
            print(f"{traceback.format_exc()}")
            sys.exit(1)

    sys.exit(0)


if __name__ == '__main__':
    deliac()
