from delia_parser import ast, types, pictures

from delia_codegen.declarations.gen_arrays import Array
from delia_codegen.declarations.gen_relations import Relation
from delia_codegen.declarations.gen_functions import Function

from delia_codegen.utils import adl_name_to_py_name
from delia_codegen.codeblock import CodeBlockNames
from delia_codegen.convert_type import do_convert


class Declarations(Array,
                   Relation,
                   Function):

    def resolve(self, node):
        if isinstance(node, ast.ConstantRef):
            def resolve_constant(constant):
                while constant and isinstance(constant, ast.ConstantRef):
                    constant = constant.definition.value
                if isinstance(constant, ast.Literal):
                    return constant.value
                else:
                    return None
            return resolve_constant(node)
        elif isinstance(node, ast.Literal):
            return node.value
        return None

    def gen_data_description(self, node):

        from_type = node.definition.type
        from_pict = node.picture.picture
        field_name = adl_name_to_py_name(node.name)
        if from_type is types.String():
            dd = f"StringDataDescription(size={from_pict.size}"

        elif from_type is types.Date():

            if not isinstance(from_pict, pictures.UnknownPicture):
                parameters = from_pict.to_parameters(ignore_ws=False)
            else:
                parameters = '"{}"'.format(self.get_date_default_fmt())

            dd = f"DateDataDescription(picture={parameters}"

        elif from_type is types.Decimal() or from_type is types.Integer():

            if not isinstance(from_pict, pictures.UnknownPicture):

                parameters = from_pict.to_parameters()

                dd = f"DecimalDataDescription({parameters}"

            else:

                if from_type is types.Integer():
                    dd = f"IntegerDataDescription()"
                else:
                    dd = f"DecimalDataDescription("

        for clause in node.attributes.clauses:
            if isinstance(clause, ast.VerifyClause):
                dd += f", verify_clause=lambda {field_name}: "
                break

        if dd not in self.dd_dict:
            dd_name = f"_DD_{field_name}"
            self.dd_dict[dd] = dd_name
            self.dd_names[field_name] = dd_name
            src_bck = self.src
            self.set_src(self.source[CodeBlockNames.DATA_DESC], node)
            self.src.newline(f"_data_descs['{dd_name}'] = {dd}")

            for clause in node.attributes.clauses:
                if isinstance(clause, ast.VerifyClause):
                    self.force_literal_value_bck = self.force_literal_value = True
                    self.force_literal_value = True

                    self.not_use_literal_value_bck = self.not_use_literal_value
                    self.not_use_literal_value = True

                    self.visit(clause)

                    self.force_literal_value = self.force_literal_value_bck
                    self.not_use_literal_value = self.not_use_literal_value_bck
                    break
            self.src.write(")")
            self.src = src_bck
        else:
            self.dd_names[field_name] = self.dd_dict[dd]

    def gen_Constant(self, node):

        self.gen_unused(node)

        if not node.used:
            return

        self.set_src(self.source[CodeBlockNames.CONSTANT], node)
        constant_name = adl_name_to_py_name(node.name)
        self.constants.add(constant_name)
        self.src.newline("constants.%s = " % constant_name)
        self.visit(node.value)

    def gen_Field(self, node):

        self.gen_unused(node)

        if not node.used:
            return

        self.collector.append_field(node)
        field_name = adl_name_to_py_name(node.name)
        self.set_src(self.source[CodeBlockNames.FIELD], node)
        self.gen_data_description(node)
        self.src.newline("procedure.%s = %s" % (field_name, self.get_default_value(node)))

    def is_default_declared(self, node):

        if isinstance(node, ast.LanguageControl):
            return True

        if hasattr(node, 'definition'):
            attributes = node.definition.attributes
        else:
            attributes = node.attributes

        for clause in attributes.clauses:
            if isinstance(clause, ast.DefaultValue):
                return True

        return False

    def get_default_value(self, node, force_literal_value=False):
        if isinstance(node, (ast.UsersLanguage, ast.DateLanguage)):
            return self.add_String("ENGLISH")
        elif isinstance(node, ast.DigitSeparator):
            return "',.'"

        _type = node.type

        if hasattr(node, 'definition'):
            _attributes = node.definition.attributes
            _picture = node.definition.picture
        else:
            _attributes = node.attributes
            _picture = node.picture

        for clause in _attributes.clauses:

            if isinstance(clause, ast.DefaultValue):

                clause_value = clause.clause_value

                if force_literal_value and isinstance(clause_value, ast.ConstantRef):
                    clause_value = clause_value.definition.value

                if isinstance(clause_value, ast.ConstantRef):
                    is_constant = True

                    if isinstance(node.type, types.String):

                        node_as_str = "{value}".format(value=adl_name_to_py_name(clause_value))

                        rcv_picture = _picture.picture
                        exp_picture = clause_value.picture.picture

                        if rcv_picture.size != exp_picture.size:
                            node_as_str += ".ljust({size})[:{size}]".format(size=_picture.size)

                        if is_constant:
                            return 'constants.' + node_as_str
                        else:
                            return 'procedure.' + node_as_str

                    elif isinstance(_type, types.Numeric):

                        to_pict = _picture.picture
                        to_type = _type

                        from_pict = clause_value.picture.picture
                        from_type = clause_value.type

                        convert_function = []
                        convert_function = do_convert(self,
                                                      to_type,
                                                      to_pict,
                                                      from_type,
                                                      from_pict,
                                                      convert_function)
                        expression = []
                        for (header, _) in reversed(convert_function):
                            if header is not None:
                                expression.append(header)

                        if is_constant:
                            expression.append('constants.' + adl_name_to_py_name(clause_value))
                        else:
                            expression.append('procedure.' + adl_name_to_py_name(clause_value))

                        for (_, footer) in convert_function:
                            if footer is not None:
                                expression.append(footer)

                        return "".join(expression)

                    else:
                        if is_constant:
                            return 'constants.' + adl_name_to_py_name(clause_value)
                        else:
                            return 'procedure.' + adl_name_to_py_name(clause_value)

                # ! isinstance(clause_value, ast.Name)
                elif isinstance(clause_value, ast.ConcatenatedString):
                    return ("({value}).ljust({size})[:{size}]".format(
                        value=self.get_concatenated_string(clause_value, force_literal_value),
                        size=_picture.size))

                # ! isinstance(clause_value, (ast.Name, ast.ConcatenatedString))
                elif isinstance(clause_value, ast.Literal):

                    if isinstance(_type, types.Numeric):

                        to_pict = _picture.picture
                        to_type = _type

                        from_pict = clause_value.picture.picture
                        from_type = clause_value.type

                        convert_function = []
                        convert_function = do_convert(self,
                                                      to_type,
                                                      to_pict,
                                                      from_type,
                                                      from_pict,
                                                      convert_function)
                        expression = []
                        for (header, _) in reversed(convert_function):
                            if header is not None:
                                expression.append(header)

                        if from_type is types.Integer():
                            expression.append("int(%d)" % int(clause_value.value))
                        elif from_type is types.Decimal():
                            expression.append(self.add_Decimal(clause_value.value, force_literal_value=force_literal_value))
                        else:
                            expression.append("%s" % clause_value)

                        for (_, footer) in convert_function:
                            if footer is not None:
                                expression.append(footer)

                        return "".join(expression)

                    elif _type is types.Boolean():
                        return "{}".format(clause_value)

                    elif _type is types.Date():
                        return (self.convert_str_to_date(str(clause_value.value)))

                    elif _type is types.String():
                        node_as_str = self.add_String(clause_value.value, force_literal_value)
                        if clause_value.size != _picture.size:
                            node_as_str += ".ljust({size})[:{size}]".format(size=_picture.size)
                        return node_as_str

        return self.get_default_from_picture(_type, _picture, force_literal_value)

    def get_default_from_picture(self, _type, _picture, force_literal_value=False):

        if _type is types.Integer():
            return("0")
        elif _type is types.Boolean():
            return("False")
        elif _type is types.Decimal():
            return self.add_Decimal("0.0", force_literal_value=force_literal_value)
        elif _type is types.Date():
            return self.get_date_min(force_literal_value=force_literal_value)
        elif _type is types.String():
            return self.add_String(_picture.size * ' ', force_literal_value)

    def get_concatenated_string(self, node, force_literal_value=False):

        if force_literal_value:
            return self.add_String(node.value, force_literal_value)

        strings = []
        for cste in node.values:
            if isinstance(cste, ast.String):
                strings.append(self.add_String(cste.value))
            elif isinstance(cste, ast.ConstantRef):
                strings.append("constants.%s" % adl_name_to_py_name(cste.name))
        return " + ".join(strings)
