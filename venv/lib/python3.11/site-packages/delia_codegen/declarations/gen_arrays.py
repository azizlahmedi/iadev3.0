from delia_parser import ast, types, pictures

from delia_codegen.utils import adl_name_to_py_name
from delia_codegen.codeblock import CodeBlockNames
from delia_codegen.convert_type import do_convert

from collections import OrderedDict


class Array:

    def array_definition_to_dict(self, node):
        if hasattr(node, 'definition'):
            array_name = adl_name_to_py_name(node.definition.name)
            lower_bound = node.definition.lower_bound
            upper_bound = node.definition.upper_bound
            columns = node.definition.columns
        else:
            array_name = adl_name_to_py_name(node.name)
            lower_bound = node.lower_bound
            upper_bound = node.upper_bound
            columns = node.columns

        values = OrderedDict()
        values['name'] = "'%s'" % array_name
        # Works because it's only constant integer fields.
        values['upper_bound'] = str(upper_bound.value)
        values['lower_bound'] = str(lower_bound.value)

        fields_list = []

        for column in columns:

            _picture = column.definition.picture.picture
            _type = column.type

            if _type is types.Integer():

                datatype = 'integer'

                size = _picture._get_size()
                total, decimal_digits = _picture.get_digits()
                integer_digits = total - decimal_digits
                subtype = '({size}, {integer_digits},)'.format(
                    size=size,
                    integer_digits=integer_digits,
                )

            elif _type is types.Decimal():

                datatype = 'decimal'

                if not isinstance(_picture, pictures.UnknownPicture):
                    size = _picture._get_size()
                    total, decimal_digits = _picture.get_digits()
                    integer_digits = total - decimal_digits
                    if _picture._get_point() == 'V':
                        decimal_pos = decimal_digits
                    else:
                        decimal_pos = None
                else:
                    size = None
                    integer_digits = None
                    decimal_digits = None
                    decimal_pos = None

                subtype = '({size}, {integer_digits}, {decimal_digits}, {decimal_pos},)'.format(
                    size=size,
                    integer_digits=integer_digits,
                    decimal_digits=decimal_digits,
                    decimal_pos=decimal_pos,
                )

            elif _type is types.Date():

                datatype = 'date'

                if not isinstance(_picture, pictures.UnknownPicture):
                    date_fmt = _picture.normal_form()
                    size = _picture.size
                    empty_is_default = _picture.empty_is_default()
                else:
                    size = self.get_date_default_size()
                    date_fmt = self.get_date_default_fmt()
                    empty_is_default = False

                subtype = "({size}, '{date_fmt}', {empty_is_default})".format(
                    size=size,
                    date_fmt=date_fmt,
                    empty_is_default=empty_is_default
                )

            elif _type is types.String():

                datatype = 'str'
                size = _picture.size
                subtype = '{size}'.format(
                    size=size,
                )

            default = self.get_default_value(column, force_literal_value=True)

            # Get default value as string.
            to_type = types.String()
            to_pict = pictures.UnknownPicture()

            from_type = _type
            from_pict = _picture

            convert_function = []
            convert_function = do_convert(self,
                                          to_type,
                                          to_pict,
                                          from_type,
                                          from_pict,
                                          convert_function,
                                          default_decimal_sep=True)
            expression = []
            for (header, _) in reversed(convert_function):
                if header is not None:
                    expression.append(header)

            expression.append(default)

            for (_, footer) in convert_function:
                if footer is not None:
                    expression.append(footer)

            default_as_str = "".join(expression)

            fields_list.append("('{}', '{}', {}, {}, {}, {})".format(
                adl_name_to_py_name(column), datatype, subtype, default, default_as_str, f"self.data_descs['{self.dd_names[adl_name_to_py_name(column)]}']"))

        values['fields'] = fields_list

        return values

    def gen_Array(self, node):
        self.gen_unused(node)

        if not node.used:
            return

        self.collector.append_array(node)

        array_pyname = adl_name_to_py_name(node.name)
        array_def_as_dict = self.array_definition_to_dict(node)

        self.set_src(self.source[CodeBlockNames.ARRAY], node)
        self.src.newline("procedure.%s = AdlArray(" % (array_pyname))
        self.src.indent()

        for key, val in array_def_as_dict.items():
            if key == 'fields':
                self.src.newline('fields=(')
                self.src.indent()
                for field in val:
                    self.src.newline('%s,' % (field))
                self.src.dedent()
                self.src.newline(')')
            else:
                self.src.newline('%s=%s,' % (key, val))

        self.src.dedent()
        self.src.newline(')')
        self.src.newline()

    def gen_SameAsArray(self, node):
        self.gen_unused(node)

        if not node.used:
            return

        self.gen_Array(node)

    def array_index(self,
                    index,
                    check,
                    lower_bound,
                    upper_bound,
                    is_upper_bound=False):

            # If check is False, the index is circular (modulo of the ARRAY size).
            if check is False:

                if (isinstance(upper_bound, ast.Literal) and
                        not isinstance(upper_bound, ast.ConstantRef) and
                        not upper_bound.conversion_types and
                        isinstance(lower_bound, ast.Literal) and
                        not isinstance(lower_bound, ast.ConstantRef) and
                        not lower_bound.conversion_types):

                    if (isinstance(index, ast.Literal) and
                            not isinstance(index, ast.ConstantRef) and
                            not index.conversion_types):

                        result = (int(str(index)) - int(str(lower_bound))) % \
                                 (int(str(upper_bound)) - int(str(lower_bound)) + 1)
                        if is_upper_bound is True:
                            result += 1
                        self.src.write(str(result))

                    else:

                        self.src.write("(")
                        self.visit(index)
                        self.src.write(" - ")
                        self.src.stop_gen_locations()
                        self.visit(lower_bound)
                        self.src.start_gen_locations()
                        self.src.write(")")

                        self.src.write(" % ")

                        result = int(str(upper_bound)) - int(str(lower_bound)) + 1
                        self.src.write(str(result))
                        if is_upper_bound is True:
                            self.src.write(" + 1")

                else:

                    self.src.write("(")
                    self.visit(index)
                    self.src.write(" - ")
                    self.src.stop_gen_locations()
                    self.visit(lower_bound)
                    self.src.start_gen_locations()
                    self.src.write(")")

                    self.src.write(" % ")

                    self.src.write("(")
                    self.src.stop_gen_locations()
                    self.visit(upper_bound)
                    self.src.write(" - ")
                    self.visit(lower_bound)
                    self.src.write(" + 1")
                    self.src.write(")")
                    self.src.start_gen_locations()
                    if is_upper_bound is True:
                        self.src.write(" + 1")

            else:
                if (isinstance(index, ast.Literal) and
                        not isinstance(index, ast.ConstantRef) and
                        not index.conversion_types and
                        isinstance(lower_bound, ast.Literal) and
                        not isinstance(lower_bound, ast.ConstantRef) and
                        not lower_bound.conversion_types):
                    result = int(str(index)) - int(str(lower_bound))
                    if is_upper_bound is True:
                        result += 1
                    self.src.write(str(result))
                else:
                    self.src.write("(")
                    self.visit(index)
                    self.src.write(" - ")
                    self.src.stop_gen_locations()
                    self.visit(lower_bound)
                    self.src.start_gen_locations()
                    self.src.write(")")
                    if is_upper_bound is True:
                        self.src.write(" + 1")
