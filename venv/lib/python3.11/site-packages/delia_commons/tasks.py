# -*- coding: utf-8 -*-
import contextlib
import distutils.util
import glob
import os
import platform
import re
import shlex
import shutil
import sys
import tempfile
from configparser import ConfigParser

distutils_platform = distutils.util.get_platform()
windows = 'win' in distutils_platform
solaris = 'solaris' in distutils_platform
aix = 'aix' in distutils_platform
artifact_url = 'http://nx-artifacts:8085/artifactory'
command_sep = '&& ' if windows else ' && '
default_version_pattern = '__version__\s*=\s*[\'"]([^\'"]+)[\'"]'
dependencies_basename = 'dependencies.conf'
dependencies_aix_basename = 'dependencies_aix.conf'
env_suffix = '-ENV'


def quote(string_in):
    string_out = shlex.quote(string_in)
    if not windows or string_in == string_out:
        return string_out
    # TODO: accurate escape on windows
    return '"%s"' % string_in


def prompt(text, default='', validate=None):
    if default != '':
        default_str = " [%s] " % str(default).strip()
    else:
        default_str = " "
    prompt_str = text.strip() + default_str
    value = None
    while value is None:
        value = input(prompt_str) or default
        if validate:
            if not validate.startswith('^'):
                validate = r'^' + validate
            if not validate.endswith('$'):
                validate += r'$'
            result = re.findall(validate, value)
            if not result:
                print("Regular expression validation failed: '%s' does not match '%s'\n" % (value, validate))
                value = None
    return value


def abort(msg):
    print('abort: ' + msg, file=sys.stderr)
    sys.exit(1)


def get_url(repo):
    return 'ssh://git@bitbucket.my-nx.com:7999/delia/{repo}.git'.format(repo=repo)


def get_tag_name(version):
    return 'v{version}'.format(version=version)


def get_new_version(version):
    return version + '-dev'


def load_dependencies(path):
    dependencies = ConfigParser()
    dependencies.read(path, encoding='utf-8')
    return dependencies


def set_version(path, version, pattern=default_version_pattern):
    with open(path, 'r', encoding='utf-8') as fd:
        content = fd.read()
    m = re.search(pattern, content)
    if not m:
        raise ValueError('failed to find %s in %s' % (pattern, path))
    content = content[:m.start()] + content[m.start():].replace(m.group(1), version, 1)
    with open(path, 'w', encoding='utf-8') as fd:
        fd.write(content)


@contextlib.contextmanager
def customize_dependencies(dependencies_path):
    dependencies = load_dependencies(dependencies_path)
    dictionary = {}
    if 'el6' in platform.platform():
        dictionary.update({
            'NATIVE_REPOSITORY': {
                'repository': artifact_url + '/gp3-binaries-centos6/',
            },
            'HYBRID_REPOSITORY': {
                'repository': artifact_url + '/gp3-binaries-centos6/'
            },
            'PYTHON_REPOSITORY': {
                'repository': artifact_url + '/api/pypi/pypi-proxy-delia-prod-centos6/simple',
                'repository_upload': artifact_url + '/api/pypi/pypi-delia-prod-centos6',
                'third_party_upload': artifact_url + '/api/pypi/pypi-delia-third-party-centos6',
            },
        })
    dependencies.read_dict(dictionary)
    with tempfile.TemporaryDirectory() as temp:
        custom_dependencies_path = os.path.join(temp, dependencies_basename)
        with open(custom_dependencies_path, 'w', encoding='utf-8') as fd:
            dependencies.write(fd)
        yield custom_dependencies_path


class Command(object):
    def contribute(self):
        raise NotImplementedError()


class Cd(Command):
    def __init__(self, path):
        self.path = path

    def contribute(self):
        return 'cd %s' % quote(self.path)


class Source(Command):
    def __init__(self, *args):
        self.args = args

    def contribute(self):
        return '%s %s' % ('@CALL' if windows else 'source', ' '.join(map(quote, self.args)))


class Export(Command):
    def __init__(self, environ):
        if not isinstance(environ, (list, tuple)):
            raise ValueError('list or tupple expected')
        self.environ = environ

    def contribute(self):
        commands = []
        for key, value in self.environ:
            if value is None:
                if windows:
                    commands.append('@SET %s=' % key)
                else:
                    commands.append('unset %s' % key)
            else:
                commands.append('%s %s=%s' % ('@SET' if windows else 'export', key, value if windows else quote(value)))
        return command_sep.join(commands)


class ContextWrapper(object):
    def __init__(self, ctx):
        self.ctx = ctx
        if os.name == 'nt':
            self.ctx.config['run']['shell'] = None
        self.commands = []

    @contextlib.contextmanager
    def _context(self, command):
        self.commands.append(command)
        try:
            yield
        finally:
            self.commands.pop()

    def cd(self, path):
        return self._context(Cd(path))

    def source(self, *args):
        return self._context(Source(*args))

    def export(self, environ):
        return self._context(Export(environ))

    def compile_env(self, support=None):
        if not support:
            if windows:
                support = os.path.dirname(sys.executable)
            else:
                support = os.path.dirname(os.path.dirname(sys.executable))
        support_lib = os.path.join(support, 'lib')
        support_bin = os.path.join(support, 'bin')
        support_inc = os.path.join(support, 'include')
        environ = (
            ('PYTHONHOME', None),
            ('PYTHONPATH', None),
            ('DELIA_GPDIR', None),  # else tests fails
            ('LANG', 'en_US.UTF-8'),
        )
        # Parser path
        delia_parser_path = os.path.normpath(
            os.path.join(os.path.dirname(os.path.abspath(__file__)), os.pardir, os.pardir, 'delia_parser'))
        if not os.path.isdir(delia_parser_path):
            if 'JENKINS_HOME' in os.environ:
                delia_parser_path = os.path.join(os.environ['JENKINS_HOME'], 'jobs', 'parser', 'workspace')
            elif 'bamboo_agentWorkingDirectory' in os.environ:
                delia_parser_path = \
                    glob.glob(os.path.join(os.environ['bamboo_agentWorkingDirectory'], '*-DELIAPARSER*'))[0]
        if os.path.isdir(delia_parser_path):
            environ += (('DELIAPARSERPATH', delia_parser_path),)
        # Platform dependant
        if 'solaris-2.11-sun4v.64bit' == distutils_platform:
            oracle_home = '/oracle/product/12.1.0'
            environ += (
                ('CC', 'cc'),
                ('MAKE', 'gmake'),
                ('LD_LIBRARY_PATH',
                 '%s:/opt/solarisstudio12.4/lib:%s' % (support_lib, os.path.join(oracle_home, 'lib'))),
                ('PATH',
                 '%s:/opt/solarisstudio12.4/bin:/usr/sfw/bin:/usr/ccs/bin:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin' % support_bin),
                ('ORACLE_HOME', oracle_home),
                ('CFLAGS', '-m64 -I%s' % support_inc),
                ('CPPFLAGS', '-m64 -I%s' % support_inc),
                ('LDFLAGS', '-m64 -L%s' % support_lib),
            )
        elif 'aix-7.1' == distutils_platform:
            oracle_home = '/oracle/product/11.2.0.2'  # NOSONAR
            environ += (
                ('CC', 'xlc_r'),
                ('MAKE', 'make'),
                ('LIBPATH', '%s:/usr/lib:%s' % (support_lib, os.path.join(oracle_home, 'lib'))),
                ('PATH', '%s:/usr/vac/bin:/usr/bin:/usr/local/bin' % support_bin),
                ('ORACLE_HOME', oracle_home),
                ('OBJECT_MODE', '64'),
                ('CFLAGS', '-DDEBUG -g -I%s' % support_inc),
                ('LDFLAGS', '-L%s' % support_lib),
            )
        elif 'linux-x86_64' == distutils_platform:
            oracle_home = '/oracle/product/12.1.0'
            postgres_home = '/usr/pgsql-11'
            environ += (
                ('CC', 'gcc'),
                ('CXX', 'g++'),
                # TODO: gmake?
                ('MAKE', 'make'),
                ('LD_LIBRARY_PATH', '%s:/usr/lib:%s:%s' % (support_lib, os.path.join(oracle_home, 'lib'), os.path.join(postgres_home, 'lib'))),
                ('PATH', '%s:/usr/bin:/bin' % support_bin),
                ('ORACLE_HOME', oracle_home),
                ('CFLAGS', '-g -I%s -I%s -I%s' % (support_inc, os.path.join(support_inc, 'ncurses'), os.path.join(postgres_home, 'lib'))),
                ('LDFLAGS', '-L%s -L%s' % (support_lib, os.path.join(postgres_home, 'lib'))),
            )
        elif 'win-amd64' == distutils_platform:
            # do not unset PYTHONHOME, it makes Python crash
            environ += (
                ('PATH', '%s;%s;%%PATH%%' % (support, os.path.join(support, 'Scripts'))),
            )
            stack = contextlib.ExitStack()
            stack.enter_context(self.export(environ))
            stack.enter_context(
                self.source('C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\vcvarsall.bat',
                            'x86_amd64'))
            return stack
        else:
            raise NotImplementedError(distutils_platform)
        return self.export(environ)

    def run(self, command, **kwargs):
        contribute = command_sep.join([c.contribute() for c in self.commands if c.contribute()])
        if contribute:
            command = '%s%s%s' % (contribute, command_sep, command)
        print(command)
        return self.ctx.run(command, **kwargs)

    def run_python(self, command):
        return self.run(('python' if windows else 'python3') + ' ' + command)

    def run_pip(self, command, **kwargs):
        return self.run(('pip' if windows else 'pip3') + ' ' + command, **kwargs)

    def run_pip_install(self, command):
        return self.run_pip(
            'install --trusted-host nx-artifacts -i ' + artifact_url + '/api/pypi/pypi-gp3/simple ' + command)

    def run_uninstall(self, package, setup_py='setup.py'):
        self.run_python(setup_py + ' develop --uninstall')
        self.run_pip('uninstall --yes %s' % package, warn=True)

    def pwd(self):
        return self.run('cd' if windows else 'pwd').stdout.rstrip('\r\n')

    def rm(self, *args):
        for arg in args:
            for path in glob.glob(self.abspath(arg)):
                if len(path) < 15:
                    raise ValueError('too short to delete: ' % path)
                if os.path.isfile(path):
                    os.remove(path)
                elif os.path.isdir(path):
                    shutil.rmtree(path)

    def abspath(self, path):
        if not os.path.isabs(path):
            path = os.path.join(self.pwd(), path)
        return path

    def replace(self, path, old, new, encoding='utf-8'):
        abs_path = self.abspath(path)
        with open(abs_path, 'r', encoding=encoding) as fd:
            content = fd.read()
        if old not in content:
            raise ValueError('not found: %r' % old)
        content = content.replace(old, new)
        with open(abs_path, 'w', encoding=encoding) as fd:
            fd.write(content)

    def delegate(self, task, dirs, kwargs=None):
        if kwargs is None:
            kwargs = {}
        command = [quote(sys.argv[0]), quote(task.name), ]
        for k, v in kwargs.items():
            if isinstance(v, bool):
                command.append('--%s' % k)
            else:
                command.append('--%s=%s' % (k, quote(v)))
        for d in dirs:
            with self.cd(d):
                self.run(' '.join(command))

    def tag(self, repo, package, version, version_path, dependencies_path=None, aix_dependencies_path=None, branch_name='master'):
        if not version:
            abort('missing version')
        with tempfile.TemporaryDirectory() as temp:
            # Clone
            clone = os.path.join(temp, 'clone')
            self.run('git clone --branch {branch_name} {url} {clone}'.format(
                branch_name=branch_name,
                url=get_url(repo),
                clone=clone,
            ))
            with self.cd(clone):
                # Get data
                tag_name = get_tag_name(version)
                # Remove existing tag if any
                delete = self.run('git tag -d {tag_name}'.format(tag_name=tag_name), warn=True)
                if delete.ok:
                    self.run('git push origin :refs/tags/{tag_name}'.format(tag_name=tag_name))
                # Set the version
                set_version(os.path.join(clone, version_path), version)
                # Froze dependencies
                if dependencies_path:
                    dependencies = load_dependencies(dependencies_path)
                    dependencies.set(package.upper(), 'branch', tag_name)
                    env = (package + env_suffix).upper()
                    if dependencies.has_section(env):
                        deps_python = dependencies.get(env, 'deps_python', fallback='')
                        deps_python = deps_python.replace(package, package + '==' + version)
                        dependencies.set(env, 'deps_python', deps_python)
                        dependencies.set(env, 'version', version)
                    dependencies_tag_path = os.path.join(clone, dependencies_basename)
                    with open(dependencies_tag_path, 'w', encoding='utf-8') as fd:
                        dependencies.write(fd)
                    self.run('git add {path}'.format(path=dependencies_tag_path))

                if aix_dependencies_path:
                    aix_dependencies = load_dependencies(aix_dependencies_path)
                    aix_dependencies.set(package.upper(), 'branch', tag_name)
                    env = (package + env_suffix).upper()
                    if aix_dependencies.has_section(env):
                        deps_python = aix_dependencies.get(env, 'deps_python', fallback='')
                        deps_python = deps_python.replace(package, package + '==' + version)
                        aix_dependencies.set(env, 'deps_python', deps_python)
                        aix_dependencies.set(env, 'version', version)
                        aix_dependencies_tag_path = os.path.join(clone, dependencies_aix_basename)
                    with open(aix_dependencies_tag_path, 'w', encoding='utf-8') as fd:
                        aix_dependencies.write(fd)
                    self.run('git add {path}'.format(path=aix_dependencies_tag_path))

                # Commit
                msg = '[invoke] pre tag {package} {version}'.format(package=package, version=version)
                self.run('git commit -a -m {msg}'.format(msg=quote(msg)))
                self.run('git push origin {branch_name}'.format(branch_name=branch_name))
                # Create a tag
                msg = '[invoke] tag {package} {version}'.format(package=package, version=version)
                self.run('git tag -a {tag_name} -m {msg}'.format(tag_name=tag_name, msg=quote(msg)))
                self.run('git push origin : {tag_name}'.format(tag_name=tag_name))
                # Delete dependencies
                self.run('git rm {path}'.format(path=dependencies_basename))
                set_version(os.path.join(clone, version_path), get_new_version(version))
                msg = '[invoke] post tag {package} {version}'.format(package=package, version=version)
                self.run('git commit -a -m {msg}'.format(msg=quote(msg)))
                self.run('git push origin {branch_name}'.format(branch_name=branch_name))

    def release(self, repo, package, version):
        """
        Checkout the tag to get the dependencies file.
        Release from the dependencies file.
        """
        if not version:
            abort('missing version')
        with tempfile.TemporaryDirectory() as temp:
            # Clone
            clone = os.path.join(temp, 'clone')
            self.run('git clone --depth=1 --branch {tag_name} {url} {clone}'.format(
                tag_name=get_tag_name(version),
                url=get_url(repo),
                clone=clone,
            ))
            # Get a platform specific dependencies
            if aix:
                dependencies_path = os.path.join(clone, dependencies_aix_basename)
            else:
                dependencies_path = os.path.join(clone, dependencies_basename)
            with customize_dependencies(dependencies_path) as custom_dependencies_path:
                # Commands to execute
                commands = [
                    'build -f %s %s' % (custom_dependencies_path, package.lower()),
                ]
                # Check if has to build an "-env" section
                env = (package + env_suffix).upper()
                if load_dependencies(custom_dependencies_path).has_section(env):
                    commands.extend([
                        'build -f %s %s' % (custom_dependencies_path, env.lower()),
                        'deploy -f %s %s' % (custom_dependencies_path, env.lower()),
                    ])
                # Build
                for command in commands:
                    self.run(command)
