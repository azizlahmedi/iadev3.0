import json
import logging

error_format = 'default'
SUPPORTED_ERROR_FORMAT = ['json', 'lsp', 'default']
UNKNOWN_FILENAME = '<String>'
ExceptionCounter = 0


def reset_exception_counter():
    global ExceptionCounter
    ExceptionCounter = 0


class DeliaException(Exception):
    def __init__(self, code, message, filename=None, lineno=-1, column=-1, severity=1):
        """Exception initializer.

        :param message: the error message from the parser
        :param filename: the path to the file that was parsed
        :param lineno: the number of the line on which the error was encountered
        :param column: the column number where the error was encountered
        """
        Exception.__init__(self, message)
        self.message = message
        self.code = code
        self.filename = filename or UNKNOWN_FILENAME
        self.lineno = lineno
        self.column = column
        self.severity = severity

    def __eq__(self, other):
        if not isinstance(other, type(self)):
            return False
        else:
            return self.message == other.message \
                   and self.code == other.code \
                   and self.filename == other.filename \
                   and self.lineno == other.lineno \
                   and self.column == other.column

    def __hash__(self):
        return hash((self.message, self.code, self.filename, self.lineno, self.column))

    def __repr__(self):
        """
        Use the representation depending of error_format specified.
        Supported format:
           - json, well this is straightforward ;
           - lsp for Language Server Protocole which is based on microsoft specification ;
           - default, the default error message representation.
        """
        global error_format
        error_format = error_format.lower()
        if error_format == 'json':
            return json.dumps({
                'kind': str(self.__class__.__name__),
                'code': int(self.code),
                'message': self.message,
                'file': self.filename if self.filename != UNKNOWN_FILENAME else None,
                'lineno': int(self.lineno),
                'column': int(self.column)})
        elif error_format == 'lsp':
            return json.dumps({
                'uri': self.filename,
                'diagnostics': [{
                    'range': {
                        'start': {
                            'line': int(self.lineno),
                            'character': int(self.column)
                        },
                        'end': {
                            'line': int(self.lineno),
                            'character': int(self.column)
                        }
                    },
                    'severity': self.severity,
                    'message': self.message
                }]
            })
        else:
            if self.filename == UNKNOWN_FILENAME:
                return '%s(%05d): %s, at line %d\n' % (str(self.__class__.__name__),
                                                       self.code,
                                                       self.message,
                                                       self.lineno)
            else:
                _list = []
                with open(self.filename, 'r', encoding='iso8859-15') as fd:
                    for i in range(self.lineno - 1):
                        fd.readline()
                    line = fd.readline()
                    _list.append('  File "%s",  line %d\n' % (self.filename, self.lineno))
                    i = 0
                    while i < len(line) and line[i].isspace():
                        i = i + 1
                    _list.append('    %s\n' % line.strip())
                    s = '    '
                    for c in line[i:self.column - 1]:
                        if c.isspace():
                            s = s + c
                        else:
                            s = s + ' '
                    _list.append('%s^\n' % s)
                    _list.append('%s(%05d): %s\n' % (str(self.__class__.__name__), self.code, self.message))
                    return "".join(_list)


class DeliaExceptions(Exception):
    def __init__(self, message):
        """Exception initializer.

        :param message: the error message from the parser
        """
        Exception.__init__(self, message)
        self.msg = message


class TokenizerException(DeliaException):
    def __init__(self, code, message, filename=None, lineno=-1, column=-1):
        DeliaException.__init__(self, code, message, filename, lineno, column)
        logging.getLogger('delia.tokenizer').error(repr(self))


class TokenError(TokenizerException):
    pass


class StopTokenizing(TokenizerException):
    pass


class IncludeException(DeliaException):
    def __init__(self, code, message, filename=None, lineno=-1, column=-1):
        DeliaException.__init__(self, code, message, filename, lineno, column)
        logging.getLogger('delia.preprocessor.include').error(repr(self))


class MacroException(DeliaException):
    def __init__(self, code, message, filename=None, lineno=-1, column=-1):
        DeliaException.__init__(self, code, message, filename, lineno, column)
        logging.getLogger('delia.preprocessor.macro').error(repr(self))


class ContextException(DeliaException):
    def __init__(self, message, code=-1):
        DeliaException.__init__(self, code, message)
        logging.getLogger('delia.commons').error(repr(self))


class SyntaxError(DeliaException):
    def __init__(self, code, message, filename=None, lineno=-1, column=-1):
        DeliaException.__init__(self, code, message, filename, lineno, column)
        logging.getLogger('delia.parser').error(repr(self))


def gen_macro_exceptions(code, message, filename, lineno, column, macro_stack):
    global ExceptionCounter
    ExceptionCounter += 1

    macro_stack.reverse()
    if macro_stack:
        m_name, m_lineno, m_col, m_path = macro_stack[0]
        messages = [f"{message} in {m_name}"]
        lines = [(filename, lineno, column), (m_path, m_lineno, m_col)]
        for m_name, m_lineno, m_col, m_path in macro_stack[1:]:
            messages.append(f"{message} in {m_name}")
            lines.append((m_path, m_lineno, m_col))
        messages.append(f"{message}")
        messages.reverse()
        lines.reverse()

        indent = 0
        for message, (filename, lineno, column) in zip(messages, lines):
            yield (code, f"[{ExceptionCounter:0>4}] " + "   " * indent + '|__' + message, filename, lineno, column)
            indent += 1

    else:
        yield (code, f"[{ExceptionCounter:0>4}] " + message, filename, lineno, column)


class SyntaxErrors(DeliaExceptions):
    def __init__(self, code, message, filename=None, lineno=-1, column=-1, macro_stack=[]):
        DeliaExceptions.__init__(self, "SYNTAX ERROR")
        self._errors = []
        for m_code, m_message, m_filename, m_lineno, m_column in gen_macro_exceptions(code, message, filename, lineno, column, macro_stack):
            self.add_error(SyntaxError(m_code, m_message, m_filename, m_lineno, m_column))

    def add_error(self, error):
        self._errors.append(error)

    def clear_error(self):
        self._errors.clear()

    def get_errors(self):
        return self._errors

    def has_error(self):
        return len(self._errors) > 0

    def __repr__(self):
        """Display the syntax error that just occurred.
        The output is written by sys.stderr.write().
        """
        res = ""
        for e in self.get_errors():
            res += "\n" + repr(e)
        return res


class SemanticError(DeliaException):
    def __init__(self, code, message, filename=None, lineno=-1, column=-1):
        DeliaException.__init__(self, code, message, filename, lineno, column)


class SemanticErrors(DeliaExceptions):
    def __init__(self):
        DeliaExceptions.__init__(self, "SEMANTIC ERROR")
        self._last_errors = set()

    def add_error(self, error):
        if error not in self._last_errors:
            self._last_errors.add(error)
            logging.getLogger('delia.validation').error(repr(error))

    def clear_error(self):
        self._last_errors.clear()

    def get_last_errors(self):
        return self._last_errors

    def has_error(self):
        return len(self._last_errors) > 0

    def __repr__(self):
        """Display the syntax error that just occurred.
        The output is written by sys.stderr.write().
        """
        res = ""
        for e in self.get_last_errors():
            res += "\n" + repr(e)
        return res


class SemanticWarning(DeliaException):
    def __init__(self, code, message, filename=None, lineno=-1, column=-1):
        DeliaException.__init__(self, code, message, filename, lineno, column, severity=2)


class SemanticWarnings(DeliaExceptions):
    def __init__(self):
        DeliaExceptions.__init__(self, "SEMANTIC WARN")
        self._last_warns = set()

    def add_warn(self, warn):
        if warn not in self._last_warns:
            self._last_warns.add(warn)
            logging.getLogger('delia.validation').error(repr(warn))

    def clear_warn(self):
        self._last_warns.clear()

    def get_last_warns(self):
        return self._last_warns

    def has_warn(self):
        return len(self._last_warns) > 0

    def __repr__(self):
        """Display the syntax error that just occurred.
        The output is written by sys.stderr.write().
        """
        res = ""
        for e in self.get_last_warns():
            res += "\n" + repr(e)
        return res


class UnusedDeclaration(DeliaException):
    def __init__(self, code, message, filename=None, lineno=-1, column=-1):
        DeliaException.__init__(self, code, message, filename, lineno, column, severity=2)


class UnusedDeclarations(DeliaExceptions):
    def __init__(self):
        DeliaExceptions.__init__(self, "Unused declaration INFO")
        self._last_warns = set()

    def add_warn(self, warn):
        if warn not in self._last_warns:
            self._last_warns.add(warn)
            logging.getLogger('delia.codegen').error(repr(warn))

    def clear_warn(self):
        self._last_warns.clear()

    def get_last_warns(self):
        return self._last_warns

    def has_warn(self):
        return len(self._last_warns) > 0

    def __repr__(self):
        """Display the syntax error that just occurred.
        The output is written by sys.stderr.write().
        """
        res = ""
        for e in self.get_last_warns():
            res += "\n" + repr(e)
        return res


class InvalidPictureError(DeliaException):
    pass


class DeliaError(DeliaException):
    def __init__(self, message):
        self.message = message
        Exception.__init__(self, message)

    def __repr__(self):
        return self.__class__.__name__ + ': [%s]' % (self.message)

    def __str__(self):
        return self.__class__.__name__ + ': [%s]' % (self.message)
