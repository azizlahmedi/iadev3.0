# -*- coding: utf-8 -*-
__rcs_id__ = "$Id$"

import configparser
import logging
import os
import sys
from urllib.parse import urlparse

from delia_commons.deliafile import normpath, urljoin
from delia_commons.exceptions import ContextException
from delia_commons.release import __version__, __author__
from delia_commons.singleton import Singleton

logger = logging.getLogger('delia.commons')


class Context(Singleton):
    '''Singleton for the Context class'''

    __config = None
    initialize_done = False

    def init(self):
        '''Return an instance of the Context class'''
        self.__mv_path = None
        self.__config = Config()

    def initialize(self, project_path, project_config_source=None,
                   delia_config_source=None):
        self.project_path = project_path
        self.__set_mv()
        self.__set_r_mv()

        if delia_config_source is not None:
            self.__config.read(delia_config_source)
        else:
            delia_config_source = normpath(
                os.path.join('~/.delia', 'delia.cfg'))
            if os.path.isfile(delia_config_source):
                self.__config.read(delia_config_source)

        if project_config_source is not None:
            self.__config.read(project_config_source)
        else:
            project_config_source = normpath(
                os.path.join(self.project_path, 'project.cfg'))
            if os.path.isfile(project_config_source):
                self.__config.read(project_config_source)

        self.set_source_file(self.__config.get('Remote', 'sourceFile'))
        self.set_dest_file(self.__config.get('Remote', 'destfile'))
        self.set_private_key_file(self.__config.get('Remote', 'privateKey'))
        self.set_user_name(self.__config.get('Remote', 'userName'))
        self.set_host_name(self.__config.get('Remote', 'host'))
        self.__set_project_name(self.__config.get('project', 'name'))
        self.__set_project_version(self.__config.getint('project', 'version'))
        self.__set_schema_name(self.__config.get('schema', 'name'))
        self.__set_schema_version(self.__config.getint('schema', 'version'))
        self.__set_enable_token_cache(self.__config.getboolean('cache', 'enable_token_cache', False))
        self.__set_enable_ast_cache(self.__config.getboolean('cache', 'enable_ast_cache', False))
        if self.enable_token_cache or self.enable_ast_cache:
            self.__set_cache_path(self.__config.get('cache', 'path'))
        self.__set_file_extension(
            self.__config.get('file', 'extension', '.adl'))

        self.__set_enable_pickle(
            self.__config.get('mv', 'enable_pickle', False))
        if self.__config.get('mv', 'path') is not None:
            self.__set_mv_path(self.__config.get('mv', 'path'))
            self.init_mv()

        self.logical_names = {}
        for (logical_name, path) in self.__config.items('logical_names', []):
            self.add_logical_name(logical_name, path)
        if 'magnum_default_directory' not in self.logical_names:
            e = ContextException("unable to find the key magnum_default_directory in the logical names")
            raise e

        self.bib_logical_names = [
            ln.lower() for ln in self.__config.getlist(
                'bib', 'logical_names', fallback=['BIB_APPLICATION', 'BIB', 'GP710B', 'GP2006B', 'GP2009B', ])
        ]

        self.mag_logical_names = [
            ln.lower() for ln in self.__config.getlist(
                'mag', 'logical_names', fallback=['MAGNUM_DEFAULT_DIRECTORY', 'GP710M', 'GP2006M', 'GP2009M', ])
        ]
        self.initialize_done = True

    ##########################################################################

    def __set_project_name(self, value=None):
        self.__project_name = value

    def __get_project_name(self):
        return self.__project_name

    project_name = property(__get_project_name, __set_project_name)

    ##########################################################################

    def set_source_file(self, value=None):
        self.__source_file = value

    def get_source_file(self):
        return self.__source_file

    source_file = property(get_source_file, set_source_file)

    ##########################################################################

    def set_dest_file(self, value=None):
        self.__dest_file = value

    def get_dest_file(self):
        return self.__dest_file

    dest_file = property(get_dest_file, set_dest_file)

    ##########################################################################

    def set_private_key_file(self, value=None):
        self.__private_key_file = value

    def get_private_key_file(self):
        return self.__private_key_file

    private_key_file = property(get_private_key_file, set_private_key_file)

    ##########################################################################

    def set_user_name(self, value=None):
        self.__user_name = value

    def get_user_name(self):
        return self.__user_name

    user_name = property(get_user_name, set_user_name)

    ##########################################################################

    def set_host_name(self, value=None):
        self.__host_name = value

    def get_host_name(self):
        return self.__host_name

    host_name = property(get_host_name, set_host_name)

    ##########################################################################

    def __set_project_version(self, value=None):
        self.__project_version = value

    def __get_project_version(self):
        return self.__project_version

    project_version = property(__get_project_version, __set_project_version)

    ##########################################################################

    def __set_project_path(self, value=None):
        if not os.path.isdir(normpath(value)):
            raise ContextException("The projet path '{}' is not directory or invalid path".format(value))
        else:
            self.__project_path = normpath(value)

    def __get_project_path(self):
        return self.__project_path

    project_path = property(__get_project_path, __set_project_path)

    ##########################################################################

    def __set_schema_name(self, value=None):
        self.__schema_name = value

    def __get_schema_name(self):
        return self.__schema_name

    schema_name = property(__get_schema_name, __set_schema_name)

    ##########################################################################

    def __set_schema_version(self, value=None):
        self.__schema_version = value

    def __get_schema_version(self):
        return self.__schema_version

    schema_version = property(__get_schema_version, __set_schema_version)

    ##########################################################################

    def __set_file_extension(self, value='.adl'):
        self.__file_extension = value

    def __get_file_extension(self):
        try:
            return self.__file_extension
        except:
            self.__set_file_extension('.adl')
            return self.__file_extension

    file_extension = property(__get_file_extension, __set_file_extension)

    ##########################################################################

    def __set_config_file_path(self, value=None):
        self.__config_file_path = normpath(value)

    def __get_config_file_path(self):
        return self.__config_file_path

    config_file_path = property(__get_config_file_path, __set_config_file_path)

    ##########################################################################

    def __set_enable_token_cache(self, value=True):
        self.__enable_token_cache = value

    def __get_enable_token_cache(self):
        return self.__enable_token_cache

    enable_token_cache = property(
        __get_enable_token_cache,
        __set_enable_token_cache)

    ##########################################################################

    def __set_enable_ast_cache(self, value=True):
        self.__enable_ast_cache = value

    def __get_enable_ast_cache(self):
        return self.__enable_ast_cache

    enable_ast_cache = property(__get_enable_ast_cache, __set_enable_ast_cache)

    ##########################################################################

    def __set_cache_path(self, value=None):
        import errno
        if self.project_name is not None:
            value = os.path.join(value, self.project_name)
        self.__cache_path = normpath(value)
        try:
            os.makedirs(self.__cache_path)
        except os.error as e:
            if e.errno != errno.EEXIST:
                raise ContextException(
                    "Failed to create cache directory: '%s' : %s" % (
                        value, str(e)))

    def __get_cache_path(self):
        return self.__cache_path

    cache_path = property(__get_cache_path, __set_cache_path)

    ##########################################################################

    def __set_enable_pickle(self, value=False):
        self.__enable_pickle = value

    def __get_enable_pickle(self):
        return self.__enable_pickle

    enable_pickle = property(__get_enable_pickle, __set_enable_pickle)

    ##########################################################################

    def __set_mv_path(self, value=None):
        tpath = normpath(value)
        if os.path.isabs(tpath):
            self.__mv_path = tpath
        else:
            self.__mv_path = normpath(os.path.join(self.project_path, tpath))
        if not os.path.isfile(self.__mv_path):
            raise ContextException("no such mv path: '%s'" % self.__mv_path)

    def __get_mv_path(self):
        return self.__mv_path

    mv_path = property(__get_mv_path, __set_mv_path)

    ##########################################################################

    def __set_mv(self, value={}):
        self.__mv = value

    def __get_mv(self):
        return self.__mv

    mv = property(__get_mv, __set_mv)

    ##########################################################################

    def __set_r_mv(self, value={}):
        self.__r_mv = value

    def __get_r_mv(self):
        return self.__r_mv

    r_mv = property(__get_r_mv, __set_r_mv)

    ##########################################################################

    def __set_logical_names(self, value={}):
        self.__logical_names = value

    def __get_logical_names(self):
        return self.__logical_names

    logical_names = property(__get_logical_names, __set_logical_names)

    ##########################################################################

    def add_logical_name(self, name, path):
        if name in self.logical_names:
            raise ContextException('duplicate logical name %' % name)
        npath = normpath(path)
        if os.path.isabs(npath):
            self.logical_names[name] = npath
        else:
            self.logical_names[name] = normpath(
                os.path.join(self.project_path, npath))

    def get_logical_name(self, logical_name):
        if logical_name in self.logical_names:
            return self.logical_names[logical_name]
        else:
            return None

    def get_url_logical(self, project):
        '''Get the logicals given the base url'''
        # Get the URL
        url = urlparse(project)
        # Check if HTTP or HTTPS
        if not url.scheme in ['http', 'https', 'file', ]:
            # Invalid URL
            raise ContextException('http[s] or file expected: got %s' % url)
        # Store logicals
        logicals = {}
        # Get the base
        base = urljoin(url.geturl(), 'gp%d' % self.project_version)
        # Go threw logicals
        for logical, path in self.__config.items('logical_names', []):
            # Process path
            path = normpath(path)
            # Check if absolute path
            if os.path.isabs(path):
                # Can't process relative path
                raise ContextException(
                    'relative logical required: got %s' % path)
            # Get the URL for the logical
            logicals[logical] = urljoin(base, path.replace(os.sep, '/'))
        # Return the logicals
        return logicals

    __includes_dic = []

    def get_includes_dic(self):
        return self.__includes_dic

    def get_include_idx(self, include_name):
        if include_name in self.__includes_dic:
            return self.__includes_dic.index(include_name)
        else:
            self.__includes_dic.append(include_name)
            return self.__includes_dic.index(include_name)

    def init_mv(self):
        if self.enable_pickle:
            import pickle
            mv_pickle_path = self.mv_path.replace(".py", ".pickle")
            if not os.path.exists(mv_pickle_path) or os.path.getmtime(mv_pickle_path) < os.path.getmtime(self.mv_path):
                exec(
                    compile(
                        open(self.mv_path).read(),
                        self.mv_path,
                        'exec'),
                    self.__dict__)
                if "mv" in self.__dict__:
                    self.__set_mv(self.__dict__["mv"])
                else:
                    self.__set_mv()
                if "r_mv" in self.__dict__:
                    self.__set_r_mv(self.__dict__["r_mv"])
                else:
                    self.__set_r_mv()
                with open(mv_pickle_path, 'wb') as f:
                    mv = {'mv': self.__get_mv(), 'r_mv': self.__get_r_mv()}
                    pickle.dump(mv, f)
            else:
                with open(mv_pickle_path, 'rb') as f:
                    mv = pickle.load(f)
                    self.__set_mv(mv["mv"])
                    self.__set_r_mv(mv["r_mv"])
        else:
            with open(self.mv_path) as mv_fd:
                exec(
                    compile(
                        mv_fd.read(),
                        self.mv_path,
                        'exec'),
                    self.__dict__)
            if "mv" in self.__dict__:
                self.__set_mv(self.__dict__["mv"])
            else:
                self.__set_mv()
            if "r_mv" in self.__dict__:
                self.__set_r_mv(self.__dict__["r_mv"])
            else:
                self.__set_r_mv()

    def log(self, level=logging.INFO):
        logger.log(level, "[config] platfrom: %s", sys.platform)
        logger.log(level, "[config] python prefix: %s", sys.prefix)
        logger.log(level, "[config] python version: %s", sys.version)
        logger.log(level, "[config] delia release version: %s", __version__)
        logger.log(level, "[config] delia release author: %s", __author__)
        logger.log(level, "[config] delia RCS Id: %s", __rcs_id__)
        self.__config.log(level)


class Config(object):
    def __init__(self, *args, **kwargs):
        self.parser = configparser.RawConfigParser(*args, **kwargs)

    def read(self, source):
        if isinstance(source, dict):
            self.parser.read_dict(source)
        else:
            self.parser.read((source,))

    def log(self, level=logging.INFO):
        for section in self.sections():
            for (name, value) in self.items(section):
                logger.log(level, "[config] %s.%s=%s" % (section, name, value))

    def get(self, section, option, fallback=None):
        return self.parser.get(section, option, fallback=fallback)

    def getboolean(self, section, option, fallback=False):
        return self.parser.getboolean(section, option, fallback=fallback)

    def getint(self, section, option, fallback=0):
        try:
            return self.parser.getint(section, option, fallback=fallback)
        except ValueError:
            return fallback

    def getlist(self, section, option, fallback=None):
        value_list = self.get(section, option, fallback=None)
        if value_list is None:
            return fallback
        values = []
        for value_line in value_list.split('\n'):
            for value in value_line.split(','):
                value = value.strip()
                if value:
                    values.append(value)
        return values

    def __getattr__(self, name):
        return getattr(self.parser, name)
