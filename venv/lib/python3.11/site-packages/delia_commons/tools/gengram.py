import sys
import os
import re

reSpaces = re.compile("\\s+")
unquoted = "[^'\"]%s[^'\"]?"


def gen_ast_generic(rules):
    res = "\n".join(["import delia.compiler.parser.asthandler",
                      "",
                      "class AstGeneric(delia.compiler.parser.asthandler.AstHandler):",
                      ""])

    for target, options in rules:
        tmp = []
        for t in options:
            tmp.append(" ".join(t))

        res = res + "\n".join([
            '    def ac_%s(self, target, option, names, values):' % target,
            '        """',
            '        %s' % target,
            '            : ' + "\n            | ".join(tmp),
            '        """',
            '        return self.defaultHandle(',
            '            target="%s",' % target,
            '            option=option,',
            '            names=names,',
            '            values=values)',
            '\n',
            ])
    return res


def gen_bison_parser(prologue, rules, epilogue):
    res = prologue + '\n%%' 

    for target, options in rules:
        rule = ""
        opt_idx = 0
        for opt in options:
            if len(opt) == 1 and len(opt[0]) == 0:
                fct_callback = ['$$ = ac_callback(ast_handler, "%s", %d, 0,' % (target, opt_idx),
                              '\t\t\t\tNULL']
            else:
                fct_callback = ['$$ = ac_callback(ast_handler, "%s", %d, %d' % (target, opt_idx, len(opt))]

                elt_idx = 1
                for elt in opt:
                    if elt > 1:
                        fct_callback.append('\t\t\t\t,"%s",$%d' % (elt, elt_idx))
                    else:
                        fct_callback.append('\t\t\t\t"%s",$%d' % (elt, elt_idx))
                    elt_idx = elt_idx + 1
            fct_callback.append('\t\t\t\t);')
            if opt_idx == 0:
                rule = rule + "\n".join([ target + ":", "\t\t" + " ".join(opt), "\t\t\t{" + "\n".join(fct_callback)])
            else:
                rule = rule + "\n".join([ "\n\t\t|\t" + " ".join(opt), "\t\t\t{" + "\n".join(fct_callback)])
            opt_idx = opt_idx + 1
            rule = rule + "\n\t\t\t}\n"

        res = res + "\n" + rule + "\n\t\t;\n"

    res = res + "\n%%" + epilogue
    return res


def parse_bison_file(bisonfilePath):

    try:
        rawBison = file(bisonfilePath).read()
    except:
        raise Exception("Cannot open bison file %s" % bisonfilePath)
    try:
        prologue, rulesRaw, epilogue = rawBison.split("\n%%\n")
    except:
        raise Exception(
            "File " + bisonfilePath + " is not a properly formatted bison file" + \
            " (needs 3 sections separated by %%%%"
            )

    # --------------------------------------
    # process prologue

#    prologue = prologue.split("%}")[-1].strip() # ditch the C code
    prologue = re.sub("\\n([\t ]+)", " ", prologue)  # join broken lines

    # prologueLines = [line.strip() for line in prologue.split("\n")]
    lines = prologue.split("\n")
    tmp = []
    for line in lines:
        tmp.append(line.strip())
    prologueLines = tmp

    prologueLines = [_f for _f in prologueLines if _f]
    tokens = []
    precRules = []
    for line in prologueLines:
        words = reSpaces.split(line)
        kwd = words[0]
        args = words[1:]
        if kwd == '%token':
            tokens.extend(args)
        elif kwd in ['%left', '%right', '%nonassoc']:
            precRules.append((kwd, args))
        elif kwd == '%start':
            startTarget = args[0]

    # -------------------------------------------------------------
    # process rules
    rulesRaw = re.sub("\\n([\t ]+)", " ", rulesRaw)  # join broken lines

    rulesLines = []
    for r in re.split(unquoted % ";", rulesRaw):

        r = r.strip()
        if r:
            rulesLines.append(r)

    rules = []
    for rule in rulesLines:

        try:
            tgt, terms = re.split(":", rule)
        except ValueError:
            print("Error in rule: %s" % rule)
            raise

        tgt, terms = tgt.strip(), terms.strip()

        tmp = []
        for t in re.split(r"\|", terms):

            t = t.strip()
            tmp.append(reSpaces.split(t))
        terms = tmp
        rules.append((tgt, terms))
    return(prologue, rules, epilogue)


if __name__ == "__main__":

    args = sys.argv[1:]
    inFileName = args and args[0] or "bison_parser.org"

    if len(args) > 1:
        bisonFileName = args[1]
    else:
        bisonFileName = "bison_parser.y"

    if len(args) > 2:
        astFileName = args[2]
    else:
        astFileName = "astgeneric.py"

    (prologue, rules, epilogue) = parse_bison_file(inFileName)

    try:
        print(gen_bison_parser(prologue, rules, epilogue), file=open(bisonFileName, "w"))
        print(gen_ast_generic(rules), file=open(astFileName, "w"))
    except IOError as err:
        sys.stdout.write("I/O error: %s\r?\n" % str(err))
        sys.exit(1)
