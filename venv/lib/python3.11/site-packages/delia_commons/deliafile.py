# -*- coding: utf-8 -*-
__rcs_id__ = "$Id$"

import os
import urllib.parse

from delia_commons.hash import mphash

# Available bib folders
_bib_flds = ['bibsaisie',
             'bibverif',
             'bibconvert',
             'bibcalcul',
             'bibaffiche',
             'bibcherche',
             'bibparam',
             'bibconsult',
             'bibcontrol',
             'bibvalo',
             'bibtraite', ]

# The default bib folder
_bib_def_fld = 'others'


def normpath(pathname):
    '''Normalize path ( eliminating double slashes, etc.),
    normalize case of pathname, and expand shell variables
    of form $var and ${var}.'''
    return os.path.expanduser(
        os.path.normpath(
            os.path.normcase(
                os.path.expandvars(
                    pathname))))


def urljoin(url, path):
    '''Join a path with an URL'''
    path = path.strip()
    while path.endswith('/'):
        path = path[:-1]
    while url.endswith('/'):
        url = url[:-1]
    parse = list(urllib.parse.urlparse('%s/%s' % (url, path)))
    parse.pop(3)
    parse[2] = os.path.normpath(parse[2]).replace(os.sep, '/')
    return urllib.parse.urlunsplit(parse)


def path_name_convert(ctx, name, is_text, father=None):
    if is_text:
        return text_name_convert(ctx, name)
    else:
        return file_name_convert(ctx, name, father)


def file_name_convert(ctx, text, father=None):
    '''Convert INCLUDE FILE'''
    # Get the BIB data
    global _bib_flds, _bib_def_flds
    # Get the logicals
    logicals = ctx.logical_names
    # Get the logical
    parts = text.split(':')
    # Set logical
    logical = None
    # Check that there is a logical
    if len(parts) == 2:
        # Get the source
        source = parts[1].lower().strip()
        # Get the logical
        logical = parts[0].lower().strip()
        # Check if logical exists
        if logical not in logicals:
            logical = None
    # A logical is expected
    else:
        # Set source
        source = text.lower().strip()
    # Get the version in the context
    version = ctx.project_version
    # Check if logical defined
    if logical is not None:
        # Get the URL as string
        path = logicals[logical]
        # Go threw the versions in the MV
        for current in list(ctx.r_mv.keys()):
            # Check if there is a version in the logical
            if logical.find('%d' % current) != -1:
                # There is a version, so use it
                version = current
    # Else get current folder
    else:
        path = os.curdir
    # Case for ME0
    if len(source) > 4 and source[-4:] == '.me0':
        # Check if version exists in MV and that clear name exists in MV
        if version in ctx.r_mv and source[:-4] in ctx.r_mv[version]:
            # Split on procedure parts
            parts = ctx.r_mv[version][source[:-4]].replace('.', '_').split('_')
            # Go threw the parts to append them to the URL
            for part in parts:
                path = os.path.join(path, part)
            # Get the full path
            path = os.path.join(
                path,
                '%s%s' % ('_'.join(parts), ctx.file_extension))
        # Try to guess with father file
        elif father is not None:
            # Get the procedure
            parts = os.path.basename(father).replace('_', '.').split('.')[:-1]
            # Get the procedure
            procedure = '.'.join(parts).lower().strip()
            # Check if got the source
            if mphash(ctx.schema_name, procedure) == source[:-4]:
                # Go threw the parts to append them to the URL
                for part in parts:
                    path = os.path.join(path, part)
                # Get the full path
                path = os.path.join(path, os.path.basename(father))
            # Else failed to get
            else:
                path = os.path.join(path, source)
        # Other case
        else:
            path = os.path.join(path, source)
    # Check if this is a BIB
    elif logical in ctx.bib_logical_names:
        # Store folder prefix
        found = None
        # Go threw available prefix
        for fld in _bib_flds:
            # Check if source starts with the prefix
            if source.startswith(fld):
                found = fld
        # Prefix was not found, use default one
        if found is None:
            path = os.path.join(path, _bib_def_fld, source)
        # We found a prefix, add it
        else:
            path = os.path.join(path, found, source)
    elif logical in ctx.mag_logical_names:
        path = os.path.join(path, os.path.splitext(source)[0].replace('_', os.path.sep), source)
    # Other case
    else:
        path = os.path.join(path, source)
    # Get the path
    return normpath(path)


def text_name_convert(ctx, name):
    logical_names = ctx.logical_names
    path = normpath(
        os.path.join(
            logical_names['magnum_default_directory'],
            name.lower().replace('.', '_') + ctx.file_extension))
    if not os.path.isfile(path):
        relative_path = name.replace('.', '/')
        relative_path = relative_path.replace('_', '/')
        path = normpath(
            os.path.join(
                logical_names['magnum_default_directory'],
                relative_path.lower(),
                name.lower().replace('.', '_') + ctx.file_extension))
    return path


class DeliaFile(object):
    def __init__(self, ctx, is_text, name, path=None, father=None):
        self.__is_text = is_text
        self.__name = name
        if path is None:
            self.__path = path_name_convert(ctx, name, is_text, father)
        else:
            self.__path = normpath(path)

    def __get_is_text(self):
        return self.__is_text

    is_text = property(__get_is_text)

    def __get_name(self):
        return self.__name

    name = property(__get_name)

    def __get_path(self):
        return self.__path

    path = property(__get_path)
