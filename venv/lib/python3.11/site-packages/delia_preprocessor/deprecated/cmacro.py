from delia_commons.exceptions import MacroException
from delia_tokenizer.tokenize import *
from delia_tokenizer.token import *
import logging
import warnings
logger=logging.getLogger('delia.preprocessor.macro')


def scanne_macro( tokens_gen, macro_dic={}, stack_macro=[]):
    warnings.warn('scanne_include deprecated')
    for token_infos in tokens_gen:
        token_type = token_infos[0]
        if token_type  == MACRO:
            m = Macro( *token_infos, tokens_gen=tokens_gen)
            macro_dic[m.name] = m
        elif token_type == mag_name:
            macro_name = token_infos[1].lower()
            if macro_name in macro_dic:
                if macro_name in stack_macro:
                    raise MacroException(832, _('%d: MACRO %s cannot be called recursively') %  (get_lineno(*token_infos), macro_name)) # pylint: disable-msg=E0602
                stack_macro.append(macro_name)
                macro = macro_dic[macro_name]
                macro_tokens_gen = expand_macros(tokens_gen,  macro)
                #yield (MACRO, macro.name, macro.offset, macro.lineno, -1, macro.path_idx)
                for ret in scanne_macro( macro_tokens_gen, macro_dic, stack_macro):
                    yield ret
                #yield (END_MACRO, macro.name, macro.offset, macro.lineno, -1, macro.path_idx)
                stack_macro.pop()
            else:
                yield token_infos
        else:
            yield token_infos


class Macro:
    def __init__(self, type, token, offset, lineno, col, path_idx, tokens_gen):
        self.offset = offset
        self.lineno = lineno
        self.path_idx = path_idx
        self.formal_name_list={}
        self.len_formal_name_list=0
        self.body=[]
        self.parse(tokens_gen)

    def parse(self, tokens_gen):
        self.extract_name(tokens_gen)
        self.extract_formal_name_list(tokens_gen)
        self.extract_body(tokens_gen)
        
    def extract_name(self, tokens_gen ):
        for token_infos in tokens_gen:
            if get_type(*token_infos) == comment:
                continue
            if get_type(*token_infos) == mag_name:
                self.name = get_token(*token_infos).lower()
                return
            else:
                raise MacroException(156, _('This name is illegal here. Use one of the following: IS')) # pylint: disable-msg=E0602
        raise MacroException(156, _('This name is illegal here. Use one of the following: IS')) # pylint: disable-msg=E0602

    def extract_formal_name_list(self, tokens_gen):
        in_paren = False
        last_token_type = mag_name
        i = 0
        for token_infos in tokens_gen:
            type_token = get_type(*token_infos)
            if type_token == comment:
                continue
            if not in_paren:
                if type_token == IS:
                    self.len_formal_name_list = len(self.formal_name_list)
                    return
                elif type_token == LPAREN:
                    in_paren = True
                    last_token_type = type_token
                else:
                    raise MacroException(156, _('This name is illegal here. Use one of the following: IS')) # pylint: disable-msg=E0602
            else:
                if type_token == RPAREN:
                    in_paren = False
                elif type_token == mag_name and last_token_type in [LPAREN, COMMA]:
                    param_name = token_infos[1].lower()
                    if param_name not in self.formal_name_list:
                        self.formal_name_list[param_name] = (i, token_infos)
                        i = i + 1
                    else:
                        raise MacroException(156, _('Inconsistent number of parameters for calling MACRO')) # pylint: disable-msg=E0602
                elif type_token == COMMA:
                    if last_token_type != mag_name:
                        raise MacroException(156, _('This name is illegal here. Use one of the following: IS')) # pylint: disable-msg=E0602
                    else:
                        last_token_type = type_token
                else:
                    raise MacroException(156, _('This name is illegal here. Use one of the following: IS')) # pylint: disable-msg=E0602
                last_token_type = type_token
        
        raise MacroException(156, _('This name is illegal here. Use one of the following: IS')) # pylint: disable-msg=E0602
    
    def extract_body(self, tokens_gen):
        for token_infos in tokens_gen:
            type_token = token_infos[0]
            if type_token == END_MACRO:
                return
            else:
                self.body.append(token_infos)
        raise MacroException(156, _('This name is illegal here. Use one of the following: IS')) # pylint: disable-msg=E0602
    
        
    def sub(self, parameter_list=[]):
        if self.len_formal_name_list < len(parameter_list):
            raise MacroException(267, _("Inconsistent number of parameters for calling MACRO '%s'")% self.name) # pylint: disable-msg=E0602
        
        if len(self.formal_name_list) == 0:
            for token_infos in self.body:
                yield token_infos
        else:
            for token_infos in self.body:
                if token_infos[0] == mag_name:
                    param_name = token_infos[1].lower()
                    if param_name in self.formal_name_list:
                        (index, formal_param_token_infos) = self.formal_name_list[param_name]
                        for param_token_infos in parameter_list[index]:
                            yield param_token_infos
                    else:
                        yield token_infos
                else:
                    yield token_infos
            
    def __str__(self):
        res = "Macro " + self.name + "("
        sep = ""
        for param in self.formal_name_list:
            res = res + sep, param[1] + " "
            sep = ','
        res = res + ") IS "
        for token_infos in self.body:
            res = res + token_infos[1] + " "
        res = res + ' End.Macro'
        return res
    

def expand_macros(tokens_gen, macro ):
    if macro.len_formal_name_list == 0:
        macro_param = []
    else:
        macro_param = list(extarct_macro_param(tokens_gen, macro))
    return macro.sub(macro_param)

def extarct_macro_param(tokens_gen, macro):
    START_STATE = 0
    NEXT_PARAM_STATE = 1
    END_STATE = 2
    state = START_STATE
    param = []
    nb_paren = 0
    for token_infos in tokens_gen:
        type_token = token_infos[0]
        if type_token == comment:
            continue

        if type_token == LPAREN:
            nb_paren = nb_paren + 1
        elif type_token == RPAREN:
            nb_paren = nb_paren - 1
            
        if state == START_STATE:
            if type_token == LPAREN and nb_paren == 1:
                state = NEXT_PARAM_STATE
            else:
                raise MacroException(267, "Inconsistent number of parameters for calling MACRO %s" % macro.name)
            
        elif state == NEXT_PARAM_STATE:
            if type_token == RPAREN and nb_paren == 0:
                yield param
                param = []
                state = END_STATE
            elif type_token == COMMA and nb_paren == 1:
                yield param
                param = []
            else:
                param.append(token_infos)
                
        if state == END_STATE:
            return
        
    raise MacroException(267, "Inconsistent number of parameters for calling MACRO %s" % macro.name)
