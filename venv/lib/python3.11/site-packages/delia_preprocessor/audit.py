#-*- coding: utf-8 -*-
import os
import sys
import logging
import optparse
import traceback
import pyExcelerator

from delia_commons import Context
from delia_preprocessor.data import create
from delia_preprocessor.proxy import Proxy
from delia_commons.singleton import Singleton
from delia_preprocessor.provider import IrisProvider
from delia_preprocessor.plugins.match import MatchPlugin
from delia_preprocessor.plugins.audit import AuditPlugin
from delia_preprocessor.plugins.base import IteratorPlugin
from delia_preprocessor.plugins.token import IteratorStarter
from delia_preprocessor.plugins.include import IncludePlugin
from delia_preprocessor.plugins.macro import MacroBuildPlugin, MacroSubPlugin

logger = logging.getLogger()

def run():
    '''Call with sys.args'''
    _run(sys.argv)

def _run(argv):
    '''Entry point for the script'''
    # Create the option parser
    parser = optparse.OptionParser()
    # Get the SVN user
    parser.add_option('-u', '--user', dest='user', default=None, 
                  help='SVN user.')
    # Get the SVN password
    parser.add_option('-p', '--password', dest='password', default=None, 
                  help='SVN password.')
    # Get the SVN password
    parser.add_option('-s', '--svn-url', dest='project', default='https://iris.sungard-finance.fr/svn/viewvc/gp/trunk', 
                  help='project URL on SVN.')
    # Get the beginning revision
    parser.add_option('-b', '--begin', dest='start', type='int', default=None,
                  help='beginning revision.')
    # Get the final revision
    parser.add_option('-e', '--end', dest='stop', type='int', default=None, 
                  help='final revision.')
    # Get the gap
    parser.add_option('-g', '--gap', dest='gap', type='int', default=1, 
                  help='gap between processed revisions.')
    # Output folder for expanse
    parser.add_option('-f', '--folder', dest='folder', default='.', 
                  help='output folder for expansed file.')
    # Output folder for expanse
    parser.add_option('-o', '--option', dest='option', default=None, 
                  help='option to process.')
    # Configuration file
    parser.add_option('-c', '--config', dest='config', default=None, 
                  help='configuration file.')
    # Parse the options
    options = parser.parse_args(argv)[0]
    
    # Errors
    errors = 0
    
    # Go threw the data to check
    for value, cause in [ (options.user, 'user'),
                          (options.password, 'password'),
                          (options.start, 'beginning revision'),
                          (options.stop, 'final revision'),
                          (options.folder, 'output folder'),
                          (options.option, 'option'),
                          (options.config, 'configuration'),
                          (options.project, 'project URL') ]:
        # Check if specified
        if value is None:
            # Log
            logger.error('%s not specified' % cause)
            # Add error
            errors += 1
    
    # Check if configuration exists
    if options.config is not None and not os.path.isfile(options.config):
        # Log
        logger.error("configuration file doesn't exist: %s" % options.config)
        # Add error
        errors += 1
    
    # Check if errors
    if errors > 0:
        # Log it
        logger.error('%d errors found' % errors)
        # Exit
        sys.exit(1)
        
    # Exit status
    status = 0
    
    # Call processing
    try: process(options.user, options.password,
                 options.project,
                 options.start, options.stop, options.gap,
                 options.folder,
                 options.option,
                 options.config)
    # Get error
    except Exception as e:
        # Log
        logger.error(traceback.format_exc())
        # Set status
        status = 1
        
    # Log
    logger.info('done')
    
    # Exit with status
    sys.exit(status)

def process(user, password, project, start, stop, gap, folder, option, config):
    '''Audit code'''
    # Get option
    option = option.lower().replace('_', '.')
    # Check that folder exists
    if not os.path.exists(folder): os.makedirs(folder)
    # Get the context
    Context().initialize(os.path.dirname(config), project_config_source=config)
    # Store the revision
    revision = start
    # Go threw the revisions
    while revision <= stop:
        # Try
        try:
            # Log
            logger.info('process %s at revision %d' % (option, revision))
            # Get the provider
            provider = IrisProvider(user, password, project, revision, store=True)
            # Get the first file
            iterator, path = provider.get(Context(), is_text=True, text=option)
            # Get the plug in
            proxy = Proxy('starter', IteratorStarter(), data=create(iterator=iterator, path=path))
            # Get the output file
            expanse = os.path.join(folder, '%s.%d' % (option.replace('.', '_'), revision))
            # Get the tree
            Proxy('expanse', MatchPlugin(), data=create(path=expanse),
                father=Proxy('final', AuditPlugin(),
                    father=Proxy('sub', MacroSubPlugin(),
                        father=Proxy('build', MacroBuildPlugin(),
                            father=Proxy('initial', AuditPlugin(),
                                father=Proxy('iterator', IteratorPlugin(),
                                    father=Proxy('include', IncludePlugin(), data=create(provider=provider), father=proxy)
                                )
                            )
                        )
                    )
                )
            )
            # Run
            proxy.run()
            # Get initial data
            i_lines, i_tokens, _ = proxy.get('initial')
            # Get final data
            f_lines, f_tokens, acros = proxy.get('final')
            # Get the date
            date = provider.date(revision)
            # Store data
            store(option, revision, date, folder, i_lines, i_tokens, f_lines, f_tokens, acros)
        # Get interruptions
        except KeyboardInterrupt as e: raise e
        # Else log
        except:
            # Log
            logger.error(traceback.format_exc())
            # Log
            logger.error('failed to process %s at revision %d' % (option, revision))
        # Add
        revision += gap

def store(option, revision, date, folder, i_lines, i_tokens, f_lines, f_tokens, acros):
    # Get the path of the excel file
    excel = os.path.join(folder, '%s.xls' % option.replace('.', '_'))
    # Create a new doc
    doc = pyExcelerator.Workbook()
    # Get the next raws
    nexts = {}
    # Set the sheets for macros
    for acro in list(acros.keys()): nexts[acro] = 0
    # Store the sheets
    sheets = {option: doc.add_sheet(option), }
    # Create the sheets
    for entry in list(nexts.keys()):
        # Check
        if len(entry) > 31: raise Exception('tab entry too long')
        # Add the sheet
        sheets[entry] = doc.add_sheet(entry)
    # Set the sheet for option
    nexts[option] = 0
    # Check if file already exists
    if os.path.exists(excel):
        # Get the previous doc
        previous = pyExcelerator.parse_xls(excel)
        # Go threw it
        for entry, data in previous:
            # Get the bound
            bound = 0
            # Check if add the sheet
            if entry not in sheets:
                # Create a new one
                sheet = doc.add_sheet(entry)
            # Else get existing one
            else: sheet = sheets[entry]
            # Go threw the data
            for row, col in list(data.keys()):
                # Set bound
                if row > bound: bound = row
                # Add data
                foo =  data[ (row, col) ]
                # Write data
                sheet.write(row, col, data[ (row, col) ])
            # Check if bound
            if entry in nexts: nexts[entry] = bound + 1
    # Set the lines
    sheet = sheets[option]
    # Get the row
    row = nexts[option]
    # Add the line
    sheet.write(row, 0, revision)
    sheet.write(row, 1, date.isoformat())
    sheet.write(row, 2, i_lines)
    sheet.write(row, 3, i_tokens)
    sheet.write(row, 4, f_lines)
    sheet.write(row, 5, f_tokens)
    # Go threw the macros
    for acro in list(acros.keys()):
        # Get the macro
        i_lines, i_tokens, calls, f_lines, f_tokens = acros[acro]
        # Get the row
        row = nexts[acro]
        # Get the sheet
        sheet = sheets[acro]
        # Add the line
        sheet.write(row, 0, revision)
        sheet.write(row, 1, date.isoformat())
        sheet.write(row, 2, calls)
        sheet.write(row, 3, i_lines)
        sheet.write(row, 4, i_tokens)
        sheet.write(row, 5, f_lines)
        sheet.write(row, 6, f_tokens)
    # Create excel
    doc.save(excel)

if __name__=='__main__':
    process('mansion', '\\\\2Xbeyukr', 30000, 31000, 1000, '.', 'newport.gesenv.saienv', 'project.cfg')
    