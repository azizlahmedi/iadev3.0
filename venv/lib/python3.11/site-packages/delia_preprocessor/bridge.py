#-*- coding: utf-8 -*-
import marshal
from delia_tokenizer import *
import delia_preprocessor.excepts as excepts

class Writer(object):
    '''Writer for expanse'''
    
    LINE = 65535
    
    POSITION = 4095
    
    def __init__(self, fd, files, bridge):
        '''Initialize the bridge'''
        # Store the file descriptor
        self.fd = fd
        # Store the files
        self.files = files
        # Store bridge data
        self.bridge = bridge
        # Store line
        self.line = 1
        # Store position
        self.pos = 1
        # Store last written data
        self.last = None
        # Check position
        assert fd.tell() == 0
    
    def check(self):
        '''Check line and position'''
        # Check line
        if self.line > self.LINE: raise excepts.BridgeError(_('line error'))    # pylint: disable-msg=E0602
        # Check position
        if self.pos > self.POSITION: raise excepts.BridgeError(_('line too long'))    # pylint: disable-msg=E0602

    def link(self, token):
        '''Write the token and link it'''
        # Get the content
        content = get_token(*token)
        # Filter of useless token
        if get_type(*token) not in [comment, WS, ]:
            # Link
            self.bridge.link(token, self.line, self.pos)
            # Add a link
            self.pos += len(content)
            # Write the content
            self.fd.write(content)
            # Store last
            self.last = content
        # Write as basic content
        else: self.write(content)
        # Check
        self.check()

    def write(self, string):
        '''Write in the Unix way'''
        # Go threw the string
        for char in string:
            # Check if this is a new line
            if char == '\n':
                # Go to the line
                self.line += 1
                # Set position
                self.pos = 1
            # Set position
            else: self.pos += 1
        # Write content
        self.fd.write(string)
        # Store last
        self.last = string
        # Check
        self.check()
        
class IBridge(object):
    '''A bridge between expanse and original files'''
    
    desc = None
    
    def __init__(self, files=None):
        '''Initialize the bridge'''
        # Store data
        self.data = {}
        # Store files
        self.files = files
    
    def load(self, fd):
        '''Load data'''
        # Get the description
        desc = marshal.load(fd)
        # Check validity
        if desc != self.desc:
            # Invalid data
            raise excepts.BridgeError(_('a %s bridge was expected: got %s') % (self.desc, desc))    # pylint: disable-msg=E0602
        # Load files
        self.files = marshal.load(fd)
        # Load data
        self.data = marshal.load(fd)

    def pload(self, path):
        '''Load data given a path'''
        # Get the file descriptor
        fd = open(path, 'rb')
        # Load
        self.load(fd)
        # Close
        fd.close()

    def save(self, fd):
        '''Save the data'''
        save(fd, self.desc, self.files, self.data)
        
    def psave(self, path):
        '''Save data given a path'''
        # Get the file descriptor
        fd = open(path, 'wb')
        # Load
        self.save(fd)
        # Close
        fd.close()
    
    def link(self, token, line, col=None):
        '''
        Link token to position in produced file
        - token: the token in the initial file,
        - line: the line in expanse,
        - pos: the offset in expanse,
        - col: the column in expanse.
        '''
        # Has to be override
        raise NotImplementedError("IBridge can't be used directly")

    def get(self, line, col=None):
        '''Get the correspondence for the given line and column in expanse'''
        # Has to be override
        raise NotImplementedError("IBridge can't be used directly")
    
    def guess(self, line, col=None):
        '''Get the closest one'''
        # Has to be override
        raise NotImplementedError("IBridge can't be used directly")

class LineBridge(IBridge):
    '''Keep the correspondence between lines'''

    desc = 'line'

    def link(self, token, line, col=None):
        '''
        Link token to position in produced file
        - token: the token in the initial file,
        - line: the line in expanse,
        - pos: the offset in expanse,
        - col: the column in expanse.
        '''
        # Add to data
        self.data[line] = (get_path(*token), get_lineno(*token))

    def get(self, line, col=None):
        '''Get the correspondence for the given line and column in expanse'''
        # Search in data
        return self.data[line]
    
    def guess(self, line, col=None):
        '''Get the closest one'''
        # Try to get exact one
        try: return self.get(line, col)
        # Not exact
        except KeyError: raise NotImplemented('failed to guess... !')

class TokenBridge(IBridge):
    '''Keep the correspondence between tokens'''

    desc = 'token'

    def check(self, col):
        '''Check that column is specified'''
        # Check if specified
        if col is None:
            # Not specified
            raise excepts.BridgeError(_('position in line has to be specified for token bridge'))    # pylint: disable-msg=E0602

    def link(self, token, line, col=None):
        '''
        Link token to position in produced file
        - token: the token in the initial file,
        - line: the line in expanse,
        - pos: the offset in expanse,
        - col: the column in expanse.
        '''
        # Check
        self.check(col)
        # Add to data
        self.data[ (line, col) ] = (get_path(*token), get_lineno(*token), get_column(*token))

    def get(self, line, col=None):
        '''Get the correspondence for the given line and column in expanse'''
        # Check
        self.check(col)
        # Search in data
        return self.data[ (line, col) ]
    
    def guess(self, line, col=None):
        '''Get the closest one'''
        # Check
        self.check(col)
        # Try to get exact one
        try: return self.get(line, col)
        # Not exact
        except KeyError: raise NotImplemented('failed to guess... !')

def save(fd, desc, files, data):
    '''Save the data'''
    # Save description
    marshal.dump(desc, fd)
    # Save files 
    marshal.dump(files, fd)
    # Save data
    marshal.dump(data, fd)

def sort(x, y):
    '''Sort token data'''
    # Get the line and the position for the first one
    x1, x2 = x
    # Get the line and the position for the second one
    y1, y2 = y
    # Check lines
    code = cmp(x1, y1)
    # If equals, check position
    if code == 0: code = cmp(x2, y2)
    # Return the code
    return code
