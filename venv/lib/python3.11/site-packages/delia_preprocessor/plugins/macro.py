# -*- coding: utf-8 -*-

from .base import EventPlugin
from delia_tokenizer.token import *
from delia_tokenizer.tokenize import *
import delia_preprocessor.events as events
from delia_preprocessor.excepts import EventError
from delia_commons.exceptions import MacroException
from delia_preprocessor.iterator import fill, filter
from delia_preprocessor.macro import scan_macro, expand_macros, Macro


class MacroPlugin(EventPlugin):
    '''Create an iterator that expands macros'''

    def configure(self, desc, data):
        '''Configure the plug in'''
        # Store the macros
        self.acros = {}
        self.__files = []

    def default(self, event, *args):
        '''Event not expected'''
        # Raise an exception
        raise EventError(_('ITERATOR or FILE events expected: %s found') % events.listing[event])    # pylint: disable-msg=E0602

    def on_FILES(self, event, files):
        '''Let FILES event go threw'''
        self.__files = files

    def on_ITERATOR(self, event, iterator):
        '''Get the iterator to process it'''
        # Create the macro event
        yield events.MACROS, self.acros
        # Process the iterator to expand macros
        yield events.ITERATOR, scan_macro(iterator, self.acros, self.__files, stack=[])

    def get(self):
        '''Get the macros'''
        # Return the macros
        return self.acros


class MacroBuildPlugin(EventPlugin):
    '''Create macros objects'''

    def __init__(self):
        '''Initialize the plug in'''
        # Call super
        EventPlugin.__init__(self)
        # Store the macros
        self.acros = {}
        # Store data needed to create the macros
        self.data = None
        self.__files = None

    def on_FILES(self, event, files):
        '''Propagate macros'''
        self.__files = files
        # Send again files
        yield event, files
        # Send macros
        yield events.MACROS, self.acros

    def on_TOKEN(self, event, token):
        '''Process tokens'''
        # Get the type of token
        kind = get_type(*token)
        # Check if this is a macro
        if kind == MACRO:
            # It is the beginning of a macro, start storing data
            self.data = [(event, token)]
        # Check if this is the end of the macro
        elif kind == END_MACRO:
            # Set the end flag
            self.data.append((event, token))
            # Get the first token
            first = self.data[0][1]
            # Create the object
            acro = Macro(offset=get_offset(*first), lineno=get_lineno(*first), path_idx=get_path(*first), tokens_gen=iter(self.data[1:]), files=self.__files)
            # Store the macro in the dictionary
            if acro.name not in self.acros.keys():
                self.acros[acro.name] = acro
            else:
                raise MacroException(2020, _('%d: MACRO %s already defined') % (
                    acro.lineno, acro.name))
            # Send event
            yield events.M_DEFINE, acro
            # Clean up data
            self.data = None
            # Go threw the events
            for e in acro.events:
                yield e
        # Check if in a macro definition to add token
        elif self.data is not None:
            self.data.append((event, token))
        # Token outside a definition
        else:
            yield event, token

    def default(self, *event):
        '''Get default events'''
        # Add it
        if self.data is not None:
            self.data.append(event)

    def get(self):
        '''Get the macros'''
        # Return the macros
        return self.acros


class MacroSubPlugin(EventPlugin):
    '''Replace call by code'''

    def __init__(self):
        '''Initialize the plug in'''
        # Call super
        EventPlugin.__init__(self)
        # Store the macros
        self.acros = None
        # Store the current macro
        self.acro = None
        # Store the stack of macro
        self.stack = []
        # Store the data needed to call the macro
        self.data = []
        # Count parenthesis to get only needed data for call
        self.count = 0
        self.__files = None

    def on_FILES(self, event, files):
        '''Propagate macros'''
        self.__files = files

    def on_MACROS(self, event, acros):
        '''Store macros'''
        # Store macros
        self.acros = acros

    def on_TOKEN(self, event, token):
        '''Process the token'''
        # Get the type of token
        kind = get_type(*token)
        # Check if is a call
        if self.acro is not None:
            # In a call, store the token
            self.data.append((event, token))
            # Check if this is an opening parenthesis
            if kind == LPAREN:
                self.count += 1
            # Check if this is a closing parenthesis
            elif kind == RPAREN:
                # Decrease the parenthesis balance
                self.count -= 1
                # If goes to 0, this is the end of the call
                if self.count == 0:
                    # Step in
                    yield events.M_SUB_IN, self.acro
                    # Expand it
                    for inside in scan_macro(expand_macros(iter(self.data), self.acro, token, self.__files), self.acros, self.__files, self.stack):
                        # Send data
                        yield inside
                    # Step out
                    yield events.M_SUB_OUT, self.acro
                    # Clean up
                    self.acro = None
        # Check that not in a macro and found a name which could potentially be a macro
        elif self.acro is None and kind == mag_name:
            # Get the name of the macro
            entry = get_token(*token).lower()
            # Check if this macro is defined
            if entry in self.acros:
                # Check the number of parameters for the macro
                if len(self.acros[entry].formal_name_list) == 0:
                    # Step in
                    yield events.M_SUB_IN, self.acros[entry]
                    # If 0, we can process it right now
                    for inside in scan_macro(expand_macros(iter([]), self.acros[entry], token, self.__files), self.acros, self.__files, self.stack):
                        # Send data
                        yield inside
                    # Step out
                    yield events.M_SUB_OUT, self.acros[entry]
                # At least one parameter
                else:
                    # Reset data
                    self.data = []
                    # Store the macro object
                    self.acro = self.acros[entry]
                    # Reset the parenthesis counter
                    self.count = 0
            # Not found
            else:
                yield event, token
        # Other token, send it
        else:
            yield event, token

    def default(self, *event):
        '''Get default events'''
        # Add it
        self.data.append(event)
