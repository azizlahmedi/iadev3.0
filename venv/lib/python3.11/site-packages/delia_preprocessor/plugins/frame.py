#-*- coding: utf-8 -*-
from .base import EventPlugin
from delia_tokenizer import *

class FrameError(Exception):
    '''Exception class for errors on frames'''
    pass

class FramePlugin(EventPlugin):
    '''Plug in to log data'''
    
    def configure(self, desc, data):
        '''Configure the plug in'''
        # Check if inside a interesting FRAME
        self.inside = -1
        # Store the description of the FRAME
        self.entry = None
        # Check if FRAME keyword has to be skipped (in case of CLEAR FRAME, RESTORE FRAME, DISPLAY FRAME, INCLUDE FRAME) 
        self.skip = False
        # Store start of the FRAME
        self.start = None
        # Store stop of the FRAME
        self.stop = None
        # Store the files for errors
        self.files = None
        # Store result
        self.listing = {}

    def position(self, token):
        '''Return the position of the token for errors'''
        # Get it
        return _('%d:%d in %s') % (get_lineno(*token), get_column(*token), self.files[get_path(*token)])    # pylint: disable-msg=E0602

    def on_FILES(self, event, files):
        '''Get files'''
        # Store files
        self.files = files
    
    def on_TOKEN(self, event, token):
        '''Get tokens'''
        # Get the type of token
        kind = get_type(*token)
        # Keep interesting tokens
        if kind == comment: pass
        # This is interesting
        else:
            # Get the description of the FRAME
            if self.inside == 0:
                # Check this is the valid token
                if kind == mag_name:
                    # Get the description
                    self.entry = get_token(*token).lower()
                    # Go to the next step
                    self.inside = 1
                # Token not expected
                else: raise FrameError(_('frame name expected at %s') % self.position(token))    # pylint: disable-msg=E0602
            # Check the FROM keyword
            elif self.inside == 1:
                # Go to the next step
                if kind == FRAME_AREA: self.inside = 2
            # Get the start of the FRAME
            elif self.inside == 2:
                # Store the start
                try: self.start = int(get_token(*token))
                # Get error
                except: raise FrameError(_('integer expected at %s') % self.position(token))    # pylint: disable-msg=E0602
                # Go to the next step
                else: self.inside = 3
            # Check the TO keyword
            elif self.inside == 3:
                # Actually check
                if kind != TO: raise FrameError(_('keyword TO expected at %s') % self.position(token))    # pylint: disable-msg=E0602
                # Go to the next step
                self.inside = 4
            # Finalize the process
            elif self.inside == 4:
                # Get the stop of the FRAME
                try: self.stop = int(get_token(*token))
                # Get error
                except: raise FrameError(_('integer expected at %s') % self.position(token))    # pylint: disable-msg=E0602
                # Add to results
                else: self.listing[self.entry] = (self.start, self.stop)
                # Step out the FRAME
                self.inside = -1
            # Check if this is a FRAME keyword
            elif kind == FRAME:
                # Check if has to be skipped
                if self.skip: self.skip = False
                # Not skipped, step into processing
                else: self.inside = 0
            # Ignore cases 
            elif kind in [CLEAR, RESTORE, DISPLAY, INCLUDE_TOKEN, ]: self.skip = True
            # Other
            else: self.skip = False

    def get(self):
        '''Return results'''
        # Return FRAMES
        return self.listing
