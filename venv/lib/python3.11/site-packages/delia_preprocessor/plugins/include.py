#-*- coding: utf-8 -*-
from .base import EventPlugin
import delia_preprocessor.events as events
from delia_preprocessor.provider import get, FileProvider
from delia_preprocessor.excepts import EventError
from delia_preprocessor.include import scan_include
from delia_tokenizer import get_type, comment, WS, INCLUDE_TOKEN

class IncludePlugin(EventPlugin):
    '''Create an iterator that expands includes'''

    def configure(self, desc, data):
        '''Clean up the files'''
        # Store the files
        self.files = None
        # Store the provider
        self.provider = get(data.get('provider', FileProvider.entry), data=data)

    def default(self, event, *args):
        '''Event not expected, raise an exception'''
        # Not expected
        raise EventError(_('ITERATOR event expected: %s found') % events.listing[event])    # pylint: disable-msg=E0602
    
    def on_FILES(self, event, files):
        '''Store the files'''
        # Check that file list contains only one path
        assert(len(files) == 1)
        # Store the files
        self.files = files

    def on_ITERATOR(self, event, iterator):
        '''Get the ITERATOR event and create an iterator that expands includes'''
        # Create the iterator event
        yield events.ITERATOR, scan_include(
            scanner=iterator,
            path=self.files[0],
            provider=self.provider,
            files=self.files,
            stack=[],
            include=None)

    def get(self):
        '''Get the files'''
        # Return the files
        return self.files

class TokenIncludePlugin(EventPlugin):
    '''Replace includes by the real content'''

    def configure(self, desc, data):
        '''Configure the plug in'''
        # Create a stack to detect cyclic calls
        self.stack = []
        # Counter to handle includes
        self.count = 3
        # Store the files included
        self.files = None
        # Store the include token
        self.include = None
        # Store the type of include
        self.kind = None
        # Store the text description included
        self.text = None
        # Store the provider
        self.provider = get(data.get('provider', FileProvider.entry), data=data)

    def on_FILES(self, event, files):
        '''Receive the path of the root file'''
        # Check that file list contains only one path
        assert(len(files) == 1)
        # Check that stack contains nothing
        assert(self.stack == [])
        # Store files
        self.files = files
    
    def on_TOKEN(self, event, token):
        '''Receive a token'''
        # Ignore comment located inside and include
        if get_type(*token) in [comment, WS, ]:
            # Send token
            if self.count >= 2: yield event, token
        # Process other token than comment
        else:
            # Increment the counter
            self.count += 1
            # Check if an include is starting
            if get_type(*token) == INCLUDE_TOKEN:
                # An include starts, reset position counter
                self.count = 0
                # Store the include token
                self.include = token
            # Get the type of include
            elif self.count == 1:
                # Store the type of include
                self.kind = token
            # Get the file included
            elif self.count == 2:
                # Get an iterator
                iterator = [ (events.TOKEN, data) for data in [self.include, self.kind, token, ] ]
                # Go threw the included file
                for data in scan_include(scanner=iterator, path=self.files[0], provider=self.provider, files=self.files, stack=self.stack, include=None): yield data
            # Other token, return it
            else: yield event, token

    def get(self):
        '''Get the files list'''
        # Return the files
        return self.files
