#-*- coding: utf-8 -*-
import unittest

from .base import EventPlugin
from delia_preprocessor.events import *
from delia_preprocessor.tools import isiterable, posix
from delia_tokenizer import get_token, get_type, WS, comment, COLON

class AssertPlugin(object):
    '''Test plug in'''
    
    def __init__(self, iterator=None, function=None, output=None):
        '''Initialize the plug in'''
        # Iterator to start propagation
        self.iterator = iterator
        # Store the function that handle notifications
        self.function = function
        # Store the output
        self.output = output
        # Store the called steps
        self.steps = []
        # Store the notified events
        self.events = []
        
    def configure(self, desc, data):
        '''Configure the plug in'''
        # Add the flag
        self.steps.append('c')
        # Store description
        self.desc = desc
        # Store data
        self.data = data
    
    def start(self):
        '''Just start it'''
        # Add the flag
        self.steps.append('s')
        # Return the iterator
        return self.iterator
    
    def notify(self, *args):
        '''Notification'''
        # Add the flag
        self.steps.append('n')
        # Add to notified data
        self.events.append(args)
        # Check if a function is defined
        if self.function is not None:
            # Propagate
            return self.function(*args)
    
    def finalize(self):
        '''Finalization'''
        # Add the flag
        self.steps.append('f')
    
    def get(self):
        '''Get the result'''
        # Add the flag
        self.steps.append('g')
        # Return the result
        return self.output
    
    def close(self):
        '''Close'''
        # Add the flag
        self.steps.append('k')

    def assertDesc(self, desc):
        '''Assert on description'''
        # Check description
        if self.desc != desc:
            # Identity expected
            raise unittest.TestCase.failureException('desc: %s != %s' % (desc, self.desc))
        
    def assertData(self, data):
        '''Check on data data'''
        # Check data
        if self.data != data:
            # Identity expected
            raise unittest.TestCase.failureException('data: %r != %r' % (data, self.data))

    def assertSteps(self, steps):
        '''Assert on the steps'''
        # Get the result
        found = ''
        # Get a generator on the steps
        generator = iter(steps)
        # Go threw the generator
        for step in generator:
            # Get the counter
            counter = ''
            # Get the counter
            while step.isdigit():
                # Store the digit
                counter += step
                # Get the next one
                step = next(generator)
            # Check if there is a counter
            if counter != '':
                # Fill the found one
                found += int(counter) * step
            # Else just add
            else: found += step
        # Get expected one
        expected = ''.join(self.steps)
        # Check
        if expected != found:
            # Not identity
            raise unittest.TestCase.failureException('steps: %s != %s' % (expected, found))

    def assertEvents(self, expected):
        '''Assert on the events'''
        assertEvents(expected, self.events)

class StorePlugin(EventPlugin):
    '''Store token in a file'''
    
    def configure(self, desc, data):
        '''Configure the plug in'''
        # Get the path
        self.path = data.get('path')
        # Check if skip
        self.skip = data.getboolean('skip', True)
        # Get the file descriptor
        self.fd = open(self.path, 'w')
        # First token
        self.first = True

    def on_TOKEN(self, event, token):
        '''Get the tokens'''
        # Check if skip
        if not self.skip: self.fd.write(get_token(*token))
        # Else
        else:
            # Get kind of token
            kind = get_type(*token)
            # Skip
            if kind not in [comment, WS, ]:
                # Add the token without space if this is a colon
                if kind == COLON or self.first: self.fd.write(get_token(*token))
                # This is not a colon
                else: self.fd.write(' %s' % get_token(*token))
                # Check if first
                if self.first: self.first = False
    
    def finalize(self):
        '''Finalize the process'''
        # Close the file descriptor
        self.fd.close()
    
    def get(self):
        '''Get the data'''
        # Return the data
        return None

def assertEvents(expected, founds):
    '''Assert on events'''
    # Get the displayed output
    display = 'assert failed on events:\nexpected: %d events\nfound: %d events\nlisting:\n' % (len(expected), len(founds))
    # Check if equals
    equals = (len(expected) == len(founds))
    # Get the size
    size = min(len(expected), len(founds))
    # Go threw the token
    for exp, found in zip(expected, founds):
        # Check if this is equals
        ident = True 
        # Check the first one
        if exp[0] == found[0]:
            # Check macro calls
            if exp[0] in [M_DEFINE, M_SUB_IN, M_SUB_OUT, M_SUB_ARGS]:
                # Check the name
                if exp[1] != found[1].name: ident = False
            # Check the macro list
            elif exp[0] in [MACROS, ]:
                # Check length
                if len(exp[1]) != len(found[1]): ident = False
                # Check each
                else:
                    # Go threw
                    for entry in exp[1]:
                        # Check count
                        if exp[1].count(entry) != list(found[1].keys()).count(entry): ident = False
            # Check files
            elif not posix() and exp[0] == FILES:
                # Check file
                if [ p.lower() for p in exp[1] ] != [ p.lower() for p in found[1] ]: ident = False
            # Check others
            elif exp != found: ident = False
        # The first ones are not equals
        else: ident = False
        # Check if this one is equals
        if ident: display += '= | %s : %s\n' % (exp, found)
        # Not identical
        else:
            # Display
            display += '! | %s : %s\n' % (exp, found)
            # Set global flag
            equals = False
    # Still for expected
    for exp in expected[size:]: display += '- | %s\n' % (exp, )
    # Still for found
    for found in founds[size:]: display += '+ | %s\n' % (found, )
    # Check if raise
    if not equals: raise unittest.TestCase.failureException(display)

