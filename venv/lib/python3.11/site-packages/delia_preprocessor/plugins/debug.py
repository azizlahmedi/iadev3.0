# -*- coding: utf-8 -*-
from .base import EventPlugin
from delia_tokenizer.tokenize import *
import delia_preprocessor.events as events


class FLIPlugin(EventPlugin):
    '''
    Audit the code by adding FLI

    procedure test
    begin
        fields fli.debug.position as "10N"
        constant fli.debug.library = "debug"
        function fli.debug.debug(fli.debug.position) in fli.debug.library
        [...]
        fli.debug.debug(i)
        [...]
    end

    '''

    def configure(self, desc, data):
        '''Configure the plug in'''
        # Store position
        self.pos = 0
        # Get the field
        self.field = data.get('field', 'fli.debug.position')
        # Store the library
        self.lib = data.get('lib', 'fli.debug.library')
        # Store the FLI
        self.fli = data.get('fli', 'debug')
        # Store the function
        self.fct = data.get('fct', 'fli.debug.debug')
        # Store separators
        self.breaks = []
        # Go threw the specified tokens
        for entry in data.get('breaks', 'IF').split(','):
            # Process
            entry = entry.replace('\n', '').replace('\r', '').strip()
            # Check if interesting
            if entry != '':
                self.breaks.append(eval(entry))
        # Check if declared
        self.declared = False
        # Store last type of token
        self.last = None
        # Check if in type debug
        self.in_debug = False
        # Check if in a function
        self.in_fct = False
        # Count parenthesis
        self.parent = 0
        # Ignore token after SAME AS
        self.once = False

    def declare(self):
        '''Declare FLI'''
        # Get the code
        code = [(FIELDS, 'fields', -2),
                (mag_name, self.field, -2),
                (AS, 'as', -2),
                (quoted_string, '"10N"', -2),
                (CONSTANT, 'constant', -3),
                (mag_name, self.lib, -3),
                (EQ, '=', -3),
                (quoted_string, '"debug"', -3),
                (FUNCTION, 'function', -4),
                (mag_name, self.fct, -4),
                (LPAREN, '(', -4),
                (mag_name, self.field, -4),
                (RPAREN, ')', -4),
                (IN, 'in', -4),
                (mag_name, self.lib, -4), ]
        # Iterate
        for kind, token, index in code:
                yield events.TOKEN, (kind, token, index, index, index, index)

    def insert(self):
        '''Insert call'''
        # Get the code
        code = [(mag_name, self.fct),
                (LPAREN, '('),
                (integer, '%d' % self.pos),
                (RPAREN, ')'), ]
        # Iterate
        for kind, token in code:
            yield events.TOKEN, (kind, token, -5, -5, -5, -5)
        # New position
        self.pos += 1

    def on_I_STEP_IN(self, event, kind, text, index):
        '''Step in an include'''
#        # Check if process include
#        if self.include:
#            # Add code
#            for e in self.insert(): yield e
#        # Propagate
#        yield event, kind, text, index
        pass

    def on_I_STEP_OUT(self, event, kind, text, index):
        '''Step out an include'''
#        # Propagate
#        yield event, kind, text, index
#        # Check if process include
#        if self.include:
#            # Add code
#            for e in self.insert(): yield e
        pass

    def on_M_SUB_IN(self, event, acro, *args):
        '''Step in a macro'''
#        # Check if process macro
#        if self.acro:
#            # Add code
#            for e in self.insert(): yield e
#        # Propagate
#        yield event, acro
        pass

    def on_M_SUB_OUT(self, event, acro, *args):
        '''Step out a macro'''
#        # Propagate
#        yield event, acro
#        # Check if process macro
#        if self.acro:
#            # Add code
#            for e in self.insert(): yield e
        pass

    def on_TOKEN(self, event, token):
        '''Get the tokens'''
        # Get type of token
        kind = get_type(*token)
        # Check if not ignored token
        if kind not in [comment, WS, ]:
            # Check if FLI declared
            if (not self.declared) and (kind not in [PROCEDURE, mag_name, LPAREN, RPAREN, COMMA, RETURNING, BEGIN_TOKEN]):
                # Declare the FLI
                for e in self.declare():
                    yield e
                # Set flag
                self.declared = True
            # Check if in type debug
            if kind == mag_name and get_token(*token).lower() == 'type.debug' and get_type(*self.last) != FUNCTION:
                # Set the flag
                self.in_debug = True
                # Reset counter
                self.parent = 0
            # Check if in type debug
            elif self.in_debug:
                # Check if left parenthesis
                if kind == LPAREN:
                    self.parent += 1
                # Check if right parenthesis
                elif kind == RPAREN:
                    # Decrease
                    self.parent -= 1
                    # Check if all closed
                    if self.parent == 0:
                        # End of type debug
                        self.in_debug = False
                        # Return the nothing token
                        yield events.TOKEN, (NOTHING, 'nothing', -6, -6, -6, -6)
            # Check if in a function
            elif kind == FUNCTION:
                # Set flag
                self.in_fct = True
                # Reset counter
                self.parent = 0
                # Propagate
                yield event, token
            # Check if in a function
            elif self.in_fct:
                # Check if left parenthesis
                if kind == LPAREN:
                    self.parent += 1
                # Check if right parenthesis
                elif kind == RPAREN:
                    self.parent -= 1
                # Check if inside parenthesis
                elif self.parent != 0:
                    pass
                # Check if one token more
                elif get_type(*self.last) == AS:
                    # Store the type of token
                    self.once = token
                    # Step out function
                    self.in_fct = False
                # Check if tokens is not used in function
                elif kind not in [mag_name, RETURNING, SAME, AS, ]:
                    # Step out function
                    self.in_fct = False
                # Propagate
                yield event, token
            # Other case
            else:
                # Get the type
                if (get_type(*token) in self.breaks) and (get_type(*self.last) not in [THEN, ELSE, DO, COLON]) and (self.once != self.last):
                    # Insert
                    for e in self.insert():
                        yield e
                # Reset
                self.once = None
                # Propagate
                yield event, token
            # Store last token
            self.last = token
        # Propagate
        else:
            yield event, token
