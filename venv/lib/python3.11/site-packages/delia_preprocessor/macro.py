# -*- coding: utf-8 -*-

from delia_tokenizer.token import *
from delia_tokenizer.tokenize import *
import delia_preprocessor.events as events
from delia_commons.exceptions import MacroException


def resolve_token_infos(token_infos, files):
    if token_infos:
        if get_path(*token_infos) < len(files):
            token_path = files[get_path(*token_infos)]
        else:
            token_path = None
        token_lineno = get_lineno(*token_infos)
        token_column = get_column(*token_infos)
    else:
        token_path = None
        token_lineno = 1
        token_column = 1
    return token_path, token_lineno, token_column


class Macro:
    '''Macro definition'''

    def __init__(self, offset, lineno, path_idx, tokens_gen, files=[]):
        self.offset = offset
        self.lineno = lineno
        self.path_idx = path_idx
        self.files = files
        self.formal_name_list = {}
        self.body = []
        self.events = []
        self.parse(tokens_gen)

    def parse(self, tokens_gen):
        self.extract_name(tokens_gen)
        self.extract_formal_name_list(tokens_gen)
        self.extract_body(tokens_gen)

    def extract_name(self, tokens_gen):
        token_infos = None
        for event in tokens_gen:
            if event[0] == events.TOKEN:
                token_infos = event[1]
                if get_type(*token_infos) in [comment, WS, ]:
                    continue
                if get_type(*token_infos) == mag_name:
                    self.name = get_token(*token_infos).lower()
                    return
                else:
                    raise MacroException(156, _('This name is illegal here. Use one of the following: IS'), *resolve_token_infos(token_infos, self.files))  # pylint: disable-msg=E0602
            else:
                self.events.append(event)
        raise MacroException(156, _('This name is illegal here. Use one of the following: IS'), *resolve_token_infos(token_infos, self.files))  # pylint: disable-msg=E0602

    def extract_formal_name_list(self, tokens_gen):
        in_paren = False
        last_token_type = mag_name
        i = 0
        token_infos = None
        for event in tokens_gen:
            if event[0] == events.TOKEN:
                token_infos = event[1]
                type_token = get_type(*token_infos)
                if type_token in [comment, WS, ]:
                    continue
                if not in_paren:
                    if type_token == IS:
                        return
                    elif type_token == LPAREN:
                        in_paren = True
                        last_token_type = type_token
                    else:
                        raise MacroException(156, _('This name is illegal here. Use one of the following: IS'), *resolve_token_infos(token_infos, self.files))  # pylint: disable-msg=E0602
                else:
                    if type_token == RPAREN:
                        in_paren = False
                    elif type_token == mag_name and last_token_type in [LPAREN, COMMA]:
                        param_name = get_token(*token_infos).lower()
                        if param_name not in self.formal_name_list:
                            self.formal_name_list[param_name] = (i, token_infos)
                            i = i + 1
                        else:
                            raise MacroException(156, _('Inconsistent number of parameters for calling MACRO'), *resolve_token_infos(token_infos, self.files))  # pylint: disable-msg=E0602
                    elif type_token == COMMA:
                        if last_token_type != mag_name:
                            raise MacroException(156, _('This name is illegal here. Use one of the following: IS'), *resolve_token_infos(token_infos, self.files))  # pylint: disable-msg=E0602
                        else:
                            last_token_type = type_token
                    else:
                        raise MacroException(156, _('This name is illegal here. Use one of the following: IS'), *resolve_token_infos(token_infos, self.files))  # pylint: disable-msg=E0602
                    last_token_type = type_token
            else:
                self.events.append(event)

        raise MacroException(156, _('This name is illegal here. Use one of the following: IS'), *resolve_token_infos(token_infos, self.files))  # pylint: disable-msg=E0602

    def extract_body(self, tokens_gen):
        token_infos = None
        for event in tokens_gen:
            if event[0] == events.TOKEN:
                token_infos = event[1]
                type_token = get_type(*token_infos)
                if type_token == END_MACRO:
                    return
                else:
                    self.body.append(token_infos)
            else:
                self.events.append(event)
        raise MacroException(156, _('This name is illegal here. Use one of the following: IS'), *resolve_token_infos(token_infos, self.files))  # pylint: disable-msg=E0602

    def sub(self, parameter_list=[], caller_token=None):
        if len(self.formal_name_list) != len(parameter_list):
            raise MacroException(267, _("Inconsistent number of parameters for calling MACRO '%s'") % self.name, *resolve_token_infos(caller_token, self.files))  # pylint: disable-msg=E0602

        if len(self.formal_name_list) == 0:
            for token_infos in self.body:
                yield events.TOKEN, token_infos
        else:
            for token_infos in self.body:
                if get_type(*token_infos) == mag_name:
                    param_name = get_token(*token_infos).lower()
                    if param_name in self.formal_name_list:
                        (index, formal_param_token_infos) = self.formal_name_list[param_name]
                        for param_token_infos in parameter_list[index]:
                            yield events.TOKEN, param_token_infos[:2] + token_infos[2:]
                    else:
                        yield events.TOKEN, token_infos
                else:
                    yield events.TOKEN, token_infos

    def __str__(self):
        res = "Macro " + self.name
        if self.formal_name_list:
            res += "(" + ", ".join(self.formal_name_list) + ")"
        res += " IS "
        for token_infos in self.body:
            res = res + get_token(*token_infos) + " "
        res = res + ' End.Macro'
        return res


def scan_macro(scanner, acros={}, files=[], stack=[]):
    '''Scan'''
    # Go threw the generator
    for data in scanner:
        # Check if this is a token event. If this is not, return it
        if data[0] != events.TOKEN:
            yield data
        # This is a token
        else:
            # Get the token
            token_infos = data[1]
            # Get the token type
            cat = get_type(*token_infos)
            # Check if this is a definition
            if cat == MACRO:
                # Create the new object
                acro = Macro(offset=get_offset(*token_infos), lineno=get_lineno(*token_infos), path_idx=get_path(*token_infos), tokens_gen=scanner, files=files)
                # Add to the dictionary
                if acro.name not in acros.keys():
                    acros[acro.name] = acro
                else:
                    raise MacroException(2020, _('%d: MACRO %s already defined') % (
                        acro.lineno, acro.name), *resolve_token_infos(token_infos, files))
                # Send the event for definition
                yield events.M_DEFINE, acro
                # Go threw the events
                for event in acro.events:
                    yield event
            # Check if this can be a call
            elif cat == mag_name:
                # Get the name of the macro
                entry = get_token(*token_infos).lower()
                # Check if macro exists in dictionary
                if entry in acros:
                    # Check if already in stack
                    if entry in stack:
                        # This is a cyclic call, raise an exception
                        raise MacroException(832, _('%d: MACRO %s cannot be called recursively') % (get_lineno(*token_infos), entry), *resolve_token_infos(token_infos, files))  # pylint: disable-msg=E0602
                    # Add macro in the stack
                    stack.append(entry)
                    # Get the macro object
                    acro = acros[entry]
                    # Send the event for the beginning of the substitution
                    yield events.M_SUB_IN, acro, token_infos
                    # Substitute the macro
                    for i_data in scan_macro(expand_macros(scanner, acro, token_infos, files), acros, files, stack):
                        yield i_data
                    # Send the event for the end of the substitution
                    yield events.M_SUB_OUT, acro, token_infos
                    # Pop the macro from the stack
                    stack.pop()
                # This is not a macro, return the token
                else:
                    yield data
            # Default behavior, return the token
            else:
                yield data


def expand_macros(tokens_gen, macro, caller_token=None, files=[]):
    if(len(macro.formal_name_list)) == 0:
        args = []
    else:
        args = []
        for event in extract_macro_param(tokens_gen, macro, files):
            if event[0] == events.TOKEN:
                args.append(event[1])
            else:
                yield event
    yield events.M_SUB_ARGS, macro, args 
    for event in macro.sub(args, caller_token):
        yield event


def extract_macro_param(tokens_gen, macro, files):
    START_STATE = 0
    NEXT_PARAM_STATE = 1
    END_STATE = 2
    state = START_STATE
    param = []
    nb_paren = 0
    type_token = None
    for event in tokens_gen:
        if event[0] == events.TOKEN:
            token_infos = event[1]
            type_token = get_type(*token_infos)
            if type_token in [comment, WS, ]:
                continue

            if type_token == LPAREN:
                nb_paren = nb_paren + 1
            elif type_token == RPAREN:
                nb_paren = nb_paren - 1

            if state == START_STATE:
                if type_token == LPAREN and nb_paren == 1:
                    state = NEXT_PARAM_STATE
                else:
                    raise MacroException(267, "Inconsistent number of parameters for calling MACRO %s" % macro.name, *resolve_token_infos(token_infos, files))

            elif state == NEXT_PARAM_STATE:
                if type_token == RPAREN and nb_paren == 0:
                    yield events.TOKEN, param
                    param = []
                    state = END_STATE
                elif type_token == COMMA and nb_paren == 1:
                    yield events.TOKEN, param
                    param = []
                else:
                    param.append(token_infos)

            if state == END_STATE:
                return
        else:
            yield event

    raise MacroException(267, "Inconsistent number of parameters for calling MACRO %s" % macro.name, *resolve_token_infos(token_infos, files))
