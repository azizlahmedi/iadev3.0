# -*- coding: utf-8 -*-
from .data import Data
from .iterator import fill
from .tools import get_svn_date
from .excepts import ProviderError
from delia_commons import deliafile
from delia_commons.deliafile import urljoin
from delia_tokenizer.ctokenize import ScannerFromFile, ScannerFromString


class IProvider(object):
    '''Provide iterator and path'''

    def get(self, ctx, is_text, text, father=None):
        '''
        Return the iterator and path given:
        - The context,
        - The type of include
        - The file included
        - The path of the files that contains the include
        '''
        raise NotImplementedError


class StringProvider(IProvider):
    '''Provide iterators by parsing string'''
    entry = 'string'

    def __init__(self, skip_ws=True):
        '''Check if skip white space'''
        # Store
        self.skip_ws = skip_ws

    def get(self, ctx, is_text, text, father=None):
        '''
        Return the iterator and path given:
        - The context,
        - text a string to scan
        '''
        # Get the scanner
        scanner = fill(ScannerFromString(text))
        # Get the path
        path = "<String>"
        # Return scanner and path
        return scanner, path


class FileProvider(IProvider):
    '''Provide iterators by parsing files'''

    entry = 'file'

    def __init__(self, skip_ws=True):
        '''Check if skip white space'''
        # Store
        self.skip_ws = skip_ws

    def get(self, ctx, is_text, text, father=None):
        '''
        Return the iterator and path given:
        - The context,
        - The type of include
        - The file included
        '''
        # Get the DELIA file
        source = deliafile.DeliaFile(ctx=ctx, is_text=is_text, name=text, father=father)
        # Get the path
        path = source.path
        # Get the scanner
        scanner = fill(ScannerFromFile(path, skip_ws=self.skip_ws))
        # Return path and scanner
        return scanner, path


class PySVNProvider(IProvider):
    '''Base class for PySVN provider'''

    def __init__(self, user, pwd):
        '''Initialize the provider'''
        # Store the user for SVN
        self.user = user
        # Store the password for SVN
        self.pwd = pwd
        # Get the API for SVN
        self.api = __import__('pysvn')
        # Get a SVN client
        self.client = self.api.Client()

        # Set politic in case of authentication
        def ssl_server_trust_prompt(trust_dict):
            return True, 0, True

        self.client.callback_ssl_server_trust_prompt = ssl_server_trust_prompt
        # Set user in client
        self.client.set_default_username(self.user)
        # Set password in client
        self.client.set_default_password(self.pwd)

    def translate(self, revision=None):
        '''Convert a integer to a PySVN revision'''
        # Check if head asked
        if revision is None:
            return self.api.Revision(self.api.opt_revision_kind.head)
        # Revision asked
        else:
            return self.api.Revision(self.api.opt_revision_kind.number, revision)


class BaseIrisProvider(PySVNProvider):
    '''Base class for Iris provider'''

    def __init__(self, user, pwd, project, store=False):
        '''Initialize the provider'''
        # Call super
        PySVNProvider.__init__(self, user, pwd)
        # Store the trunk URL
        self.project = project
        # Check if store
        self.store = store
        # Get the storage
        self.cache = {}

    def cat(self, url, revision=None):
        '''Get the content of a URL at the given revision'''
        # Check if store
        if self.store:
            # Get the key
            key = (url, revision)
            # Check if in cache
            if key not in self.cache:
                # Get the content
                self.cache[key] = self.client.cat(url, self.translate(revision))
            # Return
            return self.cache[key]
        # Else process
        else:
            return self.client.cat(url, self.translate(revision))

    def parse(self, ctx, is_text, text, revision):
        '''Parse the provided data to return an URL and a revision'''
        # Get the logicals
        logicals = ctx.get_url_logical(self.project)
        # Check if this is an INCLUDE TEXT
        if is_text:
            # Split on procedure parts
            parts = text.lower().replace('.', '_').split('_')
            # Get the URL as a string
            url = logicals['magnum_default_directory']
            # Go threw the parts to append them to the URL
            for part in parts:
                url = urljoin(url, part)
            # Get the full URL
            url = urljoin(url, '%s%s' % ('_'.join(parts), ctx.file_extension))
        # Check if INCLUDE FILE
        else:
            # Get the logical
            parts = text.split(':')
            # Check that there is a logical
            if len(parts) == 2:
                # Get the source
                source = parts[1].lower().strip()
                # Get the logical
                logical = parts[0].lower().strip()
                # Check if logical exists
                if logical not in logicals:
                    # Logical not defined
                    raise ProviderError(_('failed to process logical: %s') % logical)    # pylint: disable-msg=E0602
            # A logical is expected
            else:
                raise ProviderError(_('logical expected for include of %s') % text)    # pylint: disable-msg=E0602
            # Get the version in the context
            version = ctx.project_version
            # Get the URL as string
            url = logicals[logical]
            # Go threw the versions in the MV
            for current in ctx.r_mv.keys():
                # Check if there is a version in the logical
                if logical.find('%d' % current) != -1:
                    # There is a version, so use it
                    version = current

            # Case for ME0
            if len(source) > 4 and source[-4:] == '.me0':
                # Check if version exists in MV
                if version in ctx.r_mv:
                    # Check if clear name define in MV
                    if source[:-4] in ctx.r_mv[version]:
                        # Split on procedure parts
                        parts = ctx.r_mv[version][source[:-4]].replace('.', '_').split('_')
                        # Go threw the parts to append them to the URL
                        for part in parts:
                            url = urljoin(url, part)
                        # Get the full URL
                        url = urljoin(url, '%s%s' % ('_'.join(parts), ctx.file_extension))
                    # Failed to get clear name
                    else:
                        raise ProviderError(_('fail to reverse %s') % source[:-4])    # pylint: disable-msg=E0602
                # Invalid version
                else:
                    raise ProviderError(_('unknown version: %s') % version)    # pylint: disable-msg=E0602

            # Check if this is a BIB
            elif len(source) > 4 and source[-4:] == '.bib' and \
                    ((version == 710 and revision >= 20490) or
                     (version == 2006 and revision >= 20489) or
                     version not in [710, 2006, ]):

                # Store folder prefix
                found = None
                # Go threw available prefix
                for fld in deliafile._bib_flds:
                    # Check if source starts with the prefix
                    if source.startswith(fld):
                        found = fld
                # Prefix was not found, use default one
                if found is None:
                    url = urljoin(urljoin(url, deliafile._bib_def_fld), source)
                # We found a prefix, add it
                else:
                    url = urljoin(urljoin(url, found), source)

            # general case
            else:
                url = urljoin(url, source)

            # Special case of the library which were not on SVN before revision 23000
            if logical == 'magnum_library':
                revision = max(revision, 23000)
        # Return the URL and the revision
        return url, revision

    def date(self, revision=None):
        '''Get the corresponding date of the revision'''
        return get_svn_date(self.client, self.project, self.translate(revision))


class IrisProvider(BaseIrisProvider):
    '''Provide sources on SVN'''

    entry = 'iris'

    def __init__(self, user, pwd, project, revision, store=False):
        '''Initialize the provider'''
        # Call super
        BaseIrisProvider.__init__(self, user, pwd, project, store=store)
        # Store the revision for the checkout
        self.revision = revision

    def get(self, ctx, is_text, text, father=None):
        '''Provide a scanner and the URL'''
        # Parse the data
        url, revision = self.parse(ctx, is_text, text, self.revision)
        # Get the content
        content = self.cat(url, revision)
        # Get a scanner
        scanner = fill(ScannerFromString(content.decode('ISO-8859-1')))
        # Return the scanner and the URL
        return scanner, url


def get(entry=FileProvider.entry, data=Data()):
    '''Get the described provider'''
    # Check if already a provider
    if isinstance(entry, IProvider):
        return entry
    # Check if skip white space
    skip_ws = data.getboolean('skip_ws', True)
    # Check if this is a file provider
    if entry == FileProvider.entry:
        return FileProvider(skip_ws=skip_ws)
    if entry == StringProvider.entry:
        return StringProvider(skip_ws=skip_ws)
    # Failed to get one
    else:
        raise ProviderError(_('invalid provider: %s') % repr(entry))    # pylint: disable-msg=E0602

