# -*- coding: utf-8 -*-

"""Token constants (from "bison_parser.h")."""

#  This file is automatically generated; please don't muck it up!
#
#  To update the symbols in this file, 'cd' to the top directory of
#  the delia source tree after building the interpreter and run:
#
#    python delia/tokenizer/token.py delia/parser/bison_parser.h

# --start constants--
KEYWORD = 258
ALL = 259
AND = 260
ARRAY = 261
AS = 262
BACKUP = 263
BEGIN_TOKEN = 264
BLANK = 265
BLINK = 266
BOLD = 267
CHANGING = 268
CHECK = 269
CKSUM = 270
CONCURRENT = 271
CONSTANT = 272
CONTROLS = 273
COUNT = 274
DATA = 275
DATE = 276
DAY = 277
DEFAULT = 278
DIGIT = 279
DIM = 280
DIRECTORY = 281
END = 282
ENTERED = 283
EQ = 284
EQV = 285
ERRORS = 286
EXISTS = 287
BOOLEAN_LITERAL_FALSE = 288
FIELD = 289
FIELDS = 290
FILE_TOKEN = 291
FLAG_OF = 292
FLOAT = 293
FOR = 294
GE = 295
GT = 296
ILLEGAL = 297
IN = 298
INDEX = 299
INITIAL_TOKEN = 300
IS = 301
KEY = 302
LANGUAGE = 303
LARGEST = 304
LE = 305
LONG_FLOAT = 306
LOW = 307
LT = 308
MINIMUM = 309
MOD = 310
MONTH = 311
NE = 312
NEXT_DATE = 313
NOT = 314
OF = 315
OFF = 316
ON = 317
OPAQUE = 318
OR = 319
ORDER = 320
PROCEDURE = 321
PROMPT = 322
PROTECTED = 323
RELATION = 324
RELATIONS = 325
REQUIRED = 326
REVERSE = 327
SAME = 328
SCHEMA = 329
SEPARATOR = 330
SMALLEST = 331
STORED = 332
SUBSCRIPTS = 333
SUBSTR = 334
TERMINATE = 335
TEXT = 336
TO = 337
BOOLEAN_LITERAL_TRUE = 338
UNDERLINE = 339
UPDATE = 340
USERS = 341
VALUE = 342
VERIFY = 343
VIA = 344
WITH = 345
XOR = 346
YEAR = 347
SUNDAY = 348
MONDAY = 349
TUESDAY = 350
WEDNESDAY = 351
THURSDAY = 352
FRIDAY = 353
SATURDAY = 354
ABORT = 355
ABORT_PROCEDURE = 356
ACCEPT = 357
ACCEPTING = 358
ADD = 359
AFTER = 360
ALIAS = 361
ALTER = 362
APPEND = 363
ASCENDING = 364
ASCII = 365
BACKUP_CHARACTER = 366
BACKUP_FIELD = 367
BINARY = 368
BORDER = 369
BOTTOM_MARGIN = 370
BY = 371
BYTE = 372
CHECKPOINT = 373
CHECKPOINT_ON_UPDATE = 374
CLEAR = 375
COLOR = 376
COMPILE = 377
CONDITIONAL = 378
CONDITIONALLY = 379
CONTROLLED = 380
DATA_NAMES = 381
DATA_NAME = 382
DELETE = 383
DESCENDING = 384
DISPLAY = 385
DO = 386
DUPLICATE = 387
EACH = 388
ECHO = 389
EDIT = 390
ELSE = 391
FIELD_CONTROL = 392
FIELD_FILLER = 393
FIELD_FLAGS = 394
FINISH = 395
FIXED = 396
FOOTING_SIZE = 397
FORCE = 398
FORM = 399
FRAME = 400
FRAME_AREA = 401
FRAME_FORMAT = 402
FREE = 403
FROM = 404
FUNCTION = 405
FUNCTION_KEY = 406
FUNCTION_LENGTH = 407
FUNCTION_SEPARATOR = 408
GET_HELP = 409
GLOBALLY = 410
GROUP_FOOTING = 411
GROUP_HEADING = 412
HEADING_SIZE = 413
HELP = 414
IF = 415
INPORT = 416
INPUT = 417
INSERT = 418
INTO = 419
INVALIDS = 420
KANA = 421
LET = 422
LINE_LENGTH = 423
LINE_NUM = 424
LOGOUT = 425
MESSAGE_AREA = 426
MINIMUM_LENGTH = 427
MOVE = 428
NO = 429
NOTHING = 430
OUTPORT = 431
OUTPUT = 432
PAGE_DIVIDER = 433
PAGE_FOOTING = 434
PAGE_HEADING = 435
PAGE_NUM = 436
PAGE_SIZE = 437
PAGE_TOP = 438
PAUSE = 439
PAUSE_FOR_INPUT = 440
PRINT = 441
REPEAT = 442
REPORT = 443
REPORTS = 444
REPORT_FOOTING = 445
REPORT_HEADING = 446
RESTORE = 447
RETURN = 448
RETURNING = 449
ROUNDED = 450
RUN = 451
SCREEN = 452
SCREEN_SIZE = 453
SELECT = 454
SEND_FRAME = 455
SET_CURSOR = 456
SKIP_FIELD = 457
SORTED = 458
SOURCE = 459
SUBTRACT = 460
TERMINAL = 461
TERMINATE_FIELD = 462
TERMINATOR = 463
THEN = 464
TOP_MARGIN = 465
TRUNCATED = 466
TYPE = 467
USING = 468
WAIT = 469
WHERE = 470
WHILE = 471
WRITE = 472
WRITE_INVALIDS = 473
AT_SKIP = 474
AT_TAB = 475
AT_CR = 476
AT_FF = 477
INCLUDE_TOKEN = 478
INNER = 479
JOIN = 480
GROUPED = 481
OUTER = 482
LEFT = 483
RIGHT = 484
FULL = 485
MACRO = 486
END_MACRO = 487
eof_term = 488
PUNCTUATION = 489
POW = 490
LPAREN = 491
RPAREN = 492
COMMA = 493
COLON = 494
SEMICOLON = 495
LBRACKET = 496
RBRACKET = 497
PLUS = 498
MINUS = 499
STAR = 500
SLASH = 501
DOUBLESLASH = 502
UNDERSCORE = 503
NT_OFFSET = 504
mag_name = 505
comment = 506
quoted_string = 507
kana_q_string = 508
date_lit = 509
at_integer = 510
integer = 511
dec_number = 512
short_float = 513
long_float = 514
content_include = 515
ERRORTOKEN = 516
UNARY = 517
WS = 518
STRING_ERROR = 519
MACRO_SUB_IN = 520
MACRO_SUB_OUT = 521
# --end constants--

tok_name = {}
for _name, _value in list(globals().items()):
    if type(_value) is type(0):
        tok_name[_value] = _name


def ISTERMINAL(x):
    return x < NT_OFFSET


def ISNONTERMINAL(x):
    return x >= NT_OFFSET


def ISEOF(x):
    return x == eof_term


def main():
    import re
    import sys

    args = sys.argv[1:]
    outFileName = sys.argv[0]
    inFileName = args and args[0] or "bison_parser.h"

    if len(args) > 1:
        outFileName = args[1]
    try:
        fp = open(inFileName)
        lines = fp.read().split("\n")
        fp.close()
    except IOError as err:
        sys.stdout.write("I/O error: %s\r?\n" % str(err))
        sys.exit(1)
    prog = re.compile(
        "#define[ \t][ \t]*([A-Z0-9][A-Z0-9_]*)[ \t][ \t]*([0-9][0-9]*)",
        re.IGNORECASE)
    tokens = {}
    for line in lines:
        match = prog.match(line)
        if match:
            name, val = match.group(1, 2)
            val = int(val)
            tokens[val] = name  # reverse so we can sort them...
    keys = sorted(tokens.keys())
    # load the output skeleton from the target:
    try:
        fp = open(outFileName)
        format = fp.read().split("\n")
        fp.close()
    except IOError as err:
        sys.stderr.write("I/O error: %s\n" % str(err))
        sys.exit(2)
    try:
        start = format.index("#--start constants--") + 1
        end = format.index("#--end constants--")
    except ValueError:
        sys.stderr.write("target does not contain format markers")
        sys.exit(3)
    lines = []
    for val in keys:
        lines.append("%s = %d" % (tokens[val], val))
    format[start:end] = lines
    try:
        fp = open(outFileName, 'w')
    except IOError as err:
        sys.stderr.write("I/O error: %s\n" % str(err))
        sys.exit(4)
    fp.write("\n".join(format))
    fp.close()


if __name__ == "__main__":
    main()
