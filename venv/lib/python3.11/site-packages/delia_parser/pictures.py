
"""
FIXME: this is broken.
DONT TOUCH picture string in __init__() and check() .

Note that creating Invalid pictures is a feature, not a bug.
Picture Constructors should not raise exception if picture is invalid.
It must be possible to check picture validity.

To summarize:

* Loading a schema where some extracted pictures are invalid must be
possible (repaired).

* All useful picture information should be available as documented attributes after
a call to validate()

See: tests/testpictures.py
__class__

"""

import re
from delia_commons.exceptions import InvalidPictureError
from delia_commons.singleton import Singleton
from collections import OrderedDict


def parameters_to_str(parameters):
    elements = []
    for param in parameters:
        if isinstance(param, str):
            elements.append(param)
        else:
            elements.append('='.join(param))
    return ", ".join(elements)


class UnknownPicture(Singleton):
    pass


class Picture:

    """ Abstract ADL picture class """

    def __init__(self, basetype, picture):
        self.picture = picture.upper()
        self.normalized = None
        self.basetype = basetype

    def is_valid(self):
        """
        return True if this object represents a valid ADL picture.
        """
        try:
            self.validate()
            return True
        except InvalidPictureError:
            return False

    def validate(self):
        """
        Analyzes string representation of this picture,
        extracting information needed to
        implement normal_form(), format() and parse()

        Returns the picture.

        If this picture is invalid, raises an InvalidPictureError.
        """
        raise InvalidPictureError(self)

    def normal_form(self):
        """
        Return a standardized string representation for this picture,
        usefull for comparing pictures.
        Exact representation is not specified.

        If this picture is invalid returns None
        """
        if self.normalized is None:
            try:
                self.validate()
            except InvalidPictureError:
                pass
        return self.normalized

    def __eq__(self, other):
        """
        Two pictures are considered equal if they are both invalid or
        have the same normal form.
        """
        return self.normal_form() == other.normal_form()

    def __str__(self):
        """
        return a string representation of this picture suitable for inclusion in ADL source code.

        >>> pic = DatePicture('YYYMMDD')
        >>> schema = magnum.get_schema("schema foo begin field a as %s end" % pic)

        should give a valid schema.
        """
        return "'%s'" % self.picture

    def __repr__(self):
        return '<' + self.__class__.__name__ + ' ' + str(self) + '>'


class StringPicture(Picture):

    pattern_repeat_c = re.compile("^(C+)$", re.I)
    pattern_number_c = re.compile("^([0-9]+C)$", re.I)

    def __init__(self, picture):
        # Drop the spaces in the picture
        Picture.__init__(self, 'string', picture)
        self.size = None

    def validate(self):
        if self.size is not None:  # already checked
            return

        # For empty cotted string.
        if self.picture.upper() == '0C':
            self.normalized = '0C'
            self.size = 0
            return self

        if self.pattern_repeat_c.search(self.picture):
            self.normalized = self.picture.upper()

        elif self.pattern_number_c.search(self.picture):
            count = int(self.picture.upper().replace("C", ""))
            if count == 0:
                raise InvalidPictureError(303, "zero prefix character count not allowed in picture")
            self.normalized = "C" * count

        else:
            raise InvalidPictureError(303, "This string picture contains an illegal character")

        self.size = len(self.normalized)

        return self

    def to_parameters(self):
        self.validate()
        return parameters_to_str()

    def __str__(self):
        return "'%s'" % self.picture

    def get_largest(self):
        return repr(chr(0xFF) * self.size)

    def get_smallest(self):
        return repr(chr(0x00))


class DatePicture(Picture):

    formats = {
        # adl picture : strftime format
        'YYYY': '%Y',
        'YYYB': '%Y',
        'YY': '%y',
        'YB': '%y',
        'MMM': '%b',
        'MMB': '%b',
        'MM': '%m',
        'MB': '%m',
        'ZM': '%_m',
        'M': '%B',
        'DDD': '%j',
        'DDB': '%j',
        'ZZD': '%_j',
        'DD': '%d',
        'DB': '%d',
        'ZD': '%_d',
        'WWW': '%a',
        'WWB': '%a',
        'W': '%A',
        ' ': ' ',
        '-': '-',
        ',': ',',
        '/': '/',
        '.': '.',
        'YYY': None,
        'YYB': None,
        'Y': None,
        'D': None,
    }

    # Order by name
    formats_order = OrderedDict(sorted(formats.items(), key=lambda t: t[0]))
    # Order by length
    formats_order = OrderedDict(sorted(formats_order.items(), key=lambda t: -len(t[0])))

    valid_pattern = "|".join(["(%s)" % fmt for fmt in formats_order])

    invalid_pattern = re.compile("(Y){5}|(M){4}|(D){4}|(W){4}")

    def __init__(self, picture):
        Picture.__init__(self, 'date', picture)
        self._strftime_format = None
        self.size = None

    def validate(self):
        if self.size is not None:  # already checked
            return

        if re.findall(self.invalid_pattern, self.picture):
            raise InvalidPictureError(455, "This date picture contains an illegal character")

        # Pattern must be ordered to work
        found = re.findall(self.valid_pattern, self.picture)

        # Please don't touch...
        py_picture = []

        for res in found:
            key_found = "".join(res)
            try:
                if self.formats_order[key_found] is not None:
                    py_picture.append(self.formats_order[key_found])
                else:
                    raise InvalidPictureError(666, "'{}' is an unsupported date picture".format(key_found))
            except KeyError:
                raise InvalidPictureError(455, "This date picture contains an illegal character")

        self._strftime_format = "".join(py_picture)

        self.size = len(self.picture)

        return self

    def normal_form(self, ignore_ws=False):
        self.validate()
        fmt_date = self._strftime_format
        if ignore_ws:
            fmt_date = fmt_date.replace('%_d', '%d')
            fmt_date = fmt_date.replace('%_m', '%m')
            fmt_date = fmt_date.replace('%_j', '%j')
            return fmt_date
        else:
            return fmt_date

    def empty_is_default(self):
        if 'B' in self.picture:
            return True
        return False

    def is_size_variable(self):
        self.validate()
        if '%A' in self._strftime_format or '%B'in self._strftime_format:
            return True
        return False

    def to_parameters(self, ignore_ws=False):
        self.validate()
        if self.empty_is_default():
            return '"{}", empty_is_default=True'.format(self.normal_form(ignore_ws))
        else:
            return '"{}"'.format(self.normal_form(ignore_ws))

    def __str__(self):
        return "date '%s'" % self.picture


class NumericPicture(Picture):

    def __init__(self, basetype, picture):
        # Call the super constructor
        Picture.__init__(self, basetype, picture)
        self.size = None
        self.parameters = None

    def validate(self):
        self._check()
        self.size = self._get_size()
        return self

    def empty_is_default(self):
        if 'DB' not in self.picture and 'B' in self.picture:
            return True
        return False

    def _check(self):
        # Check if there is an exponential form
        # Drop the spaces in the picture
        self.picture = self.picture.replace(' ', '')

        p = re.compile("^([^E]*)(E?)$")
        m = p.match(self.picture)
        if m:
            (self.picture, exp) = m.groups()
        else:
            raise InvalidPictureError(
                303, "Error with the exponential form " + self.picture)
        # Check if there is a 0 before an element : for example 0N
        if re.search("(^|[^\d])0+", self.picture) is not None:
            raise InvalidPictureError(
                303, "0 can not be before an element of the picture " + self.picture)
        # Check if there isn't more than 1 point.
        p_nbr = self.picture.count(".")
        v_nbr = self.picture.count("V")
        if p_nbr + v_nbr > 1:
            raise InvalidPictureError(
                303, "the picture has more than one point " + self.picture)
        # Check the number of DB (only one allowed)
        if self.picture.count("DB") > 1:
            raise InvalidPictureError(
                303, "only one DB is allowed " + self.picture)
        # Check the number of CR (only one allowed)
        if self.picture.count("CR") > 1:
            raise InvalidPictureError(
                303, "only one CR is allowed " + self.picture)
        # Check if DB or nDB with n >= 2
        p = re.compile("(\d*)DB")  # The pattern
        # Find all the matching string in the picture
        iterator = p.finditer(self.picture)
        for match in iterator:  # Iter on all the matches
            group = match.groups()
            if group[0] != '':  # There is an integer before the element
                if int(group[0]) < 2:
                    raise InvalidPictureError(
                        303, "DB must be stand alone or with an integer >= 2 just before " + self.picture)
        # Check if CR or nCR with n >= 2
        p = re.compile("(\d*)CR")  # The pattern
        # Find all the matching string in the picture
        iterator = p.finditer(self.picture)
        for match in iterator:  # Iter on all the matches
            group = match.groups()  # There is an integer before the element
            if group[0] != '':
                if int(group[0]) < 2:
                    raise InvalidPictureError(
                        303, "CR must be stand alone or with an integer >= 2 just before " + self.picture)
        # Check the separators
        self.__check_separator()
        # Check the components of the picture
        self.__check_components()
        # Check the following elements
        self.__check_follow()
        # Check the signs
        self.__check_sign()
        # If there is an exponential form, add it
        if exp != '':
            self.picture += 'E'

    def _get_point(self):
        '''
        Return the point : '.', 'V', or '' if there is no separator at all
        '''
        if self.picture.count(".") > 0:
            return "."
        elif self.picture.count("V") > 0:
            return "V"
        else:
            return ''

    def _split(self):
        '''
        Split the integer and the decimal part.
        Return a tuple.
        The first element contains the integer part.
        The second element contains the decimal part.
        '''
        l = self.picture.replace('V', '.', 1).split('.')
        if len(l) == 1:
            l.append('')
        return l

    def __check_separator(self):
        '''
        Check the separator of the picture
        '''
        self.__check_thousand_separator()
        self.__check_decimal_separator()

    def __check_thousand_separator(self):
        '''
        Check the separators of the integer part
        '''
        (integer, decimal) = self._split()
        # Check if there is a separator
        if re.search("\, ", integer) is not None:
            # Expand the integer part
            t_pic = self._expand_integer()
            # Check if there is no separator between a number and his letter (3, N for example)
            if re.search("\d+\, [\$\+\-ZL\*NB]", t_pic) is not None:
                raise InvalidPictureError(
                    303, "there is a separator between a number and his letter " + self.picture)
            # Check if there is no sepaartor at the very beginning of the picture
            if re.search("^(\, |\+\, |\-\, |\$\, |\(\, |\$\+\, |\$\-\, |\-\$\, |\+\$\, |\(\$\, )", t_pic) is not None:
                raise InvalidPictureError(
                    303, "a separator is not at its right place at the very beginning of the string " + self.picture)
            # Delete the first non numeric elements
            if re.search("^\+([^\$]|$)", t_pic) is not None:
                t_pic = t_pic.replace('+', '', 1)
            elif re.search("^\-([^\$]|$)", t_pic) is not None:
                t_pic = t_pic.replace('-', '', 1)
            elif re.search("^\$([^\+^\-]|$)", t_pic) is not None:
                t_pic = t_pic.replace('$', '', 1)
            elif re.search("^\(([^\$]|$)", t_pic) is not None:
                t_pic = t_pic.replace('(', '', 1)
            elif re.search("^\$\+", t_pic) is not None:
                t_pic = t_pic.replace("$+", '', 1)
            elif re.search("^\$\-", t_pic) is not None:
                t_pic = t_pic.replace("$-", '', 1)
            elif re.search("^\-\$", t_pic) is not None:
                t_pic = t_pic.replace("-$", '', 1)
            elif re.search("^\+\$", t_pic) is not None:
                t_pic = t_pic.replace("+$", '', 1)
            elif re.search("^\(\$", t_pic) is not None:
                t_pic = t_pic.replace("($", '', 1)
            # If there is no decimal part, drop the final +, -, ), CR or DB
            if decimal == '':
                p = re.compile("^[^+^-]+(DD$|CC$|\+|\-|\))")
                iterator = p.finditer(self.picture)
                for match in iterator:
                    group = match.groups()
                    t_pic.replace(group[0], '')
            # Check if there is an separator every 3 digits
            # At least "X, XXX" -> 5 char
            if len(t_pic) < 5:
                raise InvalidPictureError(
                    303, "a separator is not at its right place " + self.picture)
            elif re.search("^[\$\+\-ZL\*NB]{1, 3}(\, [\$\+\-ZL\*NB]{3})*$", t_pic) is None:
                raise InvalidPictureError(
                    303, "a separator is not at its right place " + self.picture)

    def __check_decimal_separator(self):
        '''
        Check that there is no separator in the decimal part
        '''
        # Check if there is a separator
        if re.search("\, ", self._split()[1]) is not None:
            raise InvalidPictureError(
                303, "a separator can't be in the decimal part of the picture " + self.picture)
        return 0

    def _expand_integer(self):
        '''
        Expand the integer part of a picture.
        For example, 3N -> NNN
        Return the expanded integer part
        '''
        # Get the integer part
        (t_pic, d_pic) = self._split()
        # The pattern
        p = re.compile("(\d*)([\$\+\-ZL\*NB])")
        # Find all the matching string in the picture
        iterator = p.finditer(t_pic)
        # Iter on all the matches
        for match in iterator:
            group = match.groups()
            # There is an integer before the element
            if group[0] != '':
                nbr = int(group[0])
                t_pic = t_pic.replace(group[0] + group[1], nbr * group[1])
        # If there is no decimal part
        if d_pic == '':
            p = re.compile("(\d*)(CR|DB)")
            # Find all the matching string in the picture
            iterator = p.finditer(t_pic)
            # Iter on all the matches
            for match in iterator:
                group = match.groups()
                # There is an integer before the element
                if group[0] != '':
                    nbr = int(group[0])
                    if group[1] == "DB":
                        t_pic = t_pic.replace(group[0] + group[1], nbr * 'D')
                    if group[1] == "CR":
                        t_pic = t_pic.replace(group[0] + group[1], nbr * 'C')
                else:
                    if group[1] == "DB":
                        t_pic = t_pic.replace("DB", "DD")
                    if group[1] == "CR":
                        t_pic = t_pic.replace("CR", "CC")
        return t_pic

    def _expand_decimal(self):
        '''
        Expand the decimal part of a picture.
        For example, 3N -> NNN
        Be careful, it replace CR by CC and DB by DB, much more convenient to process
        For example, 3CR becomes CCC and 4 DB becomes DDDD
        Return the expanded integer part
        '''
        # Get the decimal part
        t_pic = self._split()[1]
        # The pattern
        p = re.compile("(\d*)([\+\-ZLNB])")
        # Find all the matching string in the picture
        iterator = p.finditer(t_pic)
        # Iter on all the matches
        for match in iterator:
            group = match.groups()
            # There is an integer before the element
            if group[0] != '':
                nbr = int(group[0])
                t_pic = t_pic.replace(group[0] + group[1], nbr * group[1])
        p = re.compile("(\d*)(CR|DB)")
        # Find all the matching string in the picture
        iterator = p.finditer(t_pic)
        # Iter on all the matches
        for match in iterator:
            group = match.groups()
            # There is an integer before the element
            if group[0] != '':
                nbr = int(group[0])
                if group[1] == "DB":
                    t_pic = t_pic.replace(group[0] + group[1], nbr * 'D')
                if group[1] == "CR":
                    t_pic = t_pic.replace(group[0] + group[1], nbr * 'C')
            else:
                if group[1] == "DB":
                    t_pic = t_pic.replace("DB", "DD")
                if group[1] == "CR":
                    t_pic = t_pic.replace("CR", "CC")
        return t_pic

    def __check_components(self):
        '''
        Check the components of the picture
        '''
        self.__check_integer_components()
        self.__check_decimal_components()

    def __check_integer_components(self):
        '''
        Check that there are no 'strange' letters in the integer part of the picture
        '''
        (integer, decimal) = self._split()
        if decimal != '':
            if re.search("[^\d^\$^\+^\-^\(^Z^L^\*^N^B^\, ]", integer) is not None:
                raise InvalidPictureError(
                    303, "there is some strange letters in the integer part of the picture " + self.picture)
        else:
            # Check that there is no R without CR, C without CR and D without
            # DB
            if re.search("(C([^R]|$)|D([^B]|$)|([^C]|^)R)", integer) is not None:
                raise InvalidPictureError(
                    303, "there is a mistake with CR or DB in the picture " + self.picture)
            # Check that there is no strange letters
            # and self.picture is None:
            if re.search("[^\d^\$^\+^\-^\(^Z^L^\*^N^B^\, ^C^R^D^B^\)]", integer) is not None:
                raise InvalidPictureError(
                    303, "there is some strange letters in the integer part of the picture " + self.picture)

    def __check_decimal_components(self):
        '''
        Check that there are no 'strange' letters in the decimal part of the picture
        '''
        # Check that there is no R without CR, C without CR and D without DB
        if re.search("(C([^R]|$)|D([^B]|$)|([^C]|^)R)", self._split()[1]) is not None:
            raise InvalidPictureError(
                303, "there is a mistake with CR or DB in the picture " + self.picture)
        # Check that there is no strange letters
        if re.search("[^\d^\+^\-^\)^Z^L^N^B^C^R^D^B]", self._split()[1]) is not None:
            raise InvalidPictureError(
                303, "there is some strange letters in the decimal part of the picture " + self.picture)

    def __check_follow(self):
        '''
        Check the folowing elements
        '''
        self.__check_integer_follow()
        self.__check_decimal_follow()

    def __check_integer_follow(self):
        '''
        Check the leading signs of the integer part of the picture
        '''
        # Expand the picture (3N->NNN)
        t_pic = self._expand_integer()
        # Drop the separators
        t_pic = t_pic.replace(', ', '')
        # Beginning of the picture
        if re.search("^\+([^\$]|$)", t_pic) is not None:
            n_pic = t_pic.replace('+', '', 1)
            self.__check_leading_digits(n_pic, ['[ZL]', '\*', '\+'])
        elif re.search("^\-([^\$]|$)", t_pic) is not None:
            n_pic = t_pic.replace('-', '', 1)
            self.__check_leading_digits(n_pic, ['[ZL]', '\*', '\-'])
        elif re.search("^\$([^\+^\-]|$)", t_pic) is not None:
            n_pic = t_pic.replace('$', '', 1)
            self.__check_leading_digits(n_pic, ['[ZL]', '\*', '\$'])
        elif re.search("^\(([^\$]|$)", t_pic) is not None:
            n_pic = t_pic.replace('(', '', 1)
            self.__check_leading_digits(n_pic, ['[ZL]', '\*'])
        elif re.search("^\$\+", t_pic) is not None:
            n_pic = t_pic.replace("$+", '', 1)
            self.__check_leading_digits(n_pic, ['[ZL]', '\*', '\+'])
        elif re.search("^\$\-", t_pic) is not None:
            n_pic = t_pic.replace("$-", '', 1)
            self.__check_leading_digits(n_pic, ['[ZL]', '\*', '\-'])
        elif re.search("^\-\$", t_pic) is not None:
            n_pic = t_pic.replace("-$", '', 1)
            self.__check_leading_digits(n_pic, ['[ZL]', '\*', '\$'])
        elif re.search("^\+\$", t_pic) is not None:
            n_pic = t_pic.replace("+$", '', 1)
            self.__check_leading_digits(n_pic, ['[ZL]', '\*', '\$'])
        elif re.search("^\(\$", t_pic) is not None:
            n_pic = t_pic.replace("($", '', 1)
            self.__check_leading_digits(n_pic, ['[ZL]', '\*', '\$'])
        else:
            self.__check_leading_digits(
                t_pic, ['[ZL]', '\*', '\$', '\+', '\-'])

    def __check_decimal_follow(self):
        '''
        Check the leading signs of the integer part of the picture
        '''
        # Expand the picture (3N->NNN)
        t_pic = self._expand_decimal()
        # Reverse the string, much more easy to process
        r_pic = ''
        for c in t_pic:
            r_pic = c + r_pic
        # Beginning of the picture
        if re.search("^\+", r_pic) is not None:
            n_pic = r_pic.replace('+', '', 1)
            self.__check_leading_digits(n_pic, ['[ZL]', '\+'])
        elif re.search("^\-", r_pic) is not None:
            n_pic = r_pic.replace('-', '', 1)
            self.__check_leading_digits(n_pic, ['[ZL]', '\-'])
        elif re.search("^CC", r_pic) is not None:
            n_pic = r_pic.replace('CC', '', 1)
            self.__check_leading_digits(n_pic, ['[ZL]', 'C'])
        elif re.search("^DD", r_pic) is not None:
            n_pic = r_pic.replace('DD', '', 1)
            self.__check_leading_digits(n_pic, ['[ZL]', 'D'])
        elif re.search("^\)", r_pic) is not None:
            n_pic = r_pic.replace(')', '', 1)
            self.__check_leading_digits(n_pic, ['[ZL]'])
        else:
            self.__check_leading_digits(r_pic, ['[ZL]', 'C', 'D', '\+', '\-'])

    def __check_leading_digits(self, pic, values):
        '''
        Check the leading digits of the integer part
        '''
        # If a digit is found
        found = False
        # For each char in the list
        for case in values:
            p = re.compile("^(" + case + "+)")
            m = p.search(pic)
            if m is not None:
                found = True
                t_pic = pic.replace(m.group(), '', 1)
                self.__check_digits(t_pic)
                break

        if found is False:
            self.__check_digits(pic)

    def __check_digits(self, pic):
        '''
        Check the digits of the integer part
        '''

        p = re.compile("^([NB]*)")
        m = p.search(pic)
        if m is not None:
            pic = pic.replace(m.group(), '', 1)
        # If there is no decimal part
        if self._split()[1] == '':
            p = re.compile("^(CC|DD|\+|\-|\))")
            m = p.search(pic)
            if m is not None:
                pic = pic.replace(m.group(), '', 1)
#        if len(pic) != 0:
#            raise InvalidPictureError, "error in your picture " + self.picture

    def __check_sign(self):
        '''Check the sign of the integer part and the decimal part
        + in integer and - in decimal is not possible for example
        '''
        (integer, decimal) = self._split()
        if decimal != '':
            if re.search("\(", integer) is not None:
                if re.search("\)", decimal) is None:
                    raise InvalidPictureError(
                        303, "you must have a couple of parenthesis " + self.picture)
                if re.search("[\+\-]", decimal) is not None:
                    raise InvalidPictureError(
                        303, "the sign in the decimal part is forbidden " + self.picture)
            elif re.search("\)", decimal) is not None:
                raise InvalidPictureError(
                    303, "you must have a couple of parenthesis " + self.picture)
            if re.search("[\+\-]", decimal) is not None:
                if re.search("[\+\-]", integer) is not None:
                    raise InvalidPictureError(
                        303, "sign error " + self.picture)
        else:
            if re.search("\(", integer) is not None:
                if re.search("\)", integer) is None:
                    raise InvalidPictureError(
                        303, "you must have a couple of parenthesis " + self.picture)
                if re.search("[\+\-]", integer) is not None:
                    raise InvalidPictureError(
                        303, "the sign in the decimal part is forbidden " + self.picture)
            if re.search("^(\+\.*\-|\-\.*\+|\+[^+]+\+|\-[^-]+\-)$", integer) is not None:
                raise InvalidPictureError(
                    303, "sign issue in the picture " + self.picture)

    def _count_digit(self):
        '''
        Count the number of digits of the picture
        Return a tuple.
        The first element is the number of digits
        The second element is the number of digits in the decimal part
        '''
        # Expand the integer part
        e_integer = self._expand_integer()
        # Count the intersting digits of the integer part
        i_nbr = e_integer.count('Z')                  \
            + e_integer.count('L')              \
            + e_integer.count('*')              \
            + max(0, e_integer.count('$') - 1)    \
            + max(0, e_integer.count('+') - 1)    \
            + max(0, e_integer.count('-') - 1)    \
            + e_integer.count('N')              \
            + e_integer.count('B')
        # Expand the decimal part
        e_decimal = self._expand_decimal()
        # Count the intersting digits of the decimal part
        d_nbr = e_decimal.count('Z')                  \
            + e_decimal.count('L')              \
            + max(0, e_decimal.count('C') - 2)    \
            + max(0, e_decimal.count('D') - 2)    \
            + max(0, e_decimal.count('+') - 1)    \
            + max(0, e_decimal.count('-') - 1)    \
            + e_decimal.count('N')              \
            + e_decimal.count('B')
        # Return
        return (i_nbr + d_nbr, d_nbr)

    def get_digits(self):
        (total, decimal) = self._count_digit()
        return (total, decimal)

    def get_largest(self):
        total_ndigits, dec_ndigits = self._count_digit()
        int_ndigits = total_ndigits - dec_ndigits
        if dec_ndigits:
            return '.'.join(('9'*int_ndigits, '9'*dec_ndigits))
        return '9'*int_ndigits

    def get_smallest(self):
        if self._get_sign() > 0:
            return '0'
        total_ndigits, dec_ndigits = self._count_digit()
        int_ndigits = total_ndigits - dec_ndigits
        if dec_ndigits:
            return '-' + '.'.join(('9'*int_ndigits, '9'*dec_ndigits))
        return '-' + '9'*int_ndigits

    def _get_size(self):
        '''
        Count max size of the picture
        Return a size.
        '''
        size = 0
        # Expand the integer part
        e_integer = self._expand_integer()
        # Count the intersting digits of the integer part
        i_nbr = e_integer.count('Z')                  \
            + e_integer.count('L')              \
            + e_integer.count('*')              \
            + max(0, e_integer.count('C'))    \
            + max(0, e_integer.count('D'))    \
            + max(0, e_integer.count('$'))    \
            + max(0, e_integer.count('+'))    \
            + max(0, e_integer.count('-'))    \
            + max(0, e_integer.count('('))    \
            + max(0, e_integer.count(')'))    \
            + e_integer.count('N')              \
            + e_integer.count('B')              \
            + e_integer.count(',')
        # Expand the decimal part
        e_decimal = self._expand_decimal()
        # Count the digits specifiers of the decimal part
        d_nbr = e_decimal.count('Z')                  \
            + e_decimal.count('L')              \
            + max(0, e_decimal.count('C'))    \
            + max(0, e_decimal.count('D'))    \
            + max(0, e_decimal.count('+'))    \
            + max(0, e_decimal.count('-'))    \
            + max(0, e_decimal.count(')'))    \
            + e_decimal.count('N')              \
            + e_decimal.count('B')
        if len(self.picture.replace('V', '.', 1).split('.')) == 1:
            size = i_nbr + d_nbr
        else:
            size = i_nbr + d_nbr + 1
        # Return
        return size

    def _get_sign(self):
        '''Get the sign of the picture'''
        if re.search("(CR|DB|\+|\-|\(|\))", self.picture) is not None:
            return -1
        else:
            return 1

    def normal_form(self):
        '''
        Return the normal form of the picture and additional format arguments
        '''
        return ''.join(self._get_pic_elements())

    def to_parameters(self):

        if self.parameters:
            return self.parameters

        s_int_prefix, s_int_digits, s_int_postfix, s_point, s_dec_digits, s_dec_postfix = self._get_pic_elements()
        s_int = s_int_prefix + s_int_digits + s_int_postfix
        s_dec = s_dec_digits + s_dec_postfix
        parameters = []

        # Initialization
        sign_before_leading_spaces = ''
        leading_spaces = 0
        sign_after_leading_spaces = ''
        stars = 0
        leading_zeros = 0
        thousand_sep_count = 0
        trailing_zeros = 0
        sign_before_trailing_spaces = ''
        trailing_spaces = 0
        sign_after_trailing_spaces = ''
        free_integer = 0

        supported_sign_before_leading_spaces = ('', '+', '-')
        supported_sign_after_leading_spaces = ('', '+', '-', '(')
        supported_sign_before_trailing_spaces = ('', '+', '-', ')', 'CR', 'DB')
        supported_sign_after_trailing_spaces = ('', '+', '-', ')', 'CR', 'DB')

        position_int = (('sign_before_leading_spaces', supported_sign_before_leading_spaces),
                        ('spaces', ('Z', )),
                        ('sign_after_leading_spaces', supported_sign_after_leading_spaces),
                        ('remains', ('*', 'N', ',', 'Z', '-', '+', 'B', 'L', 'CR', 'DB', ')')),
                        )

        position_dec = (('trailing_zeros', ('N', 'B')),
                        ('sign_before_trailing_spaces', supported_sign_before_trailing_spaces),
                        ('trailing_spaces', ('Z', )),
                        ('sign_after_trailing_spaces', supported_sign_after_trailing_spaces),
                        ('remains', ('L', )))

        position = 0
        sign_count = 0
        is_last_digit = False

        for pos, digit in enumerate(s_int):

            if pos == len(s_int) - 1:
                is_last_digit = True

            while 1:
                if position > len(position_int) - 1:
                    raise InvalidPictureError(
                        303, f"'{digit}' at position {pos+1} is not allowed in the picture '{self.picture}'")

                descr, values = position_int[position]

                if digit == 'C':
                    digit = 'CR'
                elif digit == 'D':
                    digit = 'DB'

                if digit not in values:
                    position += 1
                else:

                    if descr == 'sign_before_leading_spaces':

                        sign_before_leading_spaces = digit

                        if digit in ('-', '+'):
                            if sign_count > 0:
                                leading_spaces += 1
                                sign_after_leading_spaces = sign_before_leading_spaces
                                sign_before_leading_spaces = ''
                            sign_count += 1

                    elif descr == 'spaces':
                        leading_spaces += 1

                    elif descr == 'sign_after_leading_spaces':

                        sign_after_leading_spaces = digit

                        if digit in ('-', '+'):
                            if sign_count > 0:
                                leading_spaces += 1
                            sign_count += 1

                    else:
                        if digit == '*':
                            stars += 1
                        elif digit in ('N', 'B'):
                            leading_zeros += 1
                        elif digit == 'Z':
                            leading_spaces += 1
                        elif digit in ('-', '+'):
                            if sign_count > 0:
                                leading_spaces += 1
                            else:
                                if is_last_digit:
                                    sign_after_trailing_spaces = digit
                                else:
                                    sign_after_leading_spaces = digit
                            sign_count += 1
                        elif digit in ('CR', 'DB', ')'):
                            sign_after_trailing_spaces = digit
                        elif digit == ',':
                            thousand_sep_count += 1
                            leading_spaces += 1
                        elif digit == 'L':
                            free_integer += 1
                    break

        position = 0
        is_last_digit = False

        for pos, digit in enumerate(s_dec):

            if pos == len(s_dec) - 1:
                is_last_digit = True

            while 1:
                if position > len(position_dec) - 1:
                    raise InvalidPictureError(
                        303, f"'{digit}' at position {len(s_int) + pos + 2} is not allowed in the picture '{self.picture}'")

                descr, values = position_dec[position]

                if digit == 'C':
                    digit = 'CR'
                elif digit == 'D':
                    digit = 'DB'

                if digit not in values:
                    position += 1
                else:

                    if descr == 'trailing_zeros':
                        trailing_zeros += 1
                    elif descr == 'sign_before_trailing_spaces':
                        if digit in ('-', '+'):
                            if sign_count > 0:
                                trailing_spaces += 1
                            else:
                                sign_before_trailing_spaces = digit
                            sign_count += 1
                        elif digit in ('CR', 'DB'):
                            if sign_count > 1:
                                trailing_spaces += 1
                                sign_before_trailing_spaces = digit
                                sign_after_trailing_spaces = ''
                            else:
                                if not is_last_digit:
                                    sign_before_trailing_spaces = digit
                                else:
                                    sign_before_trailing_spaces = ''
                                    sign_after_trailing_spaces = digit
                            sign_count += 1
                        elif digit == ')':
                            if not is_last_digit:
                                sign_before_trailing_spaces = digit
                            else:
                                sign_before_trailing_spaces = ''
                                sign_after_trailing_spaces = digit
                    elif descr == 'trailing_spaces':
                        trailing_spaces += 1
                    elif descr == 'sign_after_trailing_spaces':
                        sign_after_trailing_spaces = digit
                    else:
                        if digit == 'L':
                            trailing_spaces += 1
                            free_integer += leading_spaces
                            leading_spaces = 0
                    break

        if "".join(set(self.picture)) == 'L':
            leading_zeros = 1

        # If there is no leading_zeros in the picture, then automatically
        # add one. Examples:
        # "ZZZZZZZ" becomes "ZZZZZZN"
        # "ZZZZZZB" does not change
        if (leading_zeros == 0 and
                stars == 0 and
                leading_zeros == 0 and
                trailing_zeros == 0):
            if leading_spaces > 0:
                leading_spaces -= 1
                leading_zeros = 1

        # If there is no leading_zeros in the picture containing stars, then automatically
        # add one. Examples:
        # "*" becomes "N"
        # "**" becomes "*N"
        # "***.N" does not change
        if (leading_zeros == 0 and
                stars > 0 and
                trailing_zeros == 0):
            stars -= 1
            leading_zeros = 1

        # If there is no trailing_zeros in the picture, then automatically
        # add one. Examples:
        # "ZZZZ.2N" becomes "ZZZN.2N"
        # "ZZZZ.ZZ" becomes "ZZZN.ZZ"
        # ".ZZZZZZ" becomes ".NZZZZZ"
        if (leading_zeros == 0 and
                leading_spaces == 0 and
                stars == 0 and
                trailing_zeros == 0):
            if trailing_spaces > 0:
                trailing_spaces -= 1
                trailing_zeros = 1

        # Build parameters list
        if 'B' in s_int + s_dec:
            parameters.append(
                ("blanks_if_zero", repr(len(s_int + s_point + s_dec))))

        if s_point == 'V':
            parameters.append(("decimal_sep", repr('')), )

        if stars > 0:
            parameters.append(("stars", repr(stars)))

        if leading_zeros > 0:
            parameters.append(("leading_zeros", repr(leading_zeros)))

        if leading_spaces > 0:
            parameters.append(("leading_spaces", repr(leading_spaces)))

        if sign_before_leading_spaces:
            parameters.append(
                ("sign_before_leading_spaces", repr(sign_before_leading_spaces)))

        if sign_after_leading_spaces:
            parameters.append(
                ("sign_after_leading_spaces", repr(sign_after_leading_spaces)))

        if thousand_sep_count > 0:
            parameters.append(("thousand_sep_count", repr(thousand_sep_count)))

        if trailing_zeros > 0:
            parameters.append(("trailing_zeros", repr(trailing_zeros)))

        if trailing_spaces > 0:
            parameters.append(("trailing_spaces", repr(trailing_spaces)))

        if sign_before_trailing_spaces:
            parameters.append(
                ("sign_before_trailing_spaces", repr(sign_before_trailing_spaces)))

        if sign_after_trailing_spaces:
            parameters.append(
                ("sign_after_trailing_spaces", repr(sign_after_trailing_spaces)))

        if free_integer > 0:
            parameters.append(("free_integer", repr(free_integer)))

        self.parameters = parameters_to_str(parameters)
        return self.parameters


class DecimalPicture(NumericPicture):

    def __init__(self, picture):
        # Call the super constructor
        NumericPicture.__init__(self, 'decimal', picture)

    def _check(self):
        NumericPicture._check(self)
        if self.picture == '':
            raise InvalidPictureError(
                303, "this picture can't be empty " + self.picture)
        # Check there's no E
        if re.search("E", self.picture):
            raise InvalidPictureError(
                303, "E is not allowed in the picture " + self.picture)
        # Check the number of digits
        self.__check_size()

    def __check_size(self):
        '''
        Check if the number of digits is less than 20
        '''
        # Get the number of digits
        (total_nbr, d_nbr) = self._count_digit()
#        if total_nbr > 20:
#            raise InvalidPictureError, "too many digits " + self.picture
        if total_nbr < 1:
            raise InvalidPictureError(
                303, "not enought digits " + self.picture)

    def _get_pic_elements(self):
        '''
        Get the prefix of the picture
        '''
        # Get the integer and the decimal part
        s_integer = self._expand_integer()
        s_decimal = self._expand_decimal()
        # Init
        s_int_prefix = ''
        s_int_digits = ''
        s_int_postfix = ''
        s_dec_digits = ''
        s_dec_postfix = ''
        s_point = self._get_point()
        # Look for the prefix
        if re.search("^\+([^\$]|$)", s_integer) is not None:
            s_int_prefix = '+'
        elif re.search("^\-([^\$]|$)", s_integer) is not None:
            s_int_prefix = '-'
        elif re.search("^\$([^\+^\-]|$)", s_integer) is not None:
            s_int_prefix = '$'
        elif re.search("^\(([^\$]|$)", s_integer) is not None:
            s_int_prefix = '('
        elif re.search("^\$\+", s_integer) is not None:
            s_int_prefix = '$+'
        elif re.search("^\$\-", s_integer) is not None:
            s_int_prefix = '$-'
        elif re.search("^\-\$", s_integer) is not None:
            s_int_prefix = '-$'
        elif re.search("^\+\$", s_integer) is not None:
            s_int_prefix = '+$'
        elif re.search("^\(\$", s_integer) is not None:
            s_int_prefix = '($'
        else:
            s_int_prefix = ''
        s_int_digits = s_integer[len(s_int_prefix):]
        # If there is no decimal part
        if s_decimal == '':
            if re.search("\)$", s_int_digits) is not None:
                s_int_postfix = ')'
            elif re.search("CC$", s_int_digits) is not None:
                s_int_postfix = 'CC'
            elif re.search("DD$", s_int_digits) is not None:
                s_int_postfix = 'DD'
            elif re.search("\+$", s_int_digits) is not None and re.search("^(\+|\$\+)+\++$", s_int_prefix + s_int_digits) is None:
                s_int_postfix = '+'
            elif re.search("\-$", s_int_digits) is not None and re.search("^(\-|\$\-)+\-+$", s_int_prefix + s_int_digits) is None:
                s_int_postfix = '-'
            s_int_digits = s_int_digits[
                0:len(s_int_digits) - len(s_int_postfix)]
        else:
            # Get the postfix and the decimal part without the postfix
            p = re.compile("(CC|DD|\+|\-|\))$")
            m = p.search(s_decimal)
            if m is not None:
                s_dec_postfix = m.group()
                s_dec_digits = s_decimal[0:len(s_decimal) - len(s_dec_postfix)]
            else:
                s_dec_postfix = ''
                s_dec_digits = s_decimal
        return (s_int_prefix, s_int_digits, s_int_postfix, s_point, s_dec_digits, s_dec_postfix)

    def _check_value_sign(self, value):
        '''
        Check the sign of the value
        '''
        # Get the sign of the value
        if value < 0:
            # Check that the picture can be negativ
            if re.search("(CR|DB|\+|\-|\(|\))", self.picture) is None:
                raise ValueError(
                    "the picture " + self.picture + " can't handle negativ value")
        return 0

    def _check_value_length(self, value):
        '''
        Check the length of the value
        '''
        # Get the number of digits of the picture
        (nbr_total, nbr_decimal) = self._count_digit()
        nbr_integer = nbr_total - nbr_decimal
        # Get a textual representation of the value
        s_value = str(value)
        s_value = s_value.replace('-', '')
        # Split decimal part and integer part
        l = s_value.split('.')
        if len(l) == 1:
            l.append('')
        s_integer_value = l[0]
        s_decimal_value = l[1]
        # Check that value is compatible with the picture
        if len(s_integer_value) > nbr_integer and s_integer_value != '0':
            raise ValueError(
                "too many digits in the integer part of your value " + s_value + " for the picture " + self.picture)
        if len(s_decimal_value) > nbr_decimal:
            raise ValueError(
                "too many digits in the decimal part of your value " + s_value + " for the picture " + self.picture)
        return 0


class IntegerPicture(DecimalPicture):
    pass


class FloatPicture(DecimalPicture):

    def __init__(self, picture):
        # If there is no pictures, set the default one
        if picture == '':
            picture = "-N.5NE"
        # Call the super constructor
        NumericPicture.__init__(self, 'float', picture)

    def _check(self):
        NumericPicture._check(self)
        # Check the number of digits
        self.__check_size()

    def __check_size(self):
        '''
        Check if the number of digits is less than 20
        '''
        # Get the number of digits
        (total_nbr, d_nbr) = self._count_digit()
#        if total_nbr > 7:
#            raise InvalidPictureError, "too many digits " + self.picture
        if total_nbr < 1:
            raise InvalidPictureError(
                303, "not enought digits " + self.picture)

    def get_smallest(self):
        return '-9.9999999E+99'

    def get_largest(self):
        return '9.9999999E+99'


class DoublePicture(DecimalPicture):

    def __init__(self, picture):
        # If there is no pictures, set the default one
        if picture == '':
            picture = "-N.15NE"
        # Call the super constructor
        NumericPicture.__init__(self, 'double', picture)

    def _check(self):
        NumericPicture._check(self)
        # Check the number of digits
        self.__check_size()

    def __check_size(self):
        '''
        Check if the number of digits is less than 20
        '''
        # Get the number of digits
        (total_nbr, d_nbr) = self._count_digit()
#        if total_nbr > 16:
#            raise InvalidPictureError, "too many digits " + self.picture
        if total_nbr < 1:
            raise InvalidPictureError(
                303, "not enought digits " + self.picture)

    def get_smallest(self):
        return '-9.9999999E+99'

    def get_largest(self):
        return '9.9999999E+99'
