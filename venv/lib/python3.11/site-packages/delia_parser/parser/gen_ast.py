# -*- coding: utf-8 -*-

import logging
import copy

from delia_commons.exceptions import SyntaxError
from delia_parser.ast import *
from delia_tokenizer import *

logger = logging.getLogger('delia.ast')
BUILTIN_LIST = ['cpu.seconds', 'time', 'today', 'user.name', 'who']


class BisonParser(object):

    """
    Base parser class

    You should subclass this, and provide a bunch of methods called
    on_TargetName', where 'TargetName' is the name of each target in
    your grammar (.y) file.
    """

    def __init__(self, verbose=False):
        method_names = (method_name for method_name in dir(self) if method_name.startswith('ac_'))
        handlers = {method_name[len('ac_'):]: getattr(self, method_name) for method_name in method_names}
        self.handlers = handlers
        self.verbose = verbose
        self.function_list = []
        self.constant_dict = {}

    def _handle(self, compile_ctx, targetname, option, values):
        """
        Callback which receives a target from parser, as a targetname
        and list of term names and values.

        Tries to dispatch to on_TargetName() methods if they exist,
        otherwise wraps the target in a BisonNode object
        """

        try:

            handler = self.handlers[targetname]
            if self.verbose:
                try:
                    hdlrline = handler.__code__.co_firstlineno
                except Exception:
                    hdlrline = handler.__init__.__code__.co_firstlineno
                logger.debug("invoking handler at line %s for %s" % (hdlrline, targetname))

            self.last = handler(compile_ctx=compile_ctx, target=targetname, option=option, values=values)

            if self.verbose:
                logger.debug("handler for %s returned %s" % (targetname, repr(self.last)))

        except KeyError:
            if self.verbose:
                logger.debug("no handler for %s, using default" % targetname)
            self.last = ParseNode(target=targetname, option=option, values=values)

        # assumedly the last thing parsed is at the top of the tree
        return self.last

    def end_token_in_ending_macro(self, macro_infos):
        if isinstance(self.last, Stmts):
            if self.last.macro_infos == macro_infos:
                self.last.in_macro = True


class ParseNode(BaseAST):

    """
    This is the base class from which all your
    parse nodes are derived.
    Add methods to this class as you need them
    """

    def __init__(self, **kw):
        BaseAST.__init__(self, **kw)

    def __str__(self):
        """Customise as needed"""
        return "<%s instance at 0x%x>" % (self.__class__.__name__, hash(self))

    def __repr__(self):
        """Customise as needed"""
        return str(self)


class Parser(BisonParser):

    """
    bison Parser class generated automatically by gengram.py from the
    grammar file

    You may (and probably should) edit the methods in this class.
    You can freely edit the rules (in the method docstrings), the
    tokens list, the start symbol, and the precedences.

    Each time this class is instantiated, a hashing technique in the
    base class detects if you have altered any of the rules. If any
    changes are detected, a new dynamic lib for the parser engine
    will be generated automatically.
    """

    # ---------------------------------------------------------------
    # Declare the start target here (by name)
    # ---------------------------------------------------------------
    start = "goal"

    # ---------------------------------------------------------------
    # These methods are the python handlers for the bison targets.
    # (which get called by the bison code each time the corresponding
    # parse target is unambiguously reached)
    #
    # WARNING - don't touch the method docstrings unless you know what
    # you are doing - they are in bison rule syntax, and are passed
    # verbatim to bison to build the parser engine library.
    # ---------------------------------------------------------------

    def ac_schema(self, compile_ctx, target, option, values):
        """
        schema
            : SCHEMA name BEGIN_TOKEN schema_decl_list END
        """
        assert(option == 0)
        assert(len(values) == 5)
        locations = get_locations(compile_ctx, values[0])
        schema_name = values[1]
        decl_list = Decls(values[3])
        return Schema(schema_name, decl_list, locations=locations)

    def ac_constant_decl(self, compile_ctx, target, option, values):
        """
        constant_decl
            : CONSTANT constant_def_list
        """
        assert(option == 0)
        assert(len(values) == 2)
        return get_list_without_sep(values[1])

    def ac_constant_def(self, compile_ctx, target, option, values):
        """
        constant_def
            : name EQ literal
            | name EQ concatenated_string
            | name EQ boolean_literal
        """
        assert(option in range(3))
        locations = get_locations(compile_ctx, values[1])
        if isinstance(values[0], ConstantRef):
            constant_name = values[0].name
        else:
            constant_name = values[0]
            self.constant_dict[str(constant_name)] = None
        if option == 2:
            literal = create_boolean_node(compile_ctx, values[2])
        else:
            literal = values[2]

        return Constant(constant_name, literal, locations=locations)

    def ac_procedure(self, compile_ctx, target, option, values):
        """
        procedure
            : procedure_signature procedure_body
        """
        signature = values[0]
        body = values[1]
        procedure_name = signature[0]
        receiving_parameter_list = signature[1]
        returning_parameter_list = signature[2]
        decl_list = body[0]
        stmt_list = body[1]
        locations = signature[3]
        return Procedure(name=procedure_name,
                         receiving_parameter_list=receiving_parameter_list,
                         returning_parameter_list=returning_parameter_list,
                         decls=decl_list,
                         stmts=stmt_list,
                         locations=locations)

    def ac_procedure_signature(self, compile_ctx, target, option, values):
        """
        procedure_signature
            : PROCEDURE name procedure_receiving_parameter_list procedure_returning_parameter_list
        """
        assert(option == 0)
        procedure_name = values[1]
        if values[2] is None:
            receiving_parameter_list = []
        else:
            receiving_parameter_list = values[2]
        if values[3] is None:
            returning_parameter_list = []
        else:
            returning_parameter_list = values[3]
        locations = get_locations(compile_ctx, values[0])
        return procedure_name, receiving_parameter_list, returning_parameter_list, locations

    def ac_procedure_receiving_parameter_list(self, compile_ctx, target, option, values):
        """
        procedure_receiving_parameter_list
            : LPAREN formal_parameter_list RPAREN
            |
        """
        assert(option in range(2))
        if option == 0:
            return get_list_without_sep(values[1])
        else:
            return []

    def ac_procedure_returning_parameter_list(self, compile_ctx, target, option, values):
        """
        procedure_returning_parameter_list
            : RETURNING LPAREN formal_parameter_list RPAREN
            |
        """
        assert(option in range(2))
        if option == 0:
            return get_list_without_sep(values[2])
        else:
            return []

    def ac_procedure_body(self, compile_ctx, target, option, values):
        """
        procedure_body
            : no_b_stmt
            | BEGIN_TOKEN decl_list stmt_list END
            | label BEGIN_TOKEN decl_list stmt_list END
        """
        assert(option in range(3))
        if option == 0:
            decl_list = Decls()
            stmt_list = create_stmts_node_from_list(values[0])
        elif option == 1:
            decl_list = Decls(values[1])
            stmt_list = create_stmts_node_from_list(*values[2])
        else:
            decl_list = Decls(values[2])
            stmt_list = create_stmts_node_from_list(LabelStmt(values[0], create_stmts_node_from_list(*values[3])))

        return decl_list, stmt_list,

    def ac_label(self, compile_ctx, target, option, values):
        """
        label
            : name COLON
        """
        return Label(values[0])

    def ac_no_b_stmt(self, compile_ctx, target, option, values):
        """
        no_b_stmt
            : struct_stmt
            | label struct_stmt
            | simple_stmt
        """
        assert(option in range(3))
        if option == 0:
            return values[0]
        elif option == 1:
            return LabelStmt(values[0], create_stmts_node_from_list(values[1]))
        elif option == 2:
            if isinstance(values[0], tuple):
                assert(get_type(*values[0]) in (NOTHING, LOGOUT))
                locations = get_locations(compile_ctx, values[0])
                if get_type(*values[0]) == NOTHING:
                    return Nothing(locations=locations)
                elif get_type(*values[0]) == LOGOUT:
                    return Logout(locations=locations)
            else:
                return values[0]

    def ac_stmt(self, compile_ctx, target, option, values):
        """
        stmt
            : BEGIN_TOKEN stmt_list END
            | label BEGIN_TOKEN stmt_list END
            | no_b_stmt
        """
        assert(option in range(2))
        if option == 0:
            stmt = create_stmts_node_from_list(*values[1])

            if len(values[0]) == 8:  # cparser append macro_infos to begin_token if begin_token is first statement in macro
                stmt.macro_infos = values[0][7]

            return stmt
        elif option == 1:
            return LabelStmt(values[0], create_stmts_node_from_list(*values[2]))
        else:
            return create_stmts_node_from_list(values[0])

    def ac_controls_decl(self, compile_ctx, target, option, values):
        """
        controls_decl
            : CONTROLS FOR all_info
        """
        return values[2]

    def ac_all_info(self, compile_ctx, target, option, values):
        """
        all_info
            : proc_alt proc_con_info_list
            | rel_alt update_info
        """
        if option == 0:
            locations = get_locations(compile_ctx, values[0])
            controls = values[1]
            return ControlsForProcedure(controls, locations=locations)
        elif option == 1: # used in GP
            return ParseNode(
                target="all_info",
                option=option,
                values=values)

    def ac_rel_alt(self, compile_ctx, target, option, values): # used in GP
        """
        rel_alt
            : rel_key
            | rel_key name_list
            | name_list
        """
        return ParseNode(
            target="rel_alt",
            option=option,
            values=values)

    def ac_proc_con_info(self, compile_ctx, target, option, values):
        """
        proc_con_info
            : CHECK SUBSCRIPTS on_off
            | NO ACCEPT TERMINATOR
            | VERIFY ACCEPT INPUT
            | SEPARATOR char_literal
        """
        assert(option in range(4))
        if option == 0:
            if get_type(*values[2]) == ON:
                return ProcedureCheckSubscripts(True)
            else:
                return ProcedureCheckSubscripts(False)
        elif option == 1:
            return ProcedureNoAcceptTerminator()
        elif option == 2:
            return ProcedureVerifyAcceptInput()
        elif option == 3:
            separator = create_char_literal_node(compile_ctx, values[1])
            return ProcedureSeparator(separator)

    def ac_update_info(self, compile_ctx, target, option, values):# used in GP
        """
        update_info
            : CHECKPOINT_ON_UPDATE
            | CONCURRENT UPDATE on_off
        """
        return ParseNode(
            target="update_info",
            option=option,
            values=values)

    def ac_function_decl(self, compile_ctx, target, option, values):
        """
        function_decl
            : function_signature stmt
            | function_signature IN file_spec
        """
        assert(option in range(2))
        function_name, receiving_parameter_list, returning_parameter_list, attributes, locations, = values[0]
        if option == 0:
            stmt_list = create_stmts_node_from_list(values[1])
            return Function(name=function_name,
                            receiving_parameter_list=receiving_parameter_list,
                            returning_parameter_list=returning_parameter_list,
                            attributes=attributes,
                            stmts=stmt_list,
                            locations=locations)
        elif option == 1:
            return FLI(name=function_name,
                       receiving_parameter_list=receiving_parameter_list,
                       returning_parameter_list=returning_parameter_list,
                       attributes=attributes,
                       file_spec=values[2],
                       locations=locations)

    def ac_function_signature(self, compile_ctx, target, option, values):
        """
        function_signature
            : FUNCTION name LPAREN name_list_opt RPAREN RETURNING LPAREN name_list RPAREN field_attributes_opt
            | FUNCTION name LPAREN name_list_opt RPAREN field_attributes_opt
            | FUNCTION name RETURNING LPAREN name_list RPAREN field_attributes_opt
            | FUNCTION name field_attributes_opt
        """
        assert(option in range(4))
        function_name = values[1]
        receiving_parameter_list = []
        returning_parameter_list = []
        locations = get_locations(compile_ctx, values[0])

        if option == 0:
            if values[3] is not None:
                receiving_parameter_list = get_list_without_sep(values[3])
            returning_parameter_list = get_list_without_sep(values[7])
            attributes = values[9]
        elif option == 1:
            if values[3] is not None:
                receiving_parameter_list = get_list_without_sep(values[3])
            attributes = values[5]
        elif option == 2:
            returning_parameter_list = get_list_without_sep(values[4])
            attributes = values[6]
        elif option == 3:
            attributes = values[2]
        self.function_list.append(str(function_name))
        return function_name, receiving_parameter_list, returning_parameter_list, attributes, locations,

    def ac_function_key_decl(self, compile_ctx, target, option, values):
        """
        function_key_decl
            : function_key_signature stmt
        """
        assert(option == 0)
        function_key_name, sequence, is_globally, locations, = values[0]
        stmt_list = create_stmts_node_from_list(values[1])
        return FunctionKey(name=function_key_name,
                           stmts=stmt_list,
                           sequence=sequence,
                           is_globally=is_globally,
                           locations=locations)

    def ac_function_key_signature(self, compile_ctx, target, option, values):
        """
        function_key_signature
            : FUNCTION_KEY name IS concatenated_string GLOBALLY
            | FUNCTION_KEY name IS concatenated_string
        """
        assert(option in range(2))
        function_key_name = values[1]
        locations = get_locations(compile_ctx, values[0])
        sequence = values[3]
        is_globally = option == 0
        return function_key_name, sequence, is_globally, locations,

    def ac_frm_frmt_decl(self, compile_ctx, target, option, values):
        """
        frm_frmt_decl
            : FRAME_FORMAT name frame_format_def
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        return FrameFormat(values[1], values[2], locations=locations)

    def ac_frame_format_def(self, compile_ctx, target, option, values):
        """
        frame_format_def
            : concatenated_string
            | frame_format_def concatenated_string
        """
        assert(option in range(2))
        if option == 0:
            return values
        elif option == 1:
            values[0].append(values[1])
            return values[0]

    def ac_frame_decl(self, compile_ctx, target, option, values):
        """
        frame_decl
            : FRAME name FROM frame_format_location border frame_area_opt frame_data_info frame_data_names controlled_field_list
            | FRAME name FROM frame_format_location border frame_area_opt controlled_field_list
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        frame_name = values[1]
        frame_format_location = values[3]
        border = values[4]
        frame_area = values[5]
        if option == 0:
            frame_data_info = values[6]
            frame_data_names = values[7]
            controlled_field_list = values[8]
        else:
            frame_data_info = None
            frame_data_names = []
            controlled_field_list = values[6]

        return Frame(frame_name, frame_format_location, border, frame_area, frame_data_info, frame_data_names, controlled_field_list, locations=locations)

    def ac_frame_format_location(self, compile_ctx, target, option, values):
        """
        frame_format_location
            : name
            | FILE_TOKEN quoted_string
            | TEXT quoted_string
        """
        assert(option in range(3))
        if option == 0:
            frame_format_name = values[0]
            return FrameFormatRef(frame_format_name)
        else:
            locations = get_locations(compile_ctx, values[0])
            file_value = create_char_literal_node(compile_ctx, values[1])

            if option == 1:
                file_spec = File(file_value, locations=locations)
            elif option == 2:
                file_spec = Text(file_value, locations=locations)

            return FrameFormatFile(file_spec, locations=locations)

    def ac_border(self, compile_ctx, target, option, values):
        """
        border
            :
            | BORDER ON
            | BORDER OFF
        """
        assert(option in range(3))
        return option == 1

    def ac_frame_data_info(self, compile_ctx, target, option, values):
        """
        frame_data_info
            : DATA quoted_string OR quoted_string
            | DATA quoted_string
            |
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        char1 = create_char_literal_node(compile_ctx, values[1])
        if option == 0:
            char2 = create_char_literal_node(compile_ctx, values[3])
        else:
            char2 = None
        return FrameDataInfo(char1, char2, locations=locations)

    def ac_frame_data_names(self, compile_ctx, target, option, values):
        """
        frame_data_names
            : DATA_NAME frame_data_list
            | DATA_NAMES frame_data_list
        """
        assert(option in range(2))
        return create_names(compile_ctx, values[1])

    def ac_frame_area(self, compile_ctx, target, option, values):
        """
        frame_area
            : FRAME_AREA frame_area_data TO frame_area_data
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])

        if isinstance(values[1], (ConstantRef, Name)):
            first_line = values[1]
        else:
            first_line = create_number_node(compile_ctx, values[1])

        if isinstance(values[3], (ConstantRef, Name)):
            last_line = values[3]
        else:
            last_line = create_number_node(compile_ctx, values[3])

        return FrameArea(first_line, last_line, locations=locations)

    def ac_controlled_field(self, compile_ctx, target, option, values):
        """
        controlled_field
            : FIELD_CONTROL LPAREN field_ref_list RPAREN control_item_list
            | FIELD_CONTROL field_ref control_item_list
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            return FrameControlledField(get_list_without_sep(values[2]), values[4], locations=locations)
        elif option == 1:
            return FrameControlledField([values[1]], values[2], locations=locations)

    def ac_field_ref(self, compile_ctx, target, option, values):
        """
        field_ref
            : name
            | name LBRACKET ALL RBRACKET of_op name
            | name of_op name
        """
        assert(option in range(3))
        locations = values[0].locations
        if option == 0:
            return create_id_or_calling_function(compile_ctx, self.function_list, values[0], locations=locations)
        elif option == 1:
            return ArrayId(values[0], ArrayIndexAll(locations=locations), values[5], locations=locations)
        elif option == 2:
            return Id(values[0], values[2], locations=locations)

    def ac_col_name_ref(self, compile_ctx, target, option, values):
        """
        col_name_ref
            : name
            | name of_op name
        """
        assert(option in range(2))
        locations = values[0].locations
        if option == 0:
            return RelationFieldId(values[0], locations=locations)
        elif option == 1:
            return RelationFieldId(values[0], values[2], locations=locations)

    def ac_control_item(self, compile_ctx, target, option, values):
        """
        control_item
            : BLANK
            | BLINK
            | BOLD
            | COLOR integer
            | DIM
            | HELP message
            | INITIAL_TOKEN
            | MINIMUM_LENGTH integer
            | OPAQUE
            | PROTECTED
            | REQUIRED
            | REVERSE
            | TERMINATE_FIELD
            | UNDERLINE
        """
        assert(option in range(14))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            return FrameControlBlank(locations=locations)
        elif option == 1:
            return FrameControlBlink(locations=locations)
        elif option == 2:
            return FrameControlBold(locations=locations)
        elif option == 3:
            return FrameControlColor((create_number_node(compile_ctx, values[1]), ), locations=locations)
        elif option == 4:
            return FrameControlDim(locations=locations)
        elif option == 5:
            return FrameControlHelp(values[1], locations=locations)
        elif option == 6:
            return FrameControlInitial(locations=locations)
        elif option == 7:
            return FrameControlMinimumLength((create_number_node(compile_ctx, values[1]), ), locations=locations)
        elif option == 8:
            return FrameControlOpaque(locations=locations)
        elif option == 9:
            return FrameControlProtected(locations=locations)
        elif option == 10:
            return FrameControlRequired(locations=locations)
        elif option == 11:
            return FrameControlReverse(locations=locations)
        elif option == 12:
            return FrameControlTerminateField(locations=locations)
        elif option == 13:
            return FrameControlUnderline(locations=locations)

    def ac_message(self, compile_ctx, target, option, values):
        """
        message
            : char_literal
            | message COMMA char_literal
        """
        assert(option in range(2))
        if option == 0:
            return [create_char_literal_node(compile_ctx, values[0])]
        elif option == 1:
            message = values[0]
            message.append(create_char_literal_node(compile_ctx, values[2]))
            return message

    def ac_report_decl(self, compile_ctx, target, option, values):
        """
        report_decl
            : report_head report_parameters report_cond_def_list
        """
        assert(option == 0)
        locations, report_name, report_append, char_set_spec, report_file = values[0]
        report_parameters = values[1]
        report_conditions = values[2]
        return Report(report_name, report_append, char_set_spec, report_file, report_parameters, report_conditions, locations=locations)

    def ac_report_head(self, compile_ctx, target, option, values):
        """
        report_head
            : REPORT name_opt append_opt TO char_set_spec report_file
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])

        report_name = values[1]

        report_append = values[2] is not None

        if values[4] is None:
            char_set_spec = ReportCharSetDefault()
        else:
            char_set_spec_type = get_type(*values[4])
            char_set_spec_locations = get_locations(compile_ctx, values[4])
            if char_set_spec_type == ASCII:
                char_set_spec = ReportCharSetAscii(char_set_spec_locations)
            elif char_set_spec_type == BINARY:
                char_set_spec = ReportCharSetBinary(char_set_spec_locations)
            elif char_set_spec_type == KANA:
                char_set_spec = ReportCharSetKana(char_set_spec_locations)

        if isinstance(values[5], FileSpec):
            report_file = values[5]
            if isinstance(report_file.value, ConcatenatedString) and len(report_file.value.values) == 1 and isinstance(report_file.value.values[0], Name):
                report_file.value = Id(report_file.value.values[0], locations)
        else:
            report_file_locations = get_locations(compile_ctx, values[5])
            report_file = ReportOutport(report_file_locations)

        return locations, report_name, report_append, char_set_spec, report_file,

    def ac_file_spec(self, compile_ctx, target, option, values):
        """
        file_spec
            : concatenated_string
            | FILE_TOKEN concatenated_string
            | TERMINAL
            | TEXT concatenated_string
        """
        assert(option in range(4))
        if option == 0:
            if isinstance(values[0], ConcatenatedString) and len(values[0].values) == 1 and isinstance(values[0].values[0], Name):
                return File(Id(values[0].values[0]))
            else:
                return File(values[0])
        else:
            locations = get_locations(compile_ctx, values[0])
            if option == 1:
                if isinstance(values[1], ConcatenatedString) and len(values[1].values) == 1 and isinstance(values[1].values[0], Name):
                    return File(Id(values[1].values[0]), locations=locations)
                else:
                    return File(values[1], locations=locations)
            elif option == 2:
                return Terminal(locations=locations)
            elif option == 3:
                if isinstance(values[1], ConcatenatedString) and len(values[1].values) == 1 and isinstance(values[1].values[0], Name):
                    return Text(Id(values[1].values[0]), locations=locations)
                else:
                    return Text(values[1], locations=locations)

    def ac_report_param(self, compile_ctx, target, option, values):
        """
        report_param
            : report_arith_item decl_arith_exp
            | report_char_item char_literal
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        item_type = get_type(*values[0])
        item_name = get_token(*values[0])
        if option == 0:
            if item_type == BOTTOM_MARGIN:
                return BottomMargin(item_name, values[1], locations=locations)
            if item_type == FOOTING_SIZE:
                return FootingSize(item_name, values[1], locations=locations)
            if item_type == HEADING_SIZE:
                return HeadingSize(item_name, values[1], locations=locations)
            if item_type == LINE_LENGTH:
                return LineLength(item_name, values[1], locations=locations)
            if item_type == LINE_NUM:
                return LineNum(item_name, values[1], locations=locations)
            if item_type == PAGE_NUM:
                return PageNum(item_name, values[1], locations=locations)
            if item_type == PAGE_SIZE:
                return PageSize(item_name, values[1], locations=locations)
            if item_type == TOP_MARGIN:
                return TopMargin(item_name, values[1], locations=locations)
        else:
            if item_type == PAGE_TOP:
                return PageTop(item_name, create_char_literal_node(compile_ctx, values[1]), locations=locations)
            else:
                return PageDivider(item_name, create_char_literal_node(compile_ctx, values[1]), locations=locations)

    def ac_report_cond_def(self, compile_ctx, target, option, values):
        """
        report_cond_def
            : group_cond stmt
            | report_cond stmt
        """
        assert(option in range(2))
        stmts = create_stmts_node_from_list(values[1])
        if option == 0:
            group_cond = values[0]
            group_cond.stmts = stmts
            return group_cond
        else:
            locations = get_locations(compile_ctx, values[0])
            item_name = get_token(*values[0])
            if get_type(*values[0]) == PAGE_FOOTING:
                return PageFooting(item_name, stmts, locations=locations)
            elif get_type(*values[0]) == PAGE_HEADING:
                return PageHeading(item_name, stmts, locations=locations)
            elif get_type(*values[0]) == REPORT_FOOTING:
                return ReportFooting(item_name, stmts, locations=locations)
            elif get_type(*values[0]) == REPORT_HEADING:
                return ReportHeading(item_name, stmts, locations=locations)

    def ac_group_cond(self, compile_ctx, target, option, values):
        """
        group_cond
            : GROUP_HEADING name_opt ON name
            | GROUP_FOOTING name_opt ON name
        """
        assert(option in range(2))
        group_token = values[0]
        locations = get_locations(compile_ctx, group_token)
        item_name = get_token(*group_token)
        group_name = values[1]
        filed_name = values[3]
        if option == 0:
            return GroupHeading(item_name, group_name, filed_name, None, locations=locations)
        else:
            return GroupFooting(item_name, group_name, filed_name, None, locations=locations)

    def ac_screen_decl(self, compile_ctx, target, option, values):
        """
        screen_decl
            : SCREEN screen_def_list
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        screen_def_list = values[1]
        return Screen(screen_def_list, locations)

    def ac_screen_def(self, compile_ctx, target, option, values):
        """
        screen_def
            : char_item char_literal
            | FUNCTION_LENGTH integer
            | FUNCTION_SEPARATOR char_literal
            | LINE_LENGTH integer
            | MESSAGE_AREA integer TO_integer
            | SCREEN_SIZE integer
        """
        assert(option in range(6))
        if option == 0:
            locations = get_locations(compile_ctx, values[0])
            char_item = get_type(*values[0])
            value = create_char_literal_node(compile_ctx, values[1])
            if char_item == ABORT_PROCEDURE:
                return ScreenAbortProcedure(value, locations)
            elif char_item == BACKUP_CHARACTER:
                return ScreenBackupCharacter(value, locations)
            elif char_item == BACKUP_FIELD:
                return ScreenBackupField(value, locations)
            elif char_item == FIELD_FILLER:
                return ScreenFieldFiller(value, locations)
            elif char_item == GET_HELP:
                return ScreenGetHelp(value, locations)
            elif char_item == SKIP_FIELD:
                return ScreenSkipField(value, locations)
            elif char_item == TERMINATE_FIELD:
                return ScreenTerminateField(value, locations)
        elif option == 1:
            locations = get_locations(compile_ctx, values[0])
            length = create_number_node(compile_ctx, values[1])
            return ScreenFunctionLength(length, locations=locations)
        elif option == 2:
            locations = get_locations(compile_ctx, values[0])
            separator = create_char_literal_node(compile_ctx, values[1])
            return ScreenFunctionSeparator(separator, locations=locations)
        elif option == 3:
            locations = get_locations(compile_ctx, values[0])
            length = create_number_node(compile_ctx, values[1])
            return ScreenLineLength(length, locations=locations)
        elif option == 4:
            locations = get_locations(compile_ctx, values[0])
            first_line = create_number_node(compile_ctx, values[1])
            last_line = values[2]
            return ScreenMessageArea(first_line, last_line, locations=locations)
        elif option == 5:
            locations = get_locations(compile_ctx, values[0])
            size = create_number_node(compile_ctx, values[1])
            return ScreenSize(size, locations=locations)

    def ac_TO_integer(self, compile_ctx, target, option, values):
        """
        TO_integer: | TO integer
        """
        assert(option == 1)
        return create_number_node(compile_ctx, values[1])

    def ac_source_decl(self, compile_ctx, target, option, values):
        """
        source_decl: SOURCE name FROM source_file source_attr_list INPUT input_list prompt_opt
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        source_name = values[1]

        if isinstance(values[3], FileSpec):
            source_file = values[3]
        else:
            source_file = SourceInport(values[3], locations)

        source_attr_list = values[4]
        input_list = get_list_without_sep(values[6])
        source_prompt = values[7]
        return Source(source_name, source_file, source_attr_list, input_list, source_prompt, locations=locations)

    def ac_source_attr(self, compile_ctx, target, option, values):
        """
        source_attr : no_echo | BINARY FORM | FIXED FORM | FREE FORM | INVALIDS TO file_spec | LINE_LENGTH decl_arith_exp | no_verify | SEPARATOR char_literal
        """
        assert(option in range(8))
        if option == 0:
            return values[0]
        elif option == 6:
            return values[0]
        else:
            locations = get_locations(compile_ctx, values[0])
            attr_type = get_type(*values[0])
            if attr_type == BINARY:
                attr_name = get_token(*values[0]) + ' ' + get_token(*values[1])
                return SourceBinaryForm(attr_name, value=None, locations=locations)
            elif attr_type == FIXED:
                attr_name = get_token(*values[0]) + ' ' + get_token(*values[1])
                return SourceFixedForm(attr_name, value=None, locations=locations)
            elif attr_type == FREE:
                attr_name = get_token(*values[0]) + ' ' + get_token(*values[1])
                return SourceFreeForm(attr_name, value=None, locations=locations)
            elif attr_type == INVALIDS:
                attr_name = get_token(*values[0]) + ' ' + get_token(*values[1])
                return SourceInvalids(attr_name, values[2], locations=locations)
            elif attr_type == LINE_LENGTH:
                attr_name = get_token(*values[0])
                line_length_value = values[1]
                if isinstance(line_length_value, Id):
                    line_length_value = ConstantRef(line_length_value.name, locations=line_length_value.locations)
                return SourceLineLength(attr_name, line_length_value, locations=locations)
            elif attr_type == SEPARATOR:
                attr_name = get_token(*values[0])
                separator_value = create_char_literal_node(compile_ctx, values[1])
                return SourceSeparator(attr_name, separator_value, locations=locations)

    def ac_no_echo(self, compile_ctx, target, option, values):
        """
        no_echo: NO ECHO
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        attr_name = get_token(*values[0]) + ' ' + get_token(*values[1])
        return NoEcho(attr_name, locations=locations)

    def ac_no_verify(self, compile_ctx, target, option, values):
        """
        no_verify: NO VERIFY
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        attr_name = get_token(*values[0]) + ' ' + get_token(*values[1])
        return NoVerify(attr_name, locations=locations)

    def ac_prompt_opt(self, compile_ctx, target, option, values):
        """
        prompt_opt:| WITH prompt_error_edit
        """
        assert(option in range(2))
        if option == 0:
            prompt_error_edit = []
        else:
            assert(isinstance(values[1], (list, ForClause)))
            if isinstance(values[1], list):
                prompt_error_edit = values[1]
            else:
                prompt_error_edit = [values[1]]

        return prompt_error_edit

    def ac_prompt_error_edit(self, compile_ctx, target, option, values):
        """
        prompt_error_edit: prompt_err_edit_fld | prompt_error_edit COMMA prompt_err_edit_fld
        """
        assert(option == 1)
        assert(isinstance(values[0], (list, ForClause)))
        if isinstance(values[0], list):
            prompt_error_edit = values[0]
            prompt_error_edit.append(values[2])
        else:
            prompt_error_edit = [values[0], values[2]]
        return prompt_error_edit

    def ac_prompt_err_edit_fld(self, compile_ctx, target, option, values):
        """
        prompt_err_edit_fld: prompt_err_edit_list FOR name
        """
        assert(option == 0)
        return ForClause(get_list_without_sep(values[0]), values[2])

    def ac_prompt_err_edit_opt(self, compile_ctx, target, option, values):
        """
        prompt_err_edit_opt: EDIT arith_exp| PROMPT quoted_string| PROMPT name| ERRORS quoted_string| ERRORS name
        """
        assert(option in range(5))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            return EditClause(values[1], locations=locations)
        elif option == 1:
            clause_value = create_char_literal_node(compile_ctx, values[1])
            return PromptClause(clause_value, locations=locations)
        elif option == 2:
            return PromptClause(values[1], locations=locations)
        elif option == 3:
            clause_value = create_char_literal_node(compile_ctx, values[1])
            return ErrorClause(clause_value, locations=locations)
        elif option == 4:
            return ErrorClause(values[1], locations=locations)

    def ac_output_item(self, compile_ctx, target, option, values):
        """
        output_item
            : AT_SKIP arith_exp
            | AT_SKIP TO arith_exp
            | arith_exp
            | tab_info
        """
        assert(option in range(4))
        if option == 0:
            locations = get_locations(compile_ctx, values[0])
            return Skip(values[1], locations=locations)
        elif option == 1:
            locations = get_locations(compile_ctx, values[0])
            return SkipTo(values[2], locations=locations)
        else:
            return values[0]

    def ac_tab_info(self, compile_ctx, target, option, values):
        """
        tab_info
            : AT_TAB arith_exp
            | AT_TAB TO arith_exp
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            return Tab(values[1], locations=locations)
        elif option == 1:
            return TabTo(values[2], locations=locations)

    def ac_input_item(self, compile_ctx, target, option, values):
        """
        input_item
            : AT_CR
            | tab_info
            | CONDITIONAL ON decl_arith_exp BEGIN_TOKEN input_case_list END input_else_opt
            | name LBRACKET array_index RBRACKET input_of_opt
            | name format_picture
        """
        assert(option in range(5))
        if option == 0:
            locations = get_locations(compile_ctx, values[0])
            return ControlCharacter(get_token(*values[0]), locations=locations)
        elif option == 1:
            return values[0]
        elif option == 2:
            locations = get_locations(compile_ctx, values[0])
            return SourceConditional(values[2], values[4], values[6], locations=locations)
        elif option == 3:
            return SourceInputArrayId(values[0], values[2], values[4])
        elif option == 4:
            return SourceInputId(values[0], values[1])

    def ac_input_case(self, compile_ctx, target, option, values):
        """
        input_case: case_labels COLON input_case_exp
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[1])
        if isinstance(values[2], tuple):
            assert(get_type(*values[2]) == NOTHING)
            input_case_exp = []
        else:
            input_case_exp = get_list_without_sep(values[2])
        return InputCase(values[0], input_case_exp, locations=locations)

    def ac_case_labels(self, compile_ctx, target, option, values):
        """
        case_labels: literal | case_labels OR literal
        """
        assert(option in range(2))
        if option == 0:
            return values
        else:
            values[0].append(values[2])
            return values[0]

    def ac_input_else_opt(self, compile_ctx, target, option, values):
        """
        input_else_opt : ELSE BEGIN_TOKEN input_case_exp END |
        """
        assert(option in range(2))
        if option == 0:
            if isinstance(values[2], tuple):
                assert(get_type(*values[2]) == NOTHING)
                return []
            else:
                return get_list_without_sep(values[2])
        else:
            return []

    def ac_input_of_opt(self, compile_ctx, target, option, values):
        """
        input_of_opt: | of_op name
        """
        assert(option == 1)
        return values[1]

    def ac_conditional_stmt(self, compile_ctx, target, option, values):
        """
        conditional_stmt: CONDITIONAL ON arith_exp BEGIN_TOKEN case_stmt_list END else_clause
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        cond = values[2]
        case_stmt_list = values[4]
        else_clause = values[6]
        return Conditional(cond, case_stmt_list, else_clause, locations=locations)

    def ac_case_stmt(self, compile_ctx, target, option, values):
        """
        case_stmt: case_labels COLON stmt
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[1])
        stmt = values[2]
        stmt_list = create_stmts_node_from_list(stmt)
        return CaseStmt(values[0], stmt_list, locations=locations)

    def ac_else_clause(self, compile_ctx, target, option, values):
        """
        else_clause: ELSE stmt |
        """
        assert(option == 0)
        stmt = values[1]
        stmt_list = create_stmts_node_from_list(stmt)
        return stmt_list

    def ac_display_stmt(self, compile_ctx, target, option, values):
        """
        display_stmt
            : DISPLAY protected_opt name_list USING name_list stmt
            | DISPLAY protected_opt name_list stmt
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        protect = values[1] is not None
        frame_names = get_list_without_sep(values[2])
        if option == 0:
            function_key_names = get_list_without_sep(values[4])
            stmt = values[5]
        else:
            function_key_names = []
            stmt = values[3]
        stmt_list = create_stmts_node_from_list(stmt)
        return Display(protect, frame_names, function_key_names, stmt_list, locations=locations)

    def ac_do_while_stmt(self, compile_ctx, target, option, values):
        """
        do_while_stmt
            : DO stmt WHILE bool_exp
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        stmt = values[1]
        stmt_list = create_stmts_node_from_list(stmt)
        cond = values[3]
        return DoWhile(stmt_list, cond, locations=locations)

    def ac_for_stmt(self, compile_ctx, target, option, values):
        """
        for_stmt
            : FOR EACH qualified_rel_alias control_clause DO stmt
            | FOR EACH qualified_rel_alias report_clause control_clause DO stmt
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        qualified_rel_alias = values[2]

        if option == 0:
            report_names = None
            control_clause = values[3]
            stmt = values[5]
        else:
            __, report_names, = values[3]
            control_clause = values[4]
            stmt = values[6]
        stmt_list = create_stmts_node_from_list(stmt)
        return For(qualified_rel_alias, report_names, control_clause, stmt_list, locations=locations)

    def ac_grouped_clause(self, compile_ctx, target, option, values):
        """
        grouped_clause
            : GROUPED ON group_list
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        group_list = get_list_without_sep(values[2])
        return GroupedClause(group_list, locations=locations)

    def ac_sorted_clause(self, compile_ctx, target, option, values):
        """
        sorted_clause
            : SORTED
            | SORTED ASCENDING
            | SORTED DESCENDING
            | SORTED ON sort_list
        """
        assert(option in range(4))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            return SortedClause(Ascending(locations=locations), locations=locations)
        elif option == 1:
            return SortedClause(Ascending(get_locations(compile_ctx, values[1])), locations=locations)
        elif option == 2:
            return SortedClause(Descending(get_locations(compile_ctx, values[1])), locations=locations)
        else:
            return SortedOnClause(get_list_without_sep(values[2]), locations=locations)

    def ac_qualified_rel_alias(self, compile_ctx, target, option, values):
        """
        qualified_rel_alias
            : name alias_clause join_clause_list_opt via_clause_opt where_clause_opt grouped_clause_opt sorted_clause_opt
        """
        assert(option == 0)
        relation_name = values[0]
        alias_name = values[1]
        join_clause_list = values[2]
        via_clause = values[3]
        where_clause = values[4]
        grouped_clause = values[5]
        sorted_clause = values[6]
        return QualifiedRelationAlias(relation_name, alias_name, join_clause_list, via_clause, where_clause, grouped_clause, sorted_clause)

    def ac_alias_clause(self, compile_ctx, target, option, values):
        """
        alias_clause
            : ALIAS name
            |
        """
        assert(option == 0)
        return values[1]

    def ac_join_clause(self, compile_ctx, target, option, values):
        """
        join_clause
        : INNER JOIN name alias_clause ON bool_exp
        | LEFT OUTER JOIN name alias_clause ON bool_exp
        | RIGHT OUTER JOIN name alias_clause ON bool_exp
        | FULL OUTER JOIN name alias_clause ON bool_exp
        """
        assert(option in range(4))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            return InnerJoinClause(values[2], values[3], values[5], locations=locations)
        elif option == 1:
            return LeftOuterJoinClause(values[3], values[4], values[6], locations=locations)
        elif option == 2:
            return RightOuterJoinClause(values[3], values[4], values[6], locations=locations)
        else:
            return FullOuterJoinClause(values[3], values[4], values[6], locations=locations)

    def ac_where_clause(self, compile_ctx, target, option, values):
        """
        where_clause
            : WHERE bool_exp
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        return WhereClause(values[1], locations=locations)

    def ac_sort_item(self, compile_ctx, target, option, values):
        """
        sort_item
            : order field_ref
        """
        assert(option == 0)
        locations = None
        if values[0] is None:
            order = Ascending(locations=locations)
        else:
            locations = get_locations(compile_ctx, values[0])
            if get_type(*values[0]) in (PLUS, ASCENDING):
                order = Ascending(locations=locations)
            else:
                order = Descending(locations=locations)
        return SortItem(order, values[1], locations=locations)

    def ac_control_clause(self, compile_ctx, target, option, values):
        """
        control_clause
            : CONTROLLED BY name_list
            |
        """
        locations = get_locations(compile_ctx, values[0])
        group_condition_name_list = create_names(compile_ctx, values[2])
        return ControlClause(group_condition_name_list, locations=locations)

    def ac_if_stmt(self, compile_ctx, target, option, values):
        """
        if_stmt
            : IF bool_exp then_else_clause
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        return If(values[1], values[2], locations=locations)

    def ac_then_else_clause(self, compile_ctx, target, option, values):
        """
        then_else_clause
            : THEN stmt
            | THEN stmt ELSE stmt
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            then_stmt = values[1]
            then_stmt_list = create_stmts_node_from_list(then_stmt)
            return ThenElseClause(then_stmt_list, locations=locations)
        elif option == 1:
            then_stmt = values[1]
            then_stmt_list = create_stmts_node_from_list(then_stmt)
            else_stmt = values[3]
            else_stmt_list = create_stmts_node_from_list(else_stmt)
            return ThenElseClause(then_stmt_list, else_stmts=else_stmt_list, locations=locations)

    def ac_pause_for_stmt(self, compile_ctx, target, option, values):
        """
        pause_for_stmt
            : PAUSE_FOR_INPUT arith_exp then_else_clause
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        return PauseForInput(values[1], values[2], locations=locations)

    def ac_select_stmt(self, compile_ctx, target, option, values):
        """
        select_stmt
            : SELECT qualified_rel_alias then_else_clause
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        return Select(values[1], values[2], locations=locations)

    def ac_while_do_stmt(self, compile_ctx, target, option, values):
        """
        while_do_stmt
            : WHILE bool_exp DO stmt
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        cond = values[1]
        stmt = values[3]
        stmt_list = create_stmts_node_from_list(stmt)
        return WhileDo(cond, stmt_list, locations=locations)

    def ac_write_report_stmt(self, compile_ctx, target, option, values):
        """
        write_report_stmt
            : report_clause stmt
        """
        assert(option == 0)
        (locations, report_clause,), stmt, = values
        stmt_list = create_stmts_node_from_list(stmt)
        return WriteReport(report_clause, stmt_list, locations=locations)

    def ac_report_clause(self, compile_ctx, target, option, values):
        """
        report_clause
            : WRITE REPORT
            | WRITE REPORTS
            | WRITE REPORT name_list
            | WRITE REPORTS name_list
        """
        assert(option in range(4))
        locations = get_locations(compile_ctx, values[0])
        if option in [0, 1]:
            return locations, [],
        else:
            return locations, get_list_without_sep(values[2]),

    def ac_abort_stmt(self, compile_ctx, target, option, values):
        """
        abort_stmt
            : ABORT
            | ABORT output_list
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            output_list = []
        else:
            output_list = get_list_without_sep(values[1])
        return Abort(output_list, locations=locations)

    def ac_accept_stmt(self, compile_ctx, target, option, values):
        """
        accept_stmt
            : ACCEPT echo_verify_opt input_fld_name prompt_opt
            | ACCEPT FROM TERMINAL echo_verify_opt input_fld_name prompt_opt
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            from_terminal = False
            no_echo, no_verify, = values[1]
            field_names = values[2]
            prompt_clause = values[3]
        elif option == 1:
            from_terminal = True
            no_echo, no_verify, = values[3]
            field_names = values[4]
            prompt_clause = values[5]

        if prompt_clause is None:
            prompt_clause = []
        return Accept(from_terminal, no_echo, no_verify, field_names, prompt_clause, locations=locations)

    def ac_input_fld_name(self, compile_ctx, target, option, values):
        """
        input_fld_name
            : fld_name
            | input_fld_name COMMA fld_name
        """
        assert(option in range(2))
        if option == 0:
            return values
        elif option == 1:
            values[0].append(values[2])
            return values[0]

    def ac_fld_name(self, compile_ctx, target, option, values):
        """
        fld_name
            : AT_CR
            | qualified_name format_picture
        """
        assert(option in range(2))
        if option == 0:
            locations = get_locations(compile_ctx, values[0])
            return ControlCharacter(get_token(*values[0]), locations=locations)
        elif option == 1:
            assert(isinstance(values[0], Id))
            _id = values[0]
            input_picture = values[1]
            if isinstance(values[0], ArrayId):
                return AcceptInputArrayId(name=_id.name, index=_id.index, of_name=_id.of_name, locations=_id.locations, input_picture=input_picture)
            else:
                return AcceptInputId(name=_id.name, of_name=_id.of_name, locations=_id.locations, input_picture=input_picture)

    def ac_add_stmt(self, compile_ctx, target, option, values):
        """
        add_stmt
            : ADD arith_exp TO var_list round_spec
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        conversion_type, echo, = eval_round_spec(values[4], locations=locations)
        var_list = get_list_without_sep(values[3])
        arith_exp = values[1]
        if isinstance(arith_exp, Default):
            e = SyntaxError(119, "This reserved word is illegal here. Use one of the following: %s" % (
                "<expression>"), locations[2], locations[0], locations[1])
            raise e
        return Add(arith_exp, var_list, conversion_type=conversion_type, echo=echo, locations=locations)

    def ac_round_spec(self, compile_ctx, target, option, values):
        """
        round_spec
            :
            | round_spec round_spec_elt
        """
        assert(option in range(2))
        if option == 0:
            return []
        elif option == 1:
            if isinstance(values[1], NoEcho):
                round_spec_elt = values[1]
            elif get_type(*values[1]) == ROUNDED:
                locations = get_locations(compile_ctx, values[1])
                round_spec_elt = Rounded(locations=locations)
            elif get_type(*values[1]) == TRUNCATED:
                locations = get_locations(compile_ctx, values[1])
                round_spec_elt = Truncated(locations=locations)
            elif get_type(*values[1]) == ECHO:
                locations = get_locations(compile_ctx, values[1])
                round_spec_elt = Echo(None, locations=locations)
            return values[0] + [round_spec_elt, ]

    def ac_alter_stmt(self, compile_ctx, target, option, values):
        """
        alter_stmt
            : ALTER name using_opt
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        return Alter(values[1], values[2], locations=locations)

    def ac_using_clause(self, compile_ctx, target, option, values):
        """
        using_clause
            : USING LPAREN using_exp_list RPAREN
        """
        assert(option == 0)
        return get_list_without_sep(values[2])

    def ac_using_exp(self, compile_ctx, target, option, values):
        """
        using_exp
            : arith_exp FOR name
        """
        assert(option == 0)
        return UsingClause(values[0], values[2])

    def ac_checkpoint_stmt(self, compile_ctx, target, option, values):
        """
        checkpoint_stmt
            : CHECKPOINT
            | CHECKPOINT name_list
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            name_list = []
        else:
            name_list = get_list_without_sep(values[1])
        return Checkpoint(name_list, locations=locations)

    def ac_clear_stmt(self, compile_ctx, target, option, values):
        """
        clear_stmt
            : CLEAR clear_head
        """
        assert(option == 0)
        values[1].locations = get_locations(compile_ctx, values[0])
        return values[1]

    def ac_clear_head(self, compile_ctx, target, option, values):
        """
        clear_head
            : frame_list
            | TERMINAL direction
        """
        assert(option in range(2))
        if option == 0:
            return ClearFrame(values[0])
        else:
            if get_type(*values[1]) == INPORT:
                return ClearTerminalInport()
            else:
                return ClearTerminalOutport()

    def ac_compile_stmt(self, compile_ctx, target, option, values):
        """
        compile_stmt
            : comp_head BEGIN_TOKEN case_stmt_list END else_clause
        """
        assert(option == 0)
        locations, compile_cond = values[0]
        case_stmt_list = values[2]
        else_clause = values[4]
        return CompileDirective(compile_cond, case_stmt_list, else_clause, locations=locations)

    def ac_comp_head(self, compile_ctx, target, option, values):
        """
        comp_head
            : COMPILE CONDITIONALLY ON literal
            | COMPILE CONDITIONALLY ON concatenated_string
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        return locations, values[3] if not isinstance(values[3], Name) else ConstantRef(values[3], locations=values[3].locations),

    def ac_delete_stmt(self, compile_ctx, target, option, values):
        """
        delete_stmt
            : DELETE file_text
            | DELETE FROM qualified_relation ALL
            | DELETE FROM qualified_relation
        """
        assert(option in range(3))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            return DeleteFile(values[1], locations=locations)
        elif option == 1:
            return DeleteRelation(values[2], True, locations=locations)
        elif option == 2:
            return DeleteRelation(values[2], False, locations=locations)

    def ac_qualified_relation(self, compile_ctx, target, option, values):
        """
        qualified_relation
            : name via_clause_opt where_clause_opt
        """
        assert(option == 0)
        alias_name = join_clause_list = grouped_clause = sorted_clause = None
        relation_name = values[0]
        via_clause = values[1]
        where_clause = values[2]
        return QualifiedRelationAlias(relation_name, alias_name, join_clause_list, via_clause, where_clause, grouped_clause, sorted_clause)

    def ac_file_text(self, compile_ctx, target, option, values):
        """
        file_text
            : FILE_TOKEN arith_exp
            | TEXT arith_exp
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            return File(values[1], locations=locations)
        elif option == 1:
            return Text(values[1], locations=locations)

    def ac_function_stmt(self, compile_ctx, target, option, values):
        """
        function_stmt
            : name param_opt
        """
        assert(option == 0)
        calling_parameters, accepting_parameters = values[1]
        locations = values[0].locations
        return FunctionStmt(values[0], calling_parameters, accepting_parameters, locations=locations)

    def ac_finish_stmt(self, compile_ctx, target, option, values):
        """
        finish_stmt
            : FINISH name
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        return Finish(values[1], locations=locations)

    def ac_force_stmt(self, compile_ctx, target, option, values):
        """
        force_stmt
            : FORCE force_clause
        """
        if isinstance(values[1], tuple):
            locations = get_locations(compile_ctx, values[0])
            item_name = get_token(*values[1])
            item_type = get_type(*values[1])
            if item_type == PAGE_FOOTING:
                force_cond = PageFooting(item_name, None, locations=locations)
            elif item_type == PAGE_HEADING:
                force_cond = PageHeading(item_name, None, locations=locations)
            elif item_type == REPORT_FOOTING:
                force_cond = ReportFooting(item_name, None, locations=locations)
            elif item_type == REPORT_HEADING:
                force_cond = ReportHeading(item_name, None, locations=locations)

            return Force(force_cond, None, locations=locations)

        elif isinstance(values[1], Name):
            locations = get_locations(compile_ctx, values[0])
            force_cond = values[1]
            report_name = None
            return Force(force_cond, report_name, locations=locations)

        elif isinstance(values[1], Force):
            return values[1]

        else:
            raise

    def ac_force_clause(self, compile_ctx, target, option, values):
        """
        force_clause
            : FOR name force_cond
            | force_cond
            | name
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        report_name = values[1]
        if isinstance(values[2], tuple):
            locations = get_locations(compile_ctx, values[0])
            item_name = get_token(*values[2])
            item_type = get_type(*values[2])
            if item_type == PAGE_FOOTING:
                force_cond = PageFooting(item_name, None, locations=locations)
            elif item_type == PAGE_HEADING:
                force_cond = PageHeading(item_name, None, locations=locations)
            elif item_type == REPORT_FOOTING:
                force_cond = ReportFooting(item_name, None, locations=locations)
            elif item_type == REPORT_HEADING:
                force_cond = ReportHeading(item_name, None, locations=locations)
        else:
            force_cond = values[2]
        return Force(force_cond, report_name, locations=locations)

    def ac_input_stmt(self, compile_ctx, target, option, values):
        """
        input_stmt
            : INPUT echo_verify_opt qualified_parameter_list USING name_list
            | INPUT echo_verify_opt qualified_parameter_list
            | INPUT FUNCTION_KEY USING name_list
            | INPUT FUNCTION_KEY
        """
        assert(option in range(4))

        locations = get_locations(compile_ctx, values[0])
        no_echo = no_verify = None
        field_reference_list = function_key_name_list = []
        if option == 0:
            no_echo, no_verify, = values[1]
            field_reference_list = get_list_without_sep(values[2])
            function_key_name_list = get_list_without_sep(values[4])
        elif option == 1:
            no_echo, no_verify, = values[1]
            field_reference_list = get_list_without_sep(values[2])
        elif option == 2:
            function_key_name_list = get_list_without_sep(values[3])
        return Input(no_echo, no_verify, field_reference_list, function_key_name_list, locations=locations)

    def ac_echo_verify_opt(self, compile_ctx, target, option, values):
        """
        echo_verify_opt
            :
            | echo_verify
            | echo_verify echo_verify
        """
        assert(option in range(2))
        echo = verify = None
        if option == 1:
            if isinstance(values[0], NoEcho):
                echo = values[0]
            elif isinstance(values[0], NoVerify):
                verify = values[0]
            elif get_type(*values[0]) == ECHO:
                locations = get_locations(compile_ctx, values[0])
                echo = Echo(None, locations=locations)
            elif get_type(*values[0]) == VERIFY:
                locations = get_locations(compile_ctx, values[0])
                verify = Verify(locations=locations)
        elif option == 2:
            echo_0 = echo_1 = verify_0 = verify_1 = None

            if isinstance(values[0], NoEcho):
                echo_0 = values[0]
            elif isinstance(values[0], NoVerify):
                verify_0 = values[0]
            elif get_type(*values[0]) == ECHO:
                locations = get_locations(compile_ctx, values[0])
                echo_0 = Echo(None, locations=locations)
            elif get_type(*values[0]) == VERIFY:
                locations = get_locations(compile_ctx, values[0])
                verify_0 = Verify(locations=locations)

            if isinstance(values[1], NoEcho):
                echo_1 = values[1]
            elif isinstance(values[1], NoVerify):
                verify_1 = values[1]
            elif get_type(*values[1]) == ECHO:
                locations = get_locations(compile_ctx, values[1])
                echo_1 = Echo(None, locations=locations)
            elif get_type(*values[1]) == VERIFY:
                locations = get_locations(compile_ctx, values[1])
                verify_1 = Verify(locations=locations)
            if echo_0 is not None and echo_1 is not None:
                e = SyntaxError(277, "Only one %s clause, please" % (
                    "echo"), locations[2], locations[0], locations[1])
                raise e
            if verify_0 is not None and verify_1 is not None:
                e = SyntaxError(
                    228, "Only one VERIFY clause, please", locations[2], locations[0], locations[1])
                raise e
            echo = (echo_0 if echo_0 is not None else echo_1)
            verify = (verify_0 if verify_0 is not None else verify_1)
        return echo, verify,

    def ac_insert_stmt(self, compile_ctx, target, option, values):
        """
        insert_stmt
            : INSERT INTO name using_opt duplicate_opt
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        return Insert(values[2], values[3], values[4], locations=locations)

    def ac_duplicate_opt(self, compile_ctx, target, option, values):
        """
        duplicate_opt
            :
            | ON DUPLICATE stmt
        """
        assert(option == 1)
        locations = get_locations(compile_ctx, values[0])
        return DuplicateClause(values[2], locations=locations)

    def ac_let_stmt(self, compile_ctx, target, option, values):
        """
        let_stmt
            : LET var_list round_spec EQ arith_exp
            | LET flag_name_list EQ bool_exp
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            conversion_type, echo, = eval_round_spec(values[2], locations=locations)
            var_list = get_list_without_sep(values[1])
            return Let(values[4], var_list, conversion_type=conversion_type, echo=echo, locations=locations)
        else:
            conversion_type = echo = None
            flag_name_list = get_list_without_sep(values[1])
            return Let(values[3], flag_name_list, conversion_type=conversion_type, echo=echo, locations=locations)

    def ac_move_stmt(self, compile_ctx, target, option, values):
        """
        move_stmt
            : MOVE bool_exp TO flag_name_list
            | MOVE arith_exp TO var_list round_spec
        """

        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            conversion_type = echo = None
            flag_name_list = get_list_without_sep(values[3])
            return Move(values[1], flag_name_list, conversion_type=conversion_type, echo=echo, locations=locations)
        else:
            conversion_type, echo, = eval_round_spec(values[4], locations=locations)
            var_list = get_list_without_sep(values[3])
            return Move(values[1], var_list, conversion_type=conversion_type, echo=echo, locations=locations)

    def ac_pause_stmt(self, compile_ctx, target, option, values):
        """
        pause_stmt
            : PAUSE arith_exp
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        return Pause(values[1], locations=locations)

    def ac_print_stmt(self, compile_ctx, target, option, values):
        """
        print_stmt
            : PRINT TO name output_list
            | PRINT output_list
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])

        if option == 0:
            report_name = values[2]
            output_list = get_list_without_sep(values[3])
        else:
            report_name = None
            output_list = get_list_without_sep(values[1])

        return Print(report_name, output_list, locations=locations)

    def ac_prompt_stmt(self, compile_ctx, target, option, values):
        """
        prompt_stmt
            : PROMPT output_list
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        output_list = get_list_without_sep(values[1])
        return Prompt(output_list, locations=locations)

    def ac_repeat_stmt(self, compile_ctx, target, option, values):
        """
        repeat_stmt
            : REPEAT name
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        label_name = values[1]
        return Repeat(label_name, locations=locations)

    def ac_restore_stmt(self, compile_ctx, target, option, values):
        """
        restore_stmt
            : RESTORE frame_list
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        frame_name_list = values[1]
        return Restore(frame_name_list, locations=locations)

    def ac_frame_list(self, compile_ctx, target, option, values):
        """
        frame_list
            : FRAME name_list
        """
        assert(option == 0)
        return get_list_without_sep(values[1])

    def ac_return_stmt(self, compile_ctx, target, option, values):
        """
        return_stmt
            : RETURN
            | RETURN using_clause
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])

        if option == 0:
            using_clause_list = []
        else:
            using_clause_list = values[1]

        return Return(using_clause_list, locations=locations)

    def ac_run_stmt(self, compile_ctx, target, option, values):
        """
        run_stmt
            : RUN name param_opt
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        calling_parameters, accepting_parameters = values[2]
        procedure_name = values[1]
        return RunStmt(procedure_name, calling_parameters, accepting_parameters, locations=locations)

    def ac_param_opt(self, compile_ctx, target, option, values):
        """
        param_opt
            : LPAREN arith_exp_list_opt RPAREN ACCEPTING LPAREN qualified_parameter_list RPAREN
            | LPAREN arith_exp_list_opt SEMICOLON qualified_parameter_list_opt RPAREN
            | LPAREN arith_exp_list_opt RPAREN
            | ACCEPTING LPAREN qualified_parameter_list RPAREN
            |
        """
        assert(option in range(5))
        calling_parameters = []
        accepting_parameters = []

        if option in range(3) and values[1] is not None:
            calling_parameters = get_list_without_sep(values[1])

        if option == 0:
            accepting_parameters = get_list_without_sep(values[5])
        elif option == 1 and values[3] is not None:
            accepting_parameters = get_list_without_sep(values[3])
        elif option == 3:
            accepting_parameters = get_list_without_sep(values[2])

        return calling_parameters, accepting_parameters,

    def ac_set_cursor_stmt(self, compile_ctx, target, option, values):
        """
        set_cursor_stmt
            : SET_CURSOR qualified_name
            | SET_CURSOR AFTER qualified_name
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])

        if option == 0:
            return SetCursor(False, values[1], locations=locations)
        else:
            return SetCursor(True, values[2], locations=locations)

    def ac_subtract_stmt(self, compile_ctx, target, option, values):
        """
        subtract_stmt
            : SUBTRACT arith_exp FROM var_list round_spec
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        conversion_type, echo, = eval_round_spec(values[4], locations=locations)
        var_list = get_list_without_sep(values[3])
        arith_exp = values[1]
        if isinstance(arith_exp, Default):
            e = SyntaxError(119, "This reserved word is illegal here. Use one of the following: %s" % (
                "<expression>"), locations[2], locations[0], locations[1])
            raise e
        return Subtract(arith_exp, var_list, conversion_type=conversion_type, echo=echo, locations=locations)

    def ac_type_stmt(self, compile_ctx, target, option, values):
        """
        type_stmt
            : TYPE type_to_opt output_list
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        if values[1] is None:
            return Type(get_list_without_sep(values[2]), locations=locations)
        elif get_type(*values[1]) == MESSAGE_AREA:
            return TypeToMessageArea(get_list_without_sep(values[2]), locations=locations)
        elif get_type(*values[1]) == TERMINAL:
            return TypeToTerminal(get_list_without_sep(values[2]), locations=locations)

    def ac_type_to_opt(self, compile_ctx, target, option, values):
        """
        type_to_opt
            :
            | TO MESSAGE_AREA
            | TO TERMINAL
        """
        assert(option in range(5))
        if option == 0:
            return None
        elif option == 1:
            return values[1]
        elif option == 2:
            return values[1]

    def ac_wait_stmt(self, compile_ctx, target, option, values):
        """
        wait_stmt
            : WAIT output_list
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        output_list = get_list_without_sep(values[1])
        return Wait(output_list, locations=locations)

    def ac_write_invalids_stmt(self, compile_ctx, target, option, values):
        """
        write_invalids_stmt
            : WRITE_INVALIDS of_op name output_list
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        output_list = get_list_without_sep(values[3])
        return WriteInvalids(values[2], output_list, locations=locations)

    def ac_format_picture(self, compile_ctx, target, option, values):
        """
        format_picture
            : AS BYTE LPAREN integer RPAREN
            | AS name
            | as_picture
            |
        """
        assert(option in range(3))
        if option == 0:
            locations = get_locations(compile_ctx, values[0])
            index = create_number_node(compile_ctx, values[3])
            return AsByte(index, locations=locations)
        elif option == 1:
            locations = get_locations(compile_ctx, values[0])
            if isinstance(values[1], ConstantRef):
                return AsConstant(values[1], locations=locations)
            else:
                return AsId(ReferenceId(values[1]), locations=locations)
        elif option == 2:
            locations = values[0].locations
            return AsPicture(values[0], locations=locations)

    def ac_of_name_opt(self, compile_ctx, target, option, values):
        """
        of_name_opt
            :
            | of_op name
        """
        assert(option == 1)
        return values[1]

    def ac_rplce_function(self, compile_ctx, target, option, values):
        """
        rplce_function
            : SUBSTR named_actual_param
        """
        assert(option in range(3))
        locations = get_locations(compile_ctx, values[0])
        function_name = Name(get_token(*values[0]).lower(), locations=locations)
        parameters = values[1]
        return CallingFunction(function_name, parameters)

    def ac_named_actual_param(self, compile_ctx, target, option, values):
        """
        named_actual_param
            : LPAREN qualified_name COMMA arith_exp_list RPAREN
        """
        assert(option == 0)
        parameters = [values[1]]
        parameters.extend(get_list_without_sep(values[3]))
        return parameters

    def ac_date_function(self, compile_ctx, target, option, values):
        """
        date_function
            : DAY date_fld
            | MONTH date_fld
            | YEAR date_fld
        """
        assert(option in range(3))
        locations = get_locations(compile_ctx, values[0])
        function_name = Name(get_token(*values[0]).lower(), locations=locations)
        parameters = [values[1]]
        return CallingFunction(function_name, parameters, locations=locations)

    def ac_date_fld(self, compile_ctx, target, option, values):
        """
        date_fld
            : LPAREN qualified_name RPAREN
        """
        assert(option == 0)
        return values[1]

    def ac_array_decl(self, compile_ctx, target, option, values):
        """
        array_decl
            : ARRAY name array_def
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        array_name = values[1]

        if len(values[2]) == 4:
            lower_bound, upper_bound, check, columns, = values[2]
            return Array(array_name, lower_bound, upper_bound, check, columns, locations=locations)
        else:
            subject_name = values[2][0]
            return SameAsArray(array_name, subject_name, locations=locations)

    def ac_array_def(self, compile_ctx, target, option, values):
        """
        array_def
            : LBRACKET bound TO bound RBRACKET check_subscripts DATA columns_array
            | SAME AS name
        """
        assert(option in range(2))
        if option == 0:
            return values[1], values[3], values[5], values[7],
        elif option == 1:
            subject_name = values[2]
            return subject_name,

    def ac_bound(self, compile_ctx, target, option, values):
        """
        bound
            : PLUS integer
            | MINUS integer
            | integer
            | name
        """
        assert(option in range(4))
        if option in range(2):
            return create_number_node(compile_ctx, values[1], get_token(*values[0]))
        elif option == 2:
            return create_number_node(compile_ctx, values[0])
        else:
            return values[0]

    def ac_check_subscripts(self, compile_ctx, target, option, values):
        """
        check_subscripts
            : CHECK SUBSCRIPTS on_off
            |
        """
        assert(option in range(2))
        if option == 0:
            return get_type(*values[2]) == ON
        elif option == 1:
            return None

    def ac_columns_array(self, compile_ctx, target, option, values):
        """
        columns_array
            : name_list
            | SAME AS name
        """
        if option == 0:
            columns = create_names(compile_ctx, values[0])
            return ArrayColumns(columns, columns[0].locations)
        else:
            subject_name = values[2]
            locations = subject_name.locations
            return SameAsArrayColumns(subject_name, locations=locations)

    def ac_field_decl(self, compile_ctx, target, option, values):
        """
        field_decl
            : field_key field_def_list
        """
        assert(option == 0)
        return get_list_without_sep(values[1])

    def ac_field_def(self, compile_ctx, target, option, values):
        """
        field_def
            : name field_attributes
        """
        assert(option == 0)
        locations = values[0].locations
        field_name = values[0]
        field_attributes = values[1]
        return Field(field_name, field_attributes, locations=locations)

    def ac_field_attributes(self, compile_ctx, target, option, values):
        """
        field_attributes
            : as_picture field_clauses
            | SAME AS name field_clauses
        """
        assert(option in range(2))
        if option == 0:
            locations = values[0].locations
            as_picture = values[0]
            field_clauses = values[1]
            attr = Attributes(as_picture, field_clauses, locations=locations)
            return attr
        else:
            locations = get_locations(compile_ctx, values[0])
            subject_name = values[2]
            field_clauses = values[3]
            attr = SameAsAttributes(subject_name, field_clauses, locations=locations)
            return attr

    def ac_as_picture(self, compile_ctx, target, option, values):
        """
        as_picture
            : AS picture
        """
        assert(option == 0)
        picture = values[1]
        return picture

    def ac_picture(self, compile_ctx, target, option, values):
        """
        picture
            : quoted_string
            | DATE
            | DATE quoted_string
            | DATE mag_name
            | FLOAT
            | FLOAT quoted_string
            | FLOAT mag_name
            | LONG_FLOAT
            | LONG_FLOAT quoted_string
            | LONG_FLOAT mag_name
        """
        assert(option in range(10))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            value = values[0]
            picture = create_picture_node(compile_ctx, value)
        elif option == 1:
            value = None
            picture = DatePicture(value=value, locations=locations)
        elif option in [2, 3]:
            value = create_char_literal_node(compile_ctx, values[1])
            picture = DatePicture(value=value, locations=locations)
        elif option == 4:
            value = None
            picture = FloatPicture(value=value, locations=locations)
        elif option in [5, 6]:
            value = create_char_literal_node(compile_ctx, values[1])
            picture = FloatPicture(value=value, locations=locations)
        elif option == 7:
            value = None
            picture = DoublePicture(value=value, locations=locations)
        elif option in [8, 9]:
            value = create_char_literal_node(compile_ctx, values[1])
            picture = DoublePicture(value=value, locations=locations)
        return picture

    def ac_field_clauses(self, compile_ctx, target, option, values):
        """
        field_clauses
            :
            | field_clauses default_value
            | field_clauses verify_clause
            | field_clauses prompt_error
        """
        assert(option in range(4))
        if option == 0:
            return []
        elif option == 3:
            values[0].extend(values[1])
            return values[0]
        else:
            values[0].append(values[1])
            return values[0]

    def ac_default_value(self, compile_ctx, target, option, values):
        """
        default_value
            : DEFAULT literal
            | DEFAULT concatenated_string
        """
        assert(option in range(2))
        locations = get_locations(compile_ctx, values[0])
        return DefaultValue(values[1], locations=locations)

    def ac_verify_clause(self, compile_ctx, target, option, values):
        """
        verify_clause
            : VERIFY bool_exp
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        return VerifyClause(values[1], locations=locations)

    def ac_prompt_error(self, compile_ctx, target, option, values):
        """
        prompt_error
            : WITH error_clause
            | WITH prompt_clause
            | WITH error_clause AND prompt_clause
            | WITH prompt_clause AND error_clause
        """
        assert(option in range(4))
        if option in range(2):
            return [values[1]]
        else:
            return [values[1], values[3]]

    def ac_error_clause(self, compile_ctx, target, option, values):
        """
        error_clause
            : ERRORS concatenated_string
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        return ErrorClause(values[1], locations=locations)

    def ac_prompt_clause(self, compile_ctx, target, option, values):
        """
        prompt_clause
            : PROMPT concatenated_string
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        return PromptClause(values[1], locations=locations)

    def ac_relation_decl(self, compile_ctx, target, option, values):
        """
        relation_decl
            : RELATION name stored_in relation_def relation_index
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        relation_name = values[1]
        dest = values[2]

        if values[4] is None:
            relation_indexes = []
            index_on_all = False
        else:
            relation_indexes, index_on_all, = values[4]

        if len(values[3]) == 2:
            relation_keys, relation_datas, = values[3]
            return Relation(relation_name, dest, relation_keys, relation_datas, relation_indexes, index_on_all, locations=locations)
        else:
            subject_name = values[3][0]
            return SameAsRelation(relation_name, dest, subject_name, relation_indexes, index_on_all, locations=locations)

    def ac_stored_in(self, compile_ctx, target, option, values):
        """
        stored_in
            : STORED IN quoted_string
            |
        """
        assert(option in range(2))
        if option == 0:
            locations = get_locations(compile_ctx, values[2])
            return String(get_token(*values[2])[1:-1], locations=locations)
        else:
            return None

    def ac_relation_def(self, compile_ctx, target, option, values):
        """
        relation_def
            : IS KEY name_list DATA name_list
            | IS KEY name_list
            | SAME AS name
        """
        assert(option in range(3))
        if option == 0:
            relation_keys = create_names(compile_ctx, values[2])
            relation_datas = create_names(compile_ctx, values[4])
            return relation_keys, relation_datas,
        elif option == 1:
            relation_keys = create_names(compile_ctx, values[2])
            relation_datas = []
            return relation_keys, relation_datas,
        else:
            subject_name = values[2]
            return subject_name,

    def ac_relation_index(self, compile_ctx, target, option, values):
        """
        relation_index
            :
            | INDEX ON ALL
            | INDEX ON name_list
            | INDEX ON indexes_list
        """
        assert(option in range(4))
        if option == 0:
            relation_indexes = []
            index_all = False
        elif option == 1:
            relation_indexes = []
            index_all = True
        elif option == 2:
            index_all = False
            relation_indexes = [[name] for name in create_names(compile_ctx, values[2])]
        else:
            index_all = False
            relation_indexes = [tuple(get_list_without_sep(index)) for index in get_list_without_sep(values[2])]

        return relation_indexes, index_all,

    def ac_bool_exp(self, compile_ctx, target, option, values):
        """
        bool_exp
            : bool_exp OR bool_exp
            | bool_exp OR rel_op arith_exp
            | bool_exp OR arith_exp
            | bool_exp AND bool_exp
            | bool_exp AND rel_op arith_exp
            | bool_exp AND arith_exp
            | bool_exp EQV bool_exp
            | bool_exp XOR bool_exp
            | arith_exp IS picture_ref
            | arith_exp IS NOT picture_ref
            | qualified_name boolean_word
            | qualified_name NOT boolean_word
            | FILE_TOKEN arith_exp EXISTS
            | TEXT arith_exp EXISTS
            | LPAREN bool_exp RPAREN
            | NOT LPAREN bool_exp RPAREN
            | arith_exp rel_op arith_exp
            | boolean_literal
            | flag_name
        """
        assert(option in range(19))
        if option == 0:
            locations = get_locations(compile_ctx, values[1])
            return Or(values[0], values[2], locations=locations)
        elif option == 1:
            if isinstance(values[0], Enclosed):
                values[0] = values[0].left
            locations = get_locations(compile_ctx, values[1])
            if isinstance(values[0], ExtendedComparisonOr):
                assert(len(values[0].exps) > 0)
                left = values[0].exps[0].left
                result = values[0]
            elif isinstance(values[0], (Eq, Ge, Gt, Le, Lt, Ne)):
                left = values[0].left
                result = ExtendedComparisonOr(locations=locations)
                result.add(values[0])
            else:
                e = SyntaxError(150, "An extended comparison must begin with a simple comparison expression", locations[2], locations[0], locations[1])
                raise e
            if get_type(*values[2]) == EQ:
                result.add(Eq(left, values[3], locations=locations))
                return result
            elif get_type(*values[2]) == GE:
                result.add(Ge(left, values[3], locations=locations))
                return result
            elif get_type(*values[2]) == GT:
                result.add(Gt(left, values[3], locations=locations))
                return result
            elif get_type(*values[2]) == LE:
                result.add(Le(left, values[3], locations=locations))
                return result
            elif get_type(*values[2]) == LT:
                result.add(Lt(left, values[3], locations=locations))
                return result
            elif get_type(*values[2]) == NE:
                result.add(Ne(left, values[3], locations=locations))
                return result
            else:
                e = SyntaxError(119, "This reserved word is illegal here. Use one of the following: %s" % (
                    "then"), locations[2], locations[0], locations[1])
                raise e
        elif option == 2:
            if isinstance(values[0], Enclosed):
                values[0] = values[0].left
            locations = get_locations(compile_ctx, values[1])
            if isinstance(values[0], ExtendedComparisonOr):
                assert(len(values[0].exps) > 0)
                exp = copy.copy(values[0].exps[0])
                exp.right = values[2]
                result = values[0]
                result.add(exp)
            elif isinstance(values[0], (Eq, Ge, Gt, Le, Lt, Ne)):
                exp2 = copy.copy(values[0])
                exp2.right = values[2]
                exp1 = values[0]
                result = ExtendedComparisonOr(locations=locations)
                result.add(exp1)
                result.add(exp2)
            elif isinstance(values[0], Enclosed):
                e = SyntaxError(150, "An extended comparison must begin with a simple comparison expression", locations[2], locations[0], locations[1])
                raise e
            else:
                e = SyntaxError(150, "An extended comparison must begin with a simple comparison expression", locations[2], locations[0], locations[1])
                raise e
            return result
        elif option == 3:
            locations = get_locations(compile_ctx, values[1])
            return And(values[0], values[2], locations=locations)
        elif option == 4:
            if isinstance(values[0], Enclosed):
                values[0] = values[0].left
            locations = get_locations(compile_ctx, values[2])
            if isinstance(values[0], ExtendedComparisonAnd):
                assert(len(values[0].exps) > 0)
                left = values[0].exps[0].left
                result = values[0]
            elif isinstance(values[0], (Eq, Ge, Gt, Le, Lt, Ne)):
                left = values[0].left
                result = ExtendedComparisonAnd(locations=locations)
                result.add(values[0])
            else:
                e = SyntaxError(150, "An extended comparison must begin with a simple comparison expression", locations[2], locations[0], locations[1])
                raise e
            if get_type(*values[2]) == EQ:
                result.add(Eq(left, values[3], locations=locations))
                return result
            elif get_type(*values[2]) == GE:
                result.add(Ge(left, values[3], locations=locations))
                return result
            elif get_type(*values[2]) == GT:
                result.add(Gt(left, values[3], locations=locations))
                return result
            elif get_type(*values[2]) == LE:
                result.add(Le(left, values[3], locations=locations))
                return result
            elif get_type(*values[2]) == LT:
                result.add(Lt(left, values[3], locations=locations))
                return result
            elif get_type(*values[2]) == NE:
                result.add(Ne(left, values[3], locations=locations))
                return result
            else:
                e = SyntaxError(150, "An extended comparison must begin with a simple comparison expression", locations[2], locations[0], locations[1])
                raise e
        elif option == 5:
            if isinstance(values[0], Enclosed):
                values[0] = values[0].left
            locations = get_locations(compile_ctx, values[1])
            if isinstance(values[0], ExtendedComparisonAnd):
                assert(len(values[0].exps) > 0)
                exp = copy.copy(values[0].exps[0])
                exp.right = values[2]
                result = values[0]
                result.add(exp)
            elif isinstance(values[0], (Eq, Ge, Gt, Le, Lt, Ne)):
                exp2 = copy.copy(values[0])
                exp2.right = values[2]
                exp1 = values[0]
                result = ExtendedComparisonAnd(locations=locations)
                result.add(exp1)
                result.add(exp2)
            else:
                e = SyntaxError(119, "This reserved word is illegal here. Use one of the following: %s" % (
                    "then"), locations[2], locations[0], locations[1])
                raise e
            return result
        elif option == 6:
            locations = get_locations(compile_ctx, values[1])
            return Eqv(values[0], values[2], locations=locations)
        elif option == 7:
            locations = get_locations(compile_ctx, values[1])
            return Xor(values[0], values[2], locations=locations)
        elif option == 8:
            locations = get_locations(compile_ctx, values[1])
            return Is(values[0], values[2], locations=locations)
        elif option == 9:
            locations = get_locations(compile_ctx, values[1])
            locations_not = get_locations(compile_ctx, values[2])
            return Not(Is(values[0], values[3], locations=locations), locations_not)
        elif option == 10:
            locations = get_locations(compile_ctx, values[1])
            if get_type(*values[1]) == CHANGING:
                return Changing(values[0], locations=locations)
            else:
                return Illegal(values[0], locations=locations)
        elif option == 11:
            locations = get_locations(compile_ctx, values[2])
            locations_not = get_locations(compile_ctx, values[1])
            if get_type(*values[2]) == CHANGING:
                return NotChanging(values[0], locations=locations)
            else:
                return Not(Illegal(values[0], locations=locations), locations_not)
        elif option == 12:
            locations = get_locations(compile_ctx, values[0])
            return FileExists(values[1], locations=locations)
        elif option == 13:
            locations = get_locations(compile_ctx, values[0])
            return TextExists(values[1], locations=locations)
        elif option == 14:
            locations = get_locations(compile_ctx, values[0])
            return Enclosed(values[1], locations=locations)
        elif option == 15:
            locations = get_locations(compile_ctx, values[0])
            return Not(values[2], locations=locations)
        elif option == 16:
            locations = get_locations(compile_ctx, values[1])
            if get_type(*values[1]) == EQ:
                return Eq(values[0], values[2], locations=locations)
            elif get_type(*values[1]) == GE:
                return Ge(values[0], values[2], locations=locations)
            elif get_type(*values[1]) == GT:
                return Gt(values[0], values[2], locations=locations)
            elif get_type(*values[1]) == LE:
                return Le(values[0], values[2], locations=locations)
            elif get_type(*values[1]) == LT:
                return Lt(values[0], values[2], locations=locations)
            elif get_type(*values[1]) == NE:
                return Ne(values[0], values[2], locations=locations)
            else:
                raise print(values[1])

        elif option == 17:
            return create_boolean_node(compile_ctx, values[0])
        elif option == 18:
            return values[0]

    def ac_flag_name(self, compile_ctx, target, option, values):
        """
        flag_name
            : flag_types FLAG_OF qualified_name
        """
        assert(option == 0)
        if isinstance(values[0], Name):
            return FlagName(values[0], values[2])
        else:
            flag_type = get_type(*values[0])
            locations = get_locations(compile_ctx, values[0])
            if flag_type == BLANK:
                return FlagBlank(values[2], locations=locations)
            if flag_type == BLINK:
                return FlagBlink(values[2], locations=locations)
            if flag_type == BOLD:
                return FlagBold(values[2], locations=locations)
            if flag_type == DIM:
                return FlagDim(values[2], locations=locations)
            if flag_type == ENTERED:
                return FlagEntered(values[2], locations=locations)
            if flag_type == INITIAL_TOKEN:
                return FlagInitial(values[2], locations=locations)
            if flag_type == LOW:
                return FlagLow(values[2], locations=locations)
            if flag_type == MINIMUM:
                return FlagMinimun(values[2], locations=locations)
            if flag_type == OPAQUE:
                return FlagOpaque(values[2], locations=locations)
            if flag_type == PROTECTED:
                return FlagProtected(values[2], locations=locations)
            if flag_type == REQUIRED:
                return FlagRequired(values[2], locations=locations)
            if flag_type == REVERSE:
                return FlagReverse(values[2], locations=locations)
            if flag_type == TERMINATE:
                return FlagTerminate(values[2], locations=locations)
            if flag_type == UNDERLINE:
                return FlagUnderline(values[2], locations=locations)
            if flag_type == VALUE:
                return FlagValue(values[2], locations=locations)
            if flag_type == VERIFY:
                return FlagVerify(values[2], locations=locations)

    def ac_picture_ref(self, compile_ctx, target, option, values):
        """
        picture_ref
            : name
            | name LBRACKET array_index RBRACKET
            | name LBRACKET array_index RBRACKET of_op name
            | picture
        """

        assert(option in range(4))
        locations = values[0].locations
        if option == 0:
            if isinstance(values[0], ConstantRef):
                return AsConstant(values[0], locations=locations)
            else:
                return AsId(ReferenceId(values[0]), locations=locations)
        elif option == 1:
            return AsArrayId(ArrayId(values[0], values[2], locations=locations), locations=locations)
        elif option == 2:
            return AsArrayId(ArrayId(values[0], values[2], values[5], locations=locations), locations=locations)
        elif option == 3:
            return AsPicture(values[0], locations=locations)

    def ac_arith_exp(self, compile_ctx, target, option, values):
        """
        arith_exp
            : LPAREN arith_exp RPAREN format_picture
            | data format_picture
            | PLUS arith_exp %prec UNARY
            | MINUS arith_exp %prec UNARY
            | arith_exp POW arith_exp
            | arith_exp STAR arith_exp
            | arith_exp SLASH arith_exp
            | arith_exp DOUBLESLASH arith_exp
            | arith_exp MOD arith_exp
            | arith_exp PLUS arith_exp
            | arith_exp MINUS arith_exp
            | DEFAULT
        """
        assert(option in range(12))
        if option == 0:
            if values[3] is not None:
                values[1].conversion_types.append(values[3])
            return values[1]
        elif option == 1:
            if values[1] is not None:
                values[0].conversion_types.append(values[1])
            return values[0]
        elif option == 2:
            locations = get_locations(compile_ctx, values[0])
            if isinstance(values[1], Numeric):
                return values[1]
            else:
                return Uplus(values[1], locations=locations)
        elif option == 3:
            locations = get_locations(compile_ctx, values[0])
            if isinstance(values[1], (Integer, Decimal)):
                if values[1].value.startswith('-'):
                    value = values[1].value[1:]
                else:
                    value = '-' + values[1].value
                return Integer(value, locations=locations) if isinstance(values[1], Integer) else Decimal(value, locations=locations)
            else:
                return Uminus(values[1], locations=locations)
        elif option == 4:
            locations = get_locations(compile_ctx, values[1])
            return Pow(values[0], values[2], locations=locations)
        elif option == 5:
            locations = get_locations(compile_ctx, values[1])
            return Mul(values[0], values[2], locations=locations)
        elif option == 6:
            locations = get_locations(compile_ctx, values[1])
            return Div(values[0], values[2], locations=locations)
        elif option == 7:
            locations = get_locations(compile_ctx, values[1])
            return FloorDiv(values[0], values[2], locations=locations)
        elif option == 8:
            locations = get_locations(compile_ctx, values[1])
            return Mod(values[0], values[2], locations=locations)
        elif option == 9:
            locations = get_locations(compile_ctx, values[1])
            return Plus(values[0], values[2], locations=locations)
        elif option == 10:
            locations = get_locations(compile_ctx, values[1])
            return Minus(values[0], values[2], locations=locations)
        elif option == 11:
            locations = get_locations(compile_ctx, values[0])
            return Default(locations=locations)

    def ac_data(self, compile_ctx, target, option, values):
        """
        data
            : ident_ref
            | report_arith_item of_name_opt
            | report_char_item of_name_opt
            | mag_function
            | number
            | character_constant
            | qualified_name
            | date_literal
        """
        assert(option in range(8))
        if option == 0:
            return values[0]
        elif option == 1:
            locations = get_locations(compile_ctx, values[0])
            item_type = get_type(*values[0])
            item_name = get_token(*values[0])

            if item_type == BOTTOM_MARGIN:
                return ReportBottomMargin(item_name, values[1], locations=locations)
            if item_type == FOOTING_SIZE:
                return ReportFootingSize(item_name, values[1], locations=locations)
            if item_type == HEADING_SIZE:
                return ReportHeadingSize(item_name, values[1], locations=locations)
            if item_type == LINE_LENGTH:
                return ReportLineLength(item_name, values[1], locations=locations)
            if item_type == LINE_NUM:
                return ReportLineNum(item_name, values[1], locations=locations)
            if item_type == PAGE_NUM:
                return ReportPageNum(item_name, values[1], locations=locations)
            if item_type == PAGE_SIZE:
                return ReportPageSize(item_name, values[1], locations=locations)
            if item_type == TOP_MARGIN:
                return ReportTopMargin(item_name, values[1], locations=locations)

        elif option == 2:
            locations = get_locations(compile_ctx, values[0])
            item_type = get_type(*values[0])
            item_name = get_token(*values[0])

            if item_type == PAGE_TOP:
                return ReportPageTop(item_name, values[1], locations=locations)
            else:
                return ReportPageDivider(item_name, values[1], locations=locations)

        elif option == 3:
            return values[0]
        elif option == 4:
            return create_number_node(compile_ctx, values[0])
        elif option == 5:
            return create_char_literal_node(compile_ctx, values[0])
        elif option == 6:
            return values[0]
        elif option == 7:
            return values[0]

    def ac_literal(self, compile_ctx, target, option, values):
        """
        literal
            : PLUS number
            | MINUS number
            | number
            | char_literal
            | date_literal
        """
        assert(option in range(5))
        if option in (0, 1):
            return create_number_node(compile_ctx, values[1], get_token(*values[0]))
        elif option == 2:
            return create_number_node(compile_ctx, values[0])
        elif option == 3:
            return create_char_literal_node(compile_ctx, values[0])
        else:
            return values[0]

    def ac_date_literal(self, compile_ctx, target, option, values):
        """
        date_literal
            : DATE quoted_string
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[0])
        value = get_token(*values[1])[1:-1]
        return Date(value, locations=locations)

    def ac_concatenated_string(self, compile_ctx, target, option, values):
        """
        concatenated_string
            : concatenated_string PLUS char_literal
            | char_literal
        """
        assert(option in range(2))
        if option == 0:
            if isinstance(values[0], ConcatenatedString):
                concatenated_string = values[0]
            else:
                concatenated_string = ConcatenatedString(values[0])
            concatenated_string.append(create_char_literal_node(compile_ctx, values[2]))
            return concatenated_string
        elif option == 1:
            return create_char_literal_node(compile_ctx, values[0])

    def ac_mag_function(self, compile_ctx, target, option, values):
        """
        mag_function
            : name LPAREN arith_exp_list RPAREN
            | SUBSTR actual_param_opt
            | COUNT actual_param_opt
            | YEAR actual_param_opt
            | MONTH actual_param_opt
            | DAY actual_param_opt
            | CKSUM LPAREN checksum_type COMMA arith_exp RPAREN
            | NEXT_DATE LPAREN week_day COMMA arith_exp RPAREN
            | LARGEST LPAREN qualified_name RPAREN
            | SMALLEST LPAREN qualified_name RPAREN
            | lang_func
        """
        assert(option in range(11))
        if option in range(0, 10):
            if option == 0:
                function_name = values[0]
                locations = function_name.locations
                parameters = get_list_without_sep(values[2])
            elif option in range(1, 6):
                locations = get_locations(compile_ctx, values[0])
                function_name = Name(get_token(*values[0]).lower(), locations=locations)
                parameters = values[1]
            elif option == 6:
                locations = get_locations(compile_ctx, values[0])
                function_name = Name(get_token(*values[0]).lower(), locations=locations)
                parameters = [values[2], values[4]]
            elif option == 7:
                locations = get_locations(compile_ctx, values[0])
                function_name = Name(get_token(*values[0]).lower(), locations=locations)
                weekday = create_weekday(compile_ctx, values[2])
                parameters = [weekday, values[4]]
            elif option in (8, 9):
                locations = get_locations(compile_ctx, values[0])
                function_name = Name(get_token(*values[0]).lower(), locations=locations)
                parameters = [values[2]]

            function_name_str = str(function_name).lower()

            if function_name_str in ('avg', 'sum') or \
                    (function_name_str in ('min', 'max') and len(parameters) == 1) or \
                    (function_name_str == 'count' and len(parameters) == 0):
                return CumulativeFunction(function_name, parameters, locations=locations)

            elif function_name_str in ('r.min', 'r.max', 'r.avg', 'r.sum', 'r.count'):
                return AggregateFunction(function_name, parameters, locations=locations)

            else:
                return CallingFunction(function_name, parameters, locations=locations)
        else:
            return values[0]

    def ac_actual_param_opt(self, compile_ctx, target, option, values):
        """
        actual_param_opt
            : LPAREN arith_exp_list RPAREN
            |
        """
        assert(option in range(2))
        if option == 0:
            parameters = get_list_without_sep(values[1])
        else:
            parameters = []

        return parameters

    def ac_lang_func(self, compile_ctx, target, option, values):
        """
        lang_func
            : DATE LANGUAGE
            | DIGIT SEPARATOR
            | USERS LANGUAGE
        """
        assert(option in range(3))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            return DateLanguage(locations=locations)
        elif option == 1:
            return DigitSeparator(locations=locations)
        elif option == 2:
            return UsersLanguage(locations=locations)

    def ac_implicit_select(self, compile_ctx, target, option, values):
        """
        implicit_select
            : name LPAREN name via_clause RPAREN
        """
        assert(option == 0)
        locations = get_locations(compile_ctx, values[1])
        return ImplicitSelect(values[0], values[2], values[3], locations=locations)

    def ac_ident_ref(self, compile_ctx, target, option, values):
        """
        ident_ref
            : name LPAREN arith_exp_list_opt RPAREN
            | implicit_select
        """
        assert(option in range(2))
        if option == 0:
            locations = values[0].locations
            function_name = values[0]
            if values[2] is None:
                parameters = []
            else:
                parameters = get_list_without_sep(values[2])
            return CallingFunction(function_name, parameters, locations=locations)
        else:
            return values[0]

    def ac_qualified_name(self, compile_ctx, target, option, values):
        """
        qualified_name
            : name
            | name LBRACKET array_index RBRACKET of_op name
            | name LBRACKET array_index RBRACKET
            | name of_op name
            | name of_op PROCEDURE
        """
        assert(option in range(5))
        locations = values[0].locations
        if option == 0:
            return create_id_or_calling_function(compile_ctx, self.function_list, values[0], locations=locations)
        elif option == 1:
            return ArrayId(values[0], values[2], values[5], locations=locations)
        elif option == 2:
            return ArrayId(values[0], values[2], locations=locations)
        elif option == 3:
            return Id(values[0], values[2], locations=locations)
        elif option == 4:
            return Id(values[0], Name("procedure"), locations=locations)

    def ac_array_index(self, compile_ctx, target, option, values):
        """
        array_index
            : ALL
            | arith_exp
            | arith_exp TO arith_exp
        """
        assert(option in range(3))
        if option == 0:
            locations = get_locations(compile_ctx, values[0])
            return ArrayIndexAll(locations=locations)
        elif option == 1:
            return ArrayIndex(values[0], values[0].locations)
        elif option == 2:
            locations = get_locations(compile_ctx, values[1])
            return ArrayIndexTo(values[0], values[2], locations=locations)

    def ac_via_clause(self, compile_ctx, target, option, values):
        """
        via_clause
            : VIA KEY
            | VIA LPAREN key_value_list RPAREN
            | VIA key_value
        """
        assert(option in range(3))
        locations = get_locations(compile_ctx, values[0])
        if option == 0:
            return ViaKeyClause(locations=locations)
        elif option == 1:
            return ViaClause(get_list_without_sep(values[2]), locations=locations)
        elif option == 2:
            return ViaClause([values[1]], locations=locations)

    def ac_key_value(self, compile_ctx, target, option, values):
        """
        key_value
            : ident_ref
            | name rel_op arith_exp
            | qualified_name
        """
        assert(option == 1)
        idf = ViaFieldId(values[0])
        locations = get_locations(compile_ctx, values[1])
        if get_type(*values[1]) == EQ:
            return Eq(idf, values[2], locations=locations)
        elif get_type(*values[1]) == GE:
            return Ge(idf, values[2], locations=locations)
        elif get_type(*values[1]) == GT:
            return Gt(idf, values[2], locations=locations)
        elif get_type(*values[1]) == LE:
            return Le(idf, values[2], locations=locations)
        elif get_type(*values[1]) == LT:
            return Lt(idf, values[2], locations=locations)
        elif get_type(*values[1]) == NE:
            return Ne(idf, values[2], locations=locations)

    def ac_name(self, compile_ctx, target, option, values):
        """
        name
            : mag_name
        """
        assert(option == 0)
        name_value = get_token(*values[0]).lower()
        locations = get_locations(compile_ctx, values[0])
        name = Name(name_value, locations=locations)
        if str(name) in self.constant_dict:
            return ConstantRef(name, locations=locations)
        else:
            return name


def get_list_without_sep(l):
    return [elt for (_, elt) in l]


def create_number_node(compile_ctx, value, sign=''):
    locations = get_locations(compile_ctx, value)
    if get_type(*value) == integer:
        return Integer(sign + get_token(*value), locations=locations)
    elif get_type(*value) == dec_number:
        return Decimal(sign + get_token(*value), locations=locations)
    elif get_type(*value) == short_float:
        return Float(sign + get_token(*value), locations=locations)
    elif get_type(*value) == long_float:
        return Double(sign + get_token(*value), locations=locations)
    else:
        raise


def create_stmts_node_from_list(*stmts):
    if len(stmts) == 1 \
            and isinstance(stmts[0], Stmts):
        return stmts[0]
    return Stmts(stmts)


def create_char_literal_node(compile_ctx, value):
    """
    char_literal
        : character_constant
        |name

    character_constant
        : quoted_string
        | at_integer
        | AT_CR
        | AT_FF
    """
    if isinstance(value, ConstantRef):
        return value
    elif isinstance(value, Name):
        return  Id(value)
    elif get_type(*value) == quoted_string:
        locations = get_locations(compile_ctx, value)
        string_value = get_token(*value)[1:-1]
        return String(string_value, locations=locations)
    else:
        locations = get_locations(compile_ctx, value)
        return ControlCharacter(get_token(*value), locations=locations)


def create_id_or_calling_function(compile_ctx, function_list, value, locations):
    if isinstance(value, ConstantRef):
        return value 
    if function_list and str(value) == function_list[-1]:
        return ReturningFunction(value, locations=locations)
    elif str(value) in BUILTIN_LIST or str(value) in function_list:
        function_name = value
        parameters = []
        return CallingFunction(function_name, parameters, locations=locations)
    else:
        return Id(value, locations=locations)


def create_boolean_node(compile_ctx, value):
    locations = get_locations(compile_ctx, value)
    return Boolean(get_token(*value), locations=locations)


def create_picture_node(compile_ctx, value):
    locations = get_locations(compile_ctx, value)
    picture_value = create_char_literal_node(compile_ctx, value)
    picture = get_token(*value)[1:-1]

    if picture.strip().lower().find('c') > -1 and picture.strip().lower().find('cr') == -1:
        return StringPicture(value=picture_value, locations=locations)

    elif picture.upper().find('LONG.FLOAT') > -1:
        return DoublePicture(value=picture_value, locations=locations)

    elif picture.upper().find('FLOAT') > -1:
        return FloatPicture(value=picture_value, locations=locations)

    elif '.' in picture or 'v' in picture.lower():
        return DecimalPicture(value=picture_value, locations=locations)

    elif not picture:
        e = SyntaxError(330, "You must specify at least one digit", locations[2], locations[0], locations[1])
        raise e

    else:
        return IntegerPicture(value=picture_value, locations=locations)


def create_names(compile_ctx, name_list):
    return [name for name in get_list_without_sep(name_list)]


def create_weekday(compile_ctx, value):
    locations = get_locations(compile_ctx, value)
    day_of_week = get_type(*value)
    if day_of_week == SUNDAY:
        return Sunday(locations=locations)
    elif day_of_week == MONDAY:
        return Monday(locations=locations)
    elif day_of_week == TUESDAY:
        return Tuesday(locations=locations)
    elif day_of_week == WEDNESDAY:
        return Wednesday(locations=locations)
    elif day_of_week == THURSDAY:
        return Thursday(locations=locations)
    elif day_of_week == FRIDAY:
        return Friday(locations=locations)
    elif day_of_week == SATURDAY:
        return Saturday(locations=locations)


def get_tok_infos(typ, token, offset, lineno, col, path=None, macros=[]):
    return typ, token, offset, lineno, col, path, macros


def get_locations(compile_ctx, value):
    _, _, _, lineno, col, path_idx, macros = get_tok_infos(*value)
    try:
        path = compile_ctx.files[path_idx]
    except KeyError:
        path = "<String>"
    return lineno, col, path, macros


def eval_round_spec(round_spec, locations):
    conversion_type = echo = None
    if len(round_spec) == 1:
        if isinstance(round_spec[0], ConversionType):
            conversion_type = round_spec[0]
        else:
            echo = round_spec[0]
    elif len(round_spec) == 2:
        if isinstance(round_spec[0], ConversionType) and isinstance(round_spec[1], ConversionType):
            e = SyntaxError(276, "ROUNDED is inconsistent with a previous clause in this statement", locations[
                            2], locations[0], locations[1])
            raise e

        if isinstance(round_spec[0], Echo) and isinstance(round_spec[1], Echo):
            e = SyntaxError(
                277, "Only one ECHO clause, please", locations[2], locations[0], locations[1])
            raise e

        if isinstance(round_spec[0], ConversionType):
            conversion_type = round_spec[0]
        else:
            echo = round_spec[0]

        if isinstance(round_spec[1], ConversionType):
            conversion_type = round_spec[1]
        else:
            echo = round_spec[1]

    elif len(round_spec) > 2:
        e = SyntaxError(
            277, "Only one ECHO clause, please", locations[2], locations[0], locations[1])
        raise e

    return conversion_type, echo,
