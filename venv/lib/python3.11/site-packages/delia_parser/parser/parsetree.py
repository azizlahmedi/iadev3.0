# -*- coding: utf-8 -*-

from delia_tokenizer import *
import re
import logging

"""
    Delia parse tree node definitions
"""


class TokenNode():

    def __init__(self, token_infos):
        self._token_infos = token_infos

    def __get_type(self):
        return get_type(*self._token_infos)
    type = property(__get_type)

    def __get_value(self):
        return get_token(*self._token_infos)
    value = property(__get_value)

    def __get_path(self):
        return get_path(*self._token_infos)
    path = property(__get_path)

    def __get_lineno(self):
        return get_lineno(*self._token_infos)
    lineno = property(__get_lineno)

    def __get_column(self):
        return get_column(*self._token_infos)
    column = property(__get_lineno)

    def __get_offset(self):
        return get_offset(*self._token_infos)
    offset = property(__get_offset)

    def __get_name(self):
        return get_tok_name(*self._token_infos)
    name = property(__get_name)


def node_wrap(obj):
    # TODO try to cast to the most appropriate node class
    if isinstance(obj, tuple):
        return TokenNode(obj)
    elif isinstance(obj, Node) or isinstance(obj, list):
        return obj
    elif obj is None:
        return None
    else:
        raise


def flatten(seq):
    if seq is None:
        return []
    if isinstance(seq, tuple):
        return [seq]
    l = []
    for elt in seq:
        if elt is None:
            continue
        if isinstance(elt, list) and not isinstance(elt, ListNode):
            for elt2 in flatten(elt):
                l.append(elt2)
        else:
            l.append(elt)
    return l


def flatten_nodes(seq):
    return [n for n in flatten(seq) if isinstance(n, Node)]


def flatten_token(token_infos):
    return (("t", get_type(*token_infos)), ("v", get_token(*token_infos)),
            ("o", get_offset(*token_infos)), ("l", get_lineno(*token_infos)),
            ("s", get_path(*token_infos)))


class Node:

    """
    Abstract base class for parse tree nodes.
    This class is the ancestor of all the Node classes.
    """

    def get_children(self):
        """
        :return: list children.
        :rtype: list 
        """
        pass  # implemented by subclasses

    def get_child_nodes(self):
        """
        :return: Return only children type Node.
        :rtype: list 
        """
        pass  # implemented by subclasses

    def __iter__(self):
        for n in self.get_child_nodes():
            yield node_wrap(n)

    def xml_serialize(self, out):
        """ print out in xml_format this node and all siblings """
        pass  # implemented by subclasses

    def __get_path(self):
        pass
    path = property(__get_path)

    def __get_lineno(self):
        pass
    lineno = property(__get_lineno)

    def __get_offset(self):
        pass
    offset = property(__get_offset)

    def find(self, pattern):
        pass  # implemented by subclasses

    def validate(self, scopes):
        """check the types of then node and symbol-table generator"""
        pass  # implemented by subclasses

    def dump(self, indent=0):
        print("<" + self.__class__.__name__ + ">")
        for node in self:
            if node is not None:
                node.dump()
            else:
                print("<none/>")
        print("</" + self.__class__.__name__ + ">")


class EmptyNode(Node):
    pass


class BaseParseTree(Node):

    """
      This class contains the basic support for an AST.
      Most people will create parse tree that are subclasses of
      BaseParseTree.
    """
    _name = None
    _comments = None

    def __init__(self, target, option, values):
        self.nodes = values
        # self.names=names

    def get_children(self):
        return self.nodes

    def get_child_nodes(self):
        return flatten_nodes(self.nodes)

    def __get_node_name(self):
        if self._name is None:
            return self.__class__.__name__
        else:
            return self._name
    node_name = property(__get_node_name)

    def __get_path(self):
        for child in self.get_children():
            child = node_wrap(child)
            if child is not None and isinstance(child, TokenNode):
                return child.path
        for child in self.get_children():
            child = node_wrap(child)
            if child is not None and not isinstance(child, TokenNode) and isinstance(child, Node):
                ret = child.path
                if ret is not None:
                    return ret
        return None
    path = property(__get_path)

    def __get_lineno(self):
        for child in self.get_children():
            child = node_wrap(child)
            if child is not None and isinstance(child, TokenNode):
                return child.lineno
        for child in self.get_children():
            child = node_wrap(child)
            if child is not None and not isinstance(child, TokenNode) and isinstance(child, Node):
                ret = child.lineno
                if ret is not None:
                    return ret
        return None
    lineno = property(__get_lineno)

    def __get_offset(self):
        for child in self.get_children():
            child = node_wrap(child)
            if child is not None and isinstance(child, TokenNode):
                return child.offset
        for child in self.get_children():
            child = node_wrap(child)
            if child is not None and not isinstance(child, TokenNode) and isinstance(child, Node):
                ret = child.offset
                if ret is not None:
                    return ret
        return None
    offset = property(__get_offset)

    def set_comments(self, comments):
        self._comments = comments

    def get_comments(self):
        return self._comments

    def find(self, pattern):
        if re.match(pattern, self.node_name):
            yield self
        for child in self:
            if child is not None:
                for ret in child.find(pattern):
                    yield ret

    def encode(self, text):
        code = {'&': "&amp;", '<': "&lt;", '>': "&gt;",
                '"': "&quot;", '\'': "&apos;", '\f': "FF(^L)"}
        n = ""
        for i in range(len(text)):
            if text[i] in code:
                n += code[text[i]]
            else:
                n += text[i]
        return n

    def xml_serialize_root_open(self, out, name):
        out.write("<" + name + ">\n")

    def xml_serialize_root_close(self, out, name):
        out.write("</" + name + ">\n")

    def xml_serialize_comments(self, out):
        for comment in self.get_comments():
            node_wrap(comment).xml_serialize(out)

    def xml_serialize(self, out):
        """ print out this node and all siblings """
        if self.get_comments() is not None:
            self.xml_serialize_comments(out)
        self.xml_serialize_root_open(out, self.node_name)
        try:
            for child in flatten(self.get_children()):
                if child is not None:
                    node = node_wrap(child)
                    node.xml_serialize(out)
        except:
            print(self)
            raise
        # print end tag
        self.xml_serialize_root_close(out, self.node_name)

    def get_source_comments(self, out):
        for comment in self.get_comments():
            node_wrap(comment).get_source(out)

    def get_source(self, out):
        """ print out this node and all siblings """
        # if self.get_comments() is not None:
        #    self.get_source_comments(out)
        try:
            for child in flatten(self.get_children()):
                if child is not None:
                    node = node_wrap(child)
                    node.get_source(out)
        except:
            print(self)
            raise

    def __repr__(self):
        if self.__class__.__name__ == 'BaseParseTree':
            return "<%s:%s>" % (self.__class__.__name__, self.node_name)
        else:
            return "<%s>" % self.node_name


class TokenNode(BaseParseTree):

    def __init__(self, token_infos):
        self._token_infos = token_infos
        self._name = get_tok_name(*self._token_infos)

    def get_children(self):
        return []

    def get_child_nodes(self):
        return []

    def __get_type(self):
        return get_type(*self._token_infos)
    type = property(__get_type)

    def __get_value(self):
        return get_token(*self._token_infos)
    value = property(__get_value)

    def __get_path(self):
        return get_path(*self._token_infos)
    path = property(__get_path)

    def __get_lineno(self):
        return get_lineno(*self._token_infos)
    lineno = property(__get_lineno)

    def __get_offset(self):
        return get_offset(*self._token_infos)
    offset = property(__get_offset)

    def xml_serialize(self, out):
        buf = "<" + self.node_name + " "
        for (attr, val) in flatten_token(self._token_infos):
            buf += attr + "=\"" + self.encode(str(val)) + "\" "
        buf += "/>\n"
        out.write(buf)

    def get_source(self, out):
        out.write(self.value + " ")


class ListNode(list, BaseParseTree):

    def __init__(self, compile_ctx, name):
        self._name = name

    def __iter__(self):
        for n in list.__iter__(self):
            yield node_wrap(n)

    def get_children(self):
        return [n for n in list.__iter__(self)]

    def get_child_nodes(self):
        return self


class ListNodeWithSep(ListNode):

    def __iter__(self):
        for (sep, n) in list.__iter__(self):
            # print "ListNodeWithSep.n", n
            yield node_wrap(n)


class Root(BaseParseTree):

    def __init__(self, compile_ctx):
        self.procedure = None
        self.schema = None

    def set_procedure(self, procedure):
        self.procedure = procedure

    def set_schema(self, schema):
        self.schema = schema

    def get_children(self):
        children = []
        if self.schema is not None:
            children.append(self.schema)
        if self.procedure is not None:
            children.append(self.procedure)
        return children

    def get_child_nodes(self):
        children = []
        if self.schema is not None:
            children.append(self.schema)
        if self.procedure is not None:
            children.append(self.procedure)
        return children

    def xml_serialize(self, out):
        out.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n")
        out.write("<Delia>\n")
        out.write("<AST_Adl version=\"0.4.0\">\n")
        try:
            for child in self:
                child.xml_serialize(out)
        except:
            print(child)
            raise
        out.write("</AST_Adl>\n")
        out.write("</Delia>\n")

    def __repr__(self):
        return "%s %s" % (repr(self.schema), repr(self.procedure))
