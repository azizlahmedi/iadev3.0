# -*- coding:utf-8 -*-
from delia_commons.errors import ErrorCode
from delia_parser import ast, types


class Function:

    def visit_RunStmt(self, node):
        self.check_locale_name(node.name)

        def check_params(params):
            self.visit(params)
            for param in params:
                if param.definition and not isinstance(param.type, (types.Numeric, types.Date, types.String)):
                    self.add_error(ErrorCode.INVALID_DEFINITION_TYPE, param, name=param.name, kind='FIELD')

        check_params(node.calling_parameters)
        check_params(node.accepting_parameters)
        self.check_accepting_parameter_duplicate(node, node.accepting_parameters)

    def visit_FunctionStmt(self, node):

        function_definition = node.name.definition
        if not function_definition:
            self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, node.name, name=node.name)
        elif not isinstance(function_definition, ast.Function):
            self.add_error(ErrorCode.INVALID_DEFINITION_TYPE, node.name, name=node.name, kind='FUNCTION')
        elif type(function_definition) is ast.Function and function_definition not in self.functions:    # exclude the FLIs
            self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, node.name, name=node.name)
        else:

            calling_parameters = node.calling_parameters
            accepting_parameters = node.accepting_parameters

            self.visit(calling_parameters)
            self.visit(accepting_parameters)

            receiving_parameters = function_definition.receiving_parameters
            returning_parameters = function_definition.returning_parameters
            self.check_parameters_match(node, receiving_parameters, calling_parameters)
            self.check_parameters_match(node, returning_parameters, accepting_parameters)
            self.check_accepting_parameter_duplicate(node, accepting_parameters)

    def visit_Return(self, node):

        using_clauses = node.using_clauses

        self.visit(using_clauses)

        procedure_parameters = []
        for param in node.returning_parameters:
            param_definition = param.definition
            if not param_definition:
                return
            procedure_parameters.append(param_definition.name)

        for using_clause in using_clauses:
            param = using_clause.parametre
            if param.definition and param not in procedure_parameters:
                self.add_error(ErrorCode.USING_CLAUSE_IS_NOT_FIELD_OF_RETURNING_CLAUSE, param, name=param)

    def check_parameters(self, node, params):
        for param in params:
            self.visit(param)
            if not param.definition:
                self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, param, name=param)
            elif not isinstance(param.definition, ast.Field):
                self.add_error(ErrorCode.INVALID_DEFINITION_TYPE, param, name=param, kind='FIELD')
        if len(params) > len(set(params)):
            self.add_error(ErrorCode.FUNCTION_MULTIPLE_PARAMETER_LIST, node, function_name=node.name)

    def check_accepting_parameter_duplicate(self, node, accepting_params):
        for param in accepting_params:
            if isinstance(param.definition, ast.Field) and accepting_params.count(param) > 1:
                self.add_warn(ErrorCode.FUNCTION_DUPLICATED_ACCEPTING_PARAMETERS, node, field_name=param.name, function=node.name)

    def check_parameters_match(self, node, expected_params, received_params):

        function_name = node.name

        if expected_params:
            nb_expected_params = len(expected_params)
        else:
            nb_expected_params = 0

        if received_params:
            nb_received_params = len(received_params)
        else:
            nb_received_params = 0

        if nb_expected_params != nb_received_params:
            self.add_error(ErrorCode.FUNCTION_INVALID_PARAMETERS_COUNT, node,
                           function_name=function_name, nb_param_expected=nb_expected_params, nb_param_received=nb_received_params)
        else:
            for i in range(nb_expected_params):

                expected_param = expected_params[i]
                received_param = received_params[i]

                expected_type = expected_param.type
                received_type = received_param.type

                if expected_type is None or received_type is None:
                    continue

                if not isinstance(expected_type, (types.Numeric, types.String, types.Date)) or \
                        not isinstance(received_type, (types.Numeric, types.String, types.Date)):
                    continue

                if not ((isinstance(expected_type, types.Numeric) and isinstance(received_type, types.Numeric)) or
                        (isinstance(expected_type, types.Date) and isinstance(received_type, types.Date)) or
                        (isinstance(expected_type, types.String) and isinstance(received_type, types.String))):

                    self.add_error(ErrorCode.FUNCTION_PARAMETER_INCOMPATIBLE_DATA_TYPE, received_param,
                                   function_name=function_name,
                                   parameter_number=self.stringify_parameter_count(i+1),
                                   parameter_type='<{}>'.format(expected_type.__class__.__name__))

    def visit_Procedure(self, node):
        self.check_name(node.name)
        if self.proc_name and str(node.name).lower() != self.proc_name.lower():
            self.add_error(ErrorCode.PROCEDURE_NAME_UNMATCH_NAME_COMPILE, node.name, name=node.name)

        self.check_parameters(node, node.receiving_parameters)
        self.check_parameters(node, node.returning_parameters)
        self.visit(node.decls)
        self.visit(node.stmts)

    def visit_Function(self, node):

        self.functions.append(node)

        if not node.name == "floordiv":

            self.check_name(node.name)

            if not node.used:
                return

            self.visit(node.attributes)

            self.check_parameters(node, node.receiving_parameters)
            self.check_parameters(node, node.returning_parameters)

            self.in_function = node
            self.visit(node.stmts)
            self.in_function = False

    def visit_FunctionKey(self, node):

        self.check_name(node.name)

        if not node.used:
            return

        self.visit(node.sequence)

        if node.is_globally:
            self.visit(node.stmts)

    def function_key_local_stmt(self, node):
        self.visit(node.stmts)

    def visit_FLI(self, node):

        self.check_name(node.name)

        function_name = str(node.name).lower()
        if function_name == "get.nom.champ":
            self.add_warn(ErrorCode.DEPRECATED, node, reason="'GET.NOM.CHAMP' is now a builtin function.")

        if not node.used:
            return

        self.visit(node.attributes)

        self.check_parameters(node, node.receiving_parameters)
        self.check_parameters(node, node.returning_parameters)

        self.visit(node.file_spec)

        file_value_definition = node.file_spec.value.definition
        file_value_type = node.file_spec.value.type

        if file_value_definition and (not isinstance(file_value_definition, (ast.Literal, ast.Constant)) or
                                      file_value_type is not types.String()):
            self.add_error(ErrorCode.FUNCTION_FLI_IN_CONSTANT_STRING, node, function_name=node.name)

    def visit_UsingClause(self, node):
        self.visit(node.data_expression)
        self.visit(node.parametre)

        param_definition = node.parametre.definition
        if not param_definition:
            self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, node.parametre, name=node.parametre)
        else:
            type_expr = node.data_expression.type
            type_param = node.parametre.type

            if type_expr is not None and type_param is not None:

                if not ((isinstance(type_expr, types.Numeric) and isinstance(type_param, types.Numeric)) or
                        (isinstance(type_expr, types.Date) and isinstance(type_param, types.Date)) or
                        (isinstance(type_expr, types.String) and isinstance(type_param, types.String))):

                    self.add_error(ErrorCode.USING_CLAUSE_INCOMPATIBLE_EXPRESSION_DATA_TYPE,
                                   node,
                                   name=node.parametre,
                                   expr_type=type_expr.__class__.__name__,
                                   param_type=type_param.__class__.__name__)
