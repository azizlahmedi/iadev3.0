#! /usr/bin/env python
# -*- coding:utf-8 -*-
import collections

from delia_commons.errors import ErrorCode
from delia_parser import ast, types, scope
from delia_parser.validate.convert_type import convert_type
from delia_parser.validate.queries.foreach import Foreach
from delia_parser.validate.queries.select import Select
from delia_parser.validate.queries.delete import Delete
from delia_parser.validate.queries.insert import Insert
from delia_parser.validate.queries.alter import Alter


class Query(Foreach,
            Select,
            Delete,
            Insert,
            Alter):

    def visit_QualifiedRelationAlias(self, node):

        self.visit(node.relation_name)
        relation_definition = node.relation_name.definition

        if not relation_definition:
            self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, node.relation_name, name=node.relation_name)
            return
        elif isinstance(relation_definition, ast.Source) and (node.via_clause or node.where_clause):
            self.add_error(ErrorCode.WHERE_OR_VIA_CLAUSE_REFERING_TO_SOURCE, node.relation_name, name=node.relation_name)

        self.visit(node.via_clause)
        if node.original_via_clause and node.original_via_clause.lkey_value:
            key_stack = []
            for via_key_ind, via_key in enumerate(node.original_via_clause.lkey_value):
                if isinstance(via_key, ast.Id):
                    via_key_name = via_key.name
                elif isinstance(via_key, ast.Rel):
                    if not isinstance(via_key, (ast.Eq, ast.Gt, ast.Ge)):
                        self.add_error(ErrorCode.INVALID_OPERATOR, node.relation_name)
                    via_key_name = via_key.left.name
                else:
                    continue
                if via_key_name in key_stack:
                    self.add_error(ErrorCode.VIA_CLAUSE_DUPLICATED_FIELD_KEY, node.relation_name, field_name=str(via_key))
                elif via_key_ind < len(relation_definition.keys):
                    relation_key = relation_definition.keys[via_key_ind]
                    if via_key_name not in relation_definition.keys:
                        self.add_error(ErrorCode.VIA_CLAUSE_WRONG_KEY_FIELD, node.relation_name, field_name=via_key_name)
                    elif via_key_name != relation_key:
                        self.add_error(ErrorCode.VIA_CLAUSE_WRONG_ORDER_KEYS, node.relation_name, field_name=via_key_name)
                else:
                    self.add_error(ErrorCode.VIA_CLAUSE_WRONG_KEY_FIELD, node.relation_name, field_name=str(via_key))
                key_stack.append(via_key_name)

        if node.via_clause and not isinstance(node.via_clause, ast.ViaKeyClause):

            for value in node.via_clause.lkey_value:

                if isinstance(value, ast.Rel):
                    field = value.left.name

                elif isinstance(value, ast.ImplicitSelect):
                    field = value.field_name

                elif isinstance(value, ast.Id):
                    field = value.name

                # Not the same behavior as MAGNUM, VIA on DATA accepted.
                if relation_definition and field not in relation_definition.columns:
                    self.add_error(ErrorCode.FIELD_WRONG_USAGE, value,
                                   name=field, relation_name=relation_definition.name)

        self.visit(node.where_clause)

        if node.where_clause:
            count = self.count_expressions(node.where_clause.clause)
            if count > self.MAXIMUM_EXPRESSIONS:
                self.add_warn(ErrorCode.MAXIMUM_EXPRESSIONS_REACHED,
                              node.where_clause, number=count, max=self.MAXIMUM_EXPRESSIONS)

        self.visit(node.sorted_clause)

        sorted_fields_and_scope = [(item.field.name, item.field.scope) for item in node.sort_list if isinstance(item.field.definition, ast.Field)]
        duplicates_sorted_fields = [item for item, count in collections.Counter(sorted_fields_and_scope).items() if count > 1]
        for field_name, scope in duplicates_sorted_fields:
            self.add_error(ErrorCode.SORTED_CLAUSE_REDEFINITION, node.sorted_clause,
                           name=field_name, relation_name=scope.name)

        self.visit(node.join_clause_list)

    def visit_ViaClause(self, node):
        self.visit(node.lkey_value)

    def visit_ViaKeyClause(self, node):
        self.visit(node.lkey_value)

    def visit_Changing(self, node):

        field = node.left
        field_definition = field.definition

        self.visit(field)

        if field_definition:
            if not isinstance(field_definition, ast.Field):
                self.add_error(ErrorCode.INVALID_DEFINITION_TYPE, field, name=field.name, kind="FIELD")
            elif not (isinstance(field.scope, scope.QueryScope) and isinstance(field.scope.node, ast.For)):
                self.add_error(ErrorCode.CHANGING_INVALID_SCOPE, node)
            else:
                for_node = field.scope.node
                relation_name = for_node.relation_name
                rel_definition = relation_name.definition

                if isinstance(rel_definition, ast.Relation):

                    qualified_rel_alias = for_node.qualified_rel_alias
                    sort_list = qualified_rel_alias.sort_list
                    grouped_clause = qualified_rel_alias.grouped_clause
                    join_clause_list = qualified_rel_alias.join_clause_list
                    sorted_fields = [item.field.name for item in sort_list]

                    if join_clause_list:
                        self.add_error(ErrorCode.CHANGING_ON_FIELD_FROM_JOIN, node, field_name=field.name)

                    if grouped_clause:
                        self.add_error(ErrorCode.CHANGING_ON_FIELD_FROM_GROUP, node, field_name=field.name)

                    if field.name in rel_definition.datas and field.name not in sorted_fields:
                        self.add_error(ErrorCode.CHANGING_ON_NON_SORTED_FIELD, node, field_name=field.name)

    def visit_NotChanging(self, node):
        self.visit_Changing(node)

    def visit_SortItem(self, node):
        field = node.field
        field_definition = field.definition
        if field_definition:
            if not isinstance(field_definition, ast.Field):
                self.add_error(ErrorCode.INVALID_DEFINITION_TYPE, field, name=field.name, kind="FIELD")
        self.visit(field)

    def visit_GroupedClause(self, node):
        group_list = node.group_list
        self.visit(group_list)
        for field in group_list:
            field_definition = field.definition
            if field_definition:
                if not isinstance(field_definition, ast.Field):
                    self.add_error(ErrorCode.INVALID_DEFINITION_TYPE, field, name=field.name, kind="FIELD")

    def visit_JoinClause(self, node):
        relation_name = node.relation_name
        rel_definition = relation_name.definition
        clause = node.clause
        join_expressions = node.join_expressions

        if relation_name not in self.names:
            self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, node.relation_name, name=node.relation_name)
        elif rel_definition and not isinstance(rel_definition, ast.Relation):
            self.add_error(ErrorCode.INVALID_DEFINITION_TYPE, relation_name, name=relation_name, kind="RELATION")

        self.visit(clause)

        if not join_expressions:
            self.add_error(ErrorCode.JOIN_CLAUSE_UNSUPPORTED, clause, name=relation_name)

    def visit_InnerJoinClause(self, node):
        self.visit_JoinClause(node)

    def visit_LeftOuterJoinClause(self, node):
        self.visit_JoinClause(node)

    @convert_type
    def visit_AggregateFunction(self, node):

        function_name = str(node.name).upper()

        parameters = node.parameters
        for param in parameters:
            self.visit(param)

        if len(parameters) != 1:
            self.add_error(ErrorCode.FUNCTION_INVALID_PARAMETERS_COUNT, node,
                           function_name=function_name,
                           nb_param_expected=1,
                           nb_param_received=len(parameters))
        else:
            param = parameters[0]
            param_definition = param.definition
            if param_definition and not isinstance(param_definition, ast.Field):
                self.add_error(ErrorCode.INVALID_DEFINITION_TYPE, param, name=param.name, kind="FIELD")
            else:

                if function_name in ("R.SUM", "R.AVG") and not isinstance(param.type, types.Numeric):
                    self.add_error(ErrorCode.FUNCTION_PARAMETER_INCOMPATIBLE_DATA_TYPE, param,
                                   function_name=function_name,
                                   parameter_number="1st",
                                   parameter_type="<Numeric>")
                if function_name in ("R.MAX", "R.MIN") and not isinstance(param.type, (types.Numeric, types.Date)):
                    self.add_error(ErrorCode.FUNCTION_PARAMETER_INCOMPATIBLE_DATA_TYPE, param,
                                   function_name=function_name,
                                   parameter_number="1st",
                                   parameter_type="<Numeric>")

                param_scope = param.scope
                if not isinstance(param_scope, scope.QueryScope):
                    self.add_error(ErrorCode.AGGREGATE_FUNCTION_NOT_IN_GROUPED_QUERY, param, name=param.name)
                else:
                    scope_node = param_scope.node
                    qualified_rel_alias = scope_node.qualified_rel_alias
                    grouped_clause = qualified_rel_alias.grouped_clause
                    if not grouped_clause:
                        self.add_error(ErrorCode.AGGREGATE_FUNCTION_NOT_IN_GROUPED_QUERY, param, name=param.name)

    def validate_join_clause(self, node):
        qualified_rel_alias = node.qualified_rel_alias
        join_clause_list = qualified_rel_alias.join_clause_list
        sorted_clause = qualified_rel_alias.sorted_clause
        sort_list = qualified_rel_alias.sort_list
        is_where_optimized = qualified_rel_alias.is_where_optimized
        via_clause = qualified_rel_alias.via_clause
        where_clause = qualified_rel_alias.where_clause

        relations = [node.relation_name]
        if node.alias_name:
            aliases = [node.alias_name]
        else:
            aliases = []

        if join_clause_list:

            if isinstance(sorted_clause, ast.SortedOnClause):
                if any([item for item in sort_list if item.field.of_name is None]):
                    self.add_error(ErrorCode.SORTED_CLAUSE_WITHOUT_ON_OR_OF_IN_JOIN, sorted_clause)
            elif isinstance(sorted_clause, ast.SortedClause):
                self.add_error(ErrorCode.SORTED_CLAUSE_WITHOUT_ON_OR_OF_IN_JOIN, sorted_clause)

            if via_clause:
                self.add_error(ErrorCode.VIA_CLAUSE_WITH_JOIN, node, name=node.relation_name)

            if where_clause and not is_where_optimized:
                self.add_error(ErrorCode.WHERE_CLAUSE_WITH_JOIN, node, name=node.relation_name)

            if isinstance(node, ast.For) and node.report_names:
                self.add_error(ErrorCode.WRITE_REPORT_WITH_JOIN, node)

            for join_clause in join_clause_list:
                relations.append(join_clause.relation_name)
                if join_clause.alias_name:
                    aliases.append(join_clause.alias_name)

            for r in relations:
                if r not in self.names_in_schema:
                    self.add_error(ErrorCode.TEMPORARY_RELATION_WITH_JOIN, node, name=r)

            duplicates_joined_relations = [item for item, count in collections.Counter(relations).items() if count > 1]
            for r in duplicates_joined_relations:
                self.add_error(ErrorCode.JOIN_CLAUSE_REDEFINITION, node, name=r)
        return aliases

    def validate_grouped_clause(self, node):

        is_foreach = isinstance(node, ast.For)

        qualified_rel_alias = node.qualified_rel_alias
        join_clause_list = qualified_rel_alias.join_clause_list
        via_clause = qualified_rel_alias.via_clause
        where_clause = qualified_rel_alias.where_clause
        is_where_optimized = qualified_rel_alias.is_where_optimized
        grouped_clause = qualified_rel_alias.grouped_clause

        is_temporary_relation = False

        if isinstance(node.relation_name.definition, ast.Relation) and\
                node.relation_name not in self.names_in_schema:
            is_temporary_relation = True

        group_list = grouped_clause.group_list
        grouped_fields = [(item.name, item.scope) for item in group_list if isinstance(item.definition, ast.Field)]

        if is_temporary_relation:
            self.add_error(ErrorCode.TEMPORARY_RELATION_WITH_GROUP, node, name=node.relation_name)

        if is_foreach and node.report_names:
            self.add_error(ErrorCode.WRITE_REPORT_WITH_GROUP, node)

        if via_clause:
            self.add_error(ErrorCode.VIA_CLAUSE_WITH_GROUP, node, name=node.relation_name)

        if where_clause and not is_where_optimized:
            self.add_error(ErrorCode.WHERE_CLAUSE_WITH_GROUP, node, name=node.relation_name)

        if join_clause_list:
            if any([item for item in group_list if item.of_name is None]):
                self.add_error(ErrorCode.GROUPED_CLAUSE_WITHOUT_OF_IN_JOIN, grouped_clause)

        for field_name, field_scope in grouped_fields:
            if not isinstance(field_scope, (scope.QueryScope, scope.WhereRoutineScope)) or field_scope.node != node:
                self.add_error(ErrorCode.FIELD_WRONG_USAGE, field_name,
                               name=field_name, relation_name=node.relation_name)

        fetched = [(col, node.scope) for col in node.scope.fetched_columns]
        if join_clause_list:
            for join_clause in join_clause_list:
                join_clause_scope = join_clause.scope
                if isinstance(join_clause_scope, scope.QueryScope):
                    fetched += [(col, join_clause_scope) for col in join_clause_scope.fetched_columns]

        for field in fetched:
            if field not in grouped_fields:
                field_name, field_scope = field
                self.add_error(ErrorCode.GROUPED_CLAUSE_MISSING_FIELD, grouped_clause, name=field_name, relation_name=field_scope)

        if group_list:
            duplicates_grouped_fields = [item for item, count in collections.Counter(grouped_fields).items() if count > 1]
            for field_name, field_scope in duplicates_grouped_fields:
                self.add_error(ErrorCode.GROUPED_CLAUSE_REDEFINITION, node, name=field_name, relation_name=field_scope)

        return grouped_fields

    def validate_report(self, node):
        relation_definition = node.relation_name.definition
        qualified_rel_alias = node.qualified_rel_alias
        sort_list = qualified_rel_alias.sort_list
        sorted_fields_name = [item.field.name for item in sort_list]

        if isinstance(relation_definition, ast.Relation):
            relation_fields = relation_definition.columns
        else:
            relation_fields = []

        self.write_report_names(node)

        for report_name in node.report_names:
            self.report_names.appendleft(report_name)

            report_definition = report_name.definition
            if isinstance(report_definition, ast.Report):

                got_group_condition = False
                for report_condition in report_definition.conditions:
                    self.visit(report_condition)

                    if isinstance(report_condition, ast.GroupCondition):
                        got_group_condition = True

                        if isinstance(relation_definition, ast.Relation):
                            group_name = report_condition.name
                            group_field_name = report_condition.field_name
                            group_field_def = group_field_name.definition

                            if group_name:
                                self.check_name(group_name)

                            if not group_field_def:
                                self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, group_field_name, name=group_field_name)

                            elif group_field_name not in relation_fields:

                                self.add_error(ErrorCode.FIELD_WRONG_USAGE, report_condition,
                                               name=group_field_name, relation_name=relation_definition.name)

                            elif group_field_name not in sorted_fields_name:

                                if isinstance(report_condition, ast.GroupFooting):
                                    condition_name = "GROUP.FOOTING"
                                else:
                                    condition_name = "GROUP.HEADING"

                                self.add_error(ErrorCode.GROUP_CONDITION_ON_NON_SORTED_FIELD,
                                               report_condition,
                                               field_name=group_field_name,
                                               condition_name=condition_name)

                if got_group_condition:
                    if isinstance(relation_definition, ast.Source):
                        self.add_error(ErrorCode.GROUP_CONDITION_IN_FOR_EACH_SOURCE, report_condition,
                                       field_name=report_condition.field_name)

    def select(self, node):
        is_foreach = isinstance(node, ast.For)
        self.visit(node.relation_name)
        self.visit(node.qualified_rel_alias)

        if is_foreach:
            self.visit(node.control_clause)

        relation_definition = node.relation_name.definition
        if is_foreach:
            if relation_definition and not isinstance(relation_definition, (ast.Relation, ast.Source)):
                self.add_error(ErrorCode.INVALID_DEFINITION_TYPE, node.relation_name, name=node.relation_name, kind="RELATION or SOURCE")
        else:
            if relation_definition and not isinstance(relation_definition, ast.Relation):
                self.add_error(ErrorCode.INVALID_DEFINITION_TYPE, node.relation_name, name=node.relation_name, kind="RELATION")

        if not node.is_relation_declared:
            return

        qualified_rel_alias = node.qualified_rel_alias
        join_clause_list = qualified_rel_alias.join_clause_list
        via_clause = qualified_rel_alias.via_clause
        is_where_optimized = qualified_rel_alias.is_where_optimized
        grouped_clause = qualified_rel_alias.grouped_clause
        sort_list = qualified_rel_alias.sort_list
        sorted_fields = [item.field for item in sort_list]

        if is_foreach:
            self.visit(node.source_location)

        self.visit(grouped_clause)

        is_permanent_relation = False

        if isinstance(node.relation_name.definition, ast.Relation) and\
                node.relation_name in self.names_in_schema:
            is_permanent_relation = True

        if is_foreach and is_permanent_relation and\
                not via_clause and\
                not is_where_optimized and\
                not join_clause_list and\
                not grouped_clause:
            self.add_warn(ErrorCode.FOR_EACH_FULL_SCAN, node, relation_name=node.relation_name)

        if grouped_clause:
            grouped_fields = self.validate_grouped_clause(node)

        for field in sorted_fields:
            if field.definition and isinstance(field.definition, ast.Field):
                if not isinstance(field.scope, (scope.QueryScope, scope.WhereRoutineScope)) or field.scope.node != node:
                    self.add_error(ErrorCode.FIELD_WRONG_USAGE, field,
                                   name=field.name, relation_name=node.relation_name)

                elif grouped_clause:
                    if (field.name, field.scope) not in grouped_fields:
                        self.add_error(ErrorCode.GROUPED_CLAUSE_MISSING_FIELD, grouped_clause, name=field.name, relation_name=field.scope)

        aliases = self.validate_join_clause(node)

        if is_foreach and node.report_names:
            self.validate_report(node)

        for a in aliases:
            self.check_locale_name(a)
            self.alias_names.appendleft(a)

        if is_foreach:
            self.visit(node.stmts)
        else:
            self.visit(node.then_else_clause.then_stmts)

        for a in aliases:
            self.alias_names.popleft()

        if is_foreach and node.report_names:
            for _ in node.report_names:
                self.report_names.popleft()

        if not is_foreach:
            self.visit(node.then_else_clause.else_stmts)
