# -*- coding:utf-8 -*-
from delia_parser import ast, types
from delia_commons.errors import ErrorCode
from delia_parser.validate.convert_type import convert_type


class Ids:

    @convert_type
    def visit_Id(self, node):
        self.visit(node.name)

        if node.name.definition is None:
            self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, node, name=node.name)

        elif node.of_name:
            if node.scope.node is None:

                if node.of_name.definition is None:
                    self.add_error(ErrorCode.INVALID_FIELD_REFERENCE, node, of_name=node.of_name)

                elif not isinstance(node.of_name.definition, ast.Array):
                    scope_name = node.of_name.definition.name
                    scope_type = node.scope.__class__.__name__
                    self.add_error(ErrorCode.FIELD_REFERENCE_NOT_IN_VALID_SCOPE, node, scope_name=scope_name, scope_type=scope_type)

    def visit_RelationFieldId(self, node):
        return self.visit_Id(node)

    def visit_ViaFieldId(self, node):
        self.visit(node.name)

        if node.name.definition is None:
            self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, node, name=node.name)

    def visit_ReferenceId(self, node):
        self.visit(node.name)

        if node.name.definition is None:
            self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, node, name=node.name)

    @convert_type
    def visit_ReturningFunction(self, node):
        self.visit(node.name)

        if node.name.definition is None:
            self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, node, name=node.name)

    @convert_type
    def visit_ArrayId(self, node):

        self.visit(node.name)
        self.visit(node.index)

        if node.name.definition is None:
            self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, node, name=node.name)

        elif node.array_definition is None:
            if len(self.array_names) == 0:
                self.add_error(ErrorCode.ARRAY_IMPLICIT_REF_WITHOUT_DECLARATION, node)
            elif len(self.array_names) > 1:
                self.add_error(ErrorCode.ARRAY_IMPLICIT_REF_WITH_MULTIPLE_DECLARATIONS, node)

        elif node.check_subscripts and not isinstance(node.index, (ast.ArrayIndexAll, ast.ArrayIndexTo)):

            if isinstance(node.index.index.type, types.Numeric):

                # If this is a literal, we can compute the boundaries and check them
                # If this is an Id do nothing as values are at runtime
                if isinstance(node.index.index, ast.Literal):
                    literal = self.resolve(node.index.index)
                    literal_val = eval(literal)
                    upper_bound_val = eval(str(node.array_definition.upper_bound.value))
                    if literal and not node.index.index.conversion_types and literal_val > upper_bound_val:
                        self.add_error(ErrorCode.ARRAY_INDEX_OUTSIDE_BOUNDARIES, node, name=node.name)