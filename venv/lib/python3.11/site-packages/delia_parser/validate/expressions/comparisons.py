# -*- coding:utf-8 -*-
from delia_commons.errors import ErrorCode
from delia_parser import ast, types


class Comparisons:

    def comparison(self, node):

        self.visit(node.left)
        self.visit(node.right)

        if isinstance(node.right, ast.Default) and \
                isinstance(node.left, ast.Default):
            self.add_error(ErrorCode.DEFAULT_WITH_COMPARISON,
                           node, exp=node.__class__.__name__)

        elif (isinstance(node.right, ast.Default) or isinstance(node.left, ast.Default)):

            if isinstance(node.right, ast.Default):
                default_to = node.left
            else:
                default_to = node.right

            if isinstance(default_to.definition, ast.Constant):
                self.add_error(ErrorCode.DEFAULT_WITH_CONSTANT, node, name=default_to.definition.name)

            elif default_to.definition:
                if not (isinstance(default_to.definition, ast.Field) or
                        (isinstance(default_to.definition, ast.Function) and default_to.definition.attributes)):
                    self.add_error(ErrorCode.INVALID_DEFINITION_TYPE, node, name=default_to.definition.name, kind='FIELD')
        else:

            type_left = node.left.type
            type_right = node.right.type

            if type_left is not None and type_right is not None:
                if not ((isinstance(type_left, types.Numeric) and isinstance(type_right, types.Numeric)) or
                        (isinstance(type_left, types.Date) and isinstance(type_right, types.Date)) or
                        (isinstance(type_left, types.String) and isinstance(type_right, types.String))):

                    self.add_error(ErrorCode.COMPARISON_INCOMPATIBLE_DATA_TYPE, node,
                                   left=type_left.__class__.__name__,
                                   right=type_right.__class__.__name__)

    def logical(self, node):

        self.visit(node.left)
        self.visit(node.right)

        type_left = node.left.type
        type_right = node.right.type

        if not (isinstance(type_left, types.Boolean) and isinstance(type_right, types.Boolean)):
            self.add_error(ErrorCode.COMPARISON_INCOMPATIBLE_DATA_TYPE, node,
                           left=type_left.__class__.__name__,
                           right=type_right.__class__.__name__)

    def visit_And(self, node):
        self.logical(node)

    def visit_Or(self, node):
        self.logical(node)

    def visit_Eqv(self, node):
        self.logical(node)

    def visit_Xor(self, node):
        self.logical(node)

    def visit_ExtendedComparisonAnd(self, node):
        self.visit(node.exps)

    def visit_ExtendedComparisonOr(self, node):
        self.visit(node.exps)

    def visit_Eq(self, node):
        self.comparison(node)

    def visit_Ge(self, node):
        self.comparison(node)

    def visit_Gt(self, node):
        self.comparison(node)

    def visit_Le(self, node):
        self.comparison(node)

    def visit_Lt(self, node):
        self.comparison(node)

    def visit_Ne(self, node):
        self.comparison(node)

    def visit_Is(self, node):
        self.visit(node.left)
        self.visit(node.right)
        if isinstance(node.left.picture, (ast.FloatPicture, ast.DoublePicture)) and \
                isinstance(node.right.picture, ast.StringPicture):
            self.add_warn(ErrorCode.DATA_CONVERSION_TEST_UNDEFINED, node, from_type="<Float>", to_type="<String>")
        elif isinstance(node.left.picture, ast.StringPicture) and \
                isinstance(node.right.picture, (ast.FloatPicture, ast.DoublePicture)):
            self.add_warn(ErrorCode.DATA_CONVERSION_TEST_UNDEFINED, node, from_type="<String>", to_type="<Float>")

    def visit_Enclosed(self, node):
        self.visit(node.left)
