# -*- coding:utf-8 -*-

from delia_parser import ast, types
from delia_commons.errors import ErrorCode
from delia_parser.builtins import builtins
from delia_parser.validate.convert_type import convert_type


class Builtins:

    def stringify_parameter_count(self, count):
        if count == 1:
            return '1st'
        elif count == 2:
            return '2nd'
        else:
            return '{}th'.format(count)

    def builtin_function(self, node):

        self.visit(node.name)
        self.visit(node.parameters)

        if node.parameters:
            nb_parameters = len(node.parameters)
        else:
            nb_parameters = 0

        function_name = str(node.name)

        if function_name in ("largest", "smallest"):
            assert(nb_parameters == 1)
            param = node.parameters[0]
            parameter_type = param.type
            if hasattr(param, "definition"):
                parameter_definition = param.definition
            else:
                parameter_definition = None

            if not isinstance(parameter_type, (types.Date, types.Numeric, types.String)) \
                    or not isinstance(parameter_definition, ast.Field):
                self.add_error(ErrorCode.FUNCTION_PARAMETER_INCOMPATIBLE_DATA_TYPE,
                               param,
                               function_name=function_name,
                               parameter_number=self.stringify_parameter_count(1),
                               parameter_type='<Numeric>, <Date> or <String>')

        elif function_name in ("min", "max"):

            if nb_parameters < 2:
                self.add_error(ErrorCode.FUNCTION_INVALID_PARAMETERS_COUNT, node,
                               function_name=function_name,
                               nb_param_expected='> 1',
                               nb_param_received=nb_parameters)
            else:

                parameter_type = None
                for count, param in enumerate(node.parameters):

                    if not parameter_type:
                        parameter_type = param.type

                    if not isinstance(parameter_type, (types.Date, types.Numeric)):
                        parameter_type = None
                        self.add_error(ErrorCode.FUNCTION_PARAMETER_INCOMPATIBLE_DATA_TYPE, param,
                                       function_name=function_name,
                                       parameter_number=self.stringify_parameter_count(count+1),
                                       parameter_type='<Numeric> or <Date>')

                    elif (isinstance(parameter_type, types.Numeric) and not isinstance(param.type, types.Numeric)) or \
                            (parameter_type is types.Date() and param.type is not types.Date()):

                        self.add_error(ErrorCode.FUNCTION_PARAMETER_INCOMPATIBLE_DATA_TYPE, param,
                                       function_name=function_name,
                                       parameter_number=self.stringify_parameter_count(count+1),
                                       parameter_type='<{}>'.format(parameter_type.__class__.__name__))

        elif function_name == "size":
            if nb_parameters != 1:
                self.add_error(ErrorCode.FUNCTION_INVALID_PARAMETERS_COUNT, node,
                               function_name=function_name,
                               nb_param_expected=1,
                               nb_param_received=nb_parameters)

            elif not isinstance(node.parameters[0].type, (types.String, types.Numeric, types.Date)):
                self.add_error(ErrorCode.FUNCTION_PARAMETER_INCOMPATIBLE_DATA_TYPE, node.parameters[0],
                               function_name=function_name,
                               parameter_number=self.stringify_parameter_count(1),
                               parameter_type='<Numeric>, <String> or <Date>')

        elif function_name == "get.nom.champ":
            if nb_parameters != 1:
                self.add_error(ErrorCode.FUNCTION_INVALID_PARAMETERS_COUNT, node,
                               function_name=function_name,
                               nb_param_expected=1,
                               nb_param_received=nb_parameters)

            elif isinstance(node.parameters[0], ast.ArrayId) or not isinstance(node.parameters[0].definition, ast.Field):
                self.add_warn(ErrorCode.FUNCTION_GET_NOM_CHAMP_INVALID_PARAMETER, node)

        elif function_name == "floordiv":
            if nb_parameters != 2:
                self.add_error(ErrorCode.FUNCTION_INVALID_PARAMETERS_COUNT, node,
                               function_name=function_name,
                               nb_param_expected=2,
                               nb_param_received=nb_parameters)

            elif not isinstance(node.parameters[0].type, types.Numeric):
                self.add_error(ErrorCode.FUNCTION_PARAMETER_INCOMPATIBLE_DATA_TYPE, node.parameters[0],
                               function_name=function_name,
                               parameter_number=self.stringify_parameter_count(1),
                               parameter_type='<Numeric>')

            elif not isinstance(node.parameters[1].type, types.Numeric):
                self.add_error(ErrorCode.FUNCTION_PARAMETER_INCOMPATIBLE_DATA_TYPE, node.parameters[1],
                               function_name=function_name,
                               parameter_number=self.stringify_parameter_count(2),
                               parameter_type='<Numeric>')

        else:

            _, _, expected_parameters = builtins[function_name]

            min_param = 0
            max_param = len(expected_parameters)
            opt = None
            for _, opt in expected_parameters:
                if not opt:
                    min_param += 1

            if min_param > nb_parameters or nb_parameters > max_param:

                if opt:
                    expected_params = "%d to %d" % (min_param, max_param)
                else:
                    expected_params = min_param

                self.add_error(ErrorCode.FUNCTION_INVALID_PARAMETERS_COUNT, node,
                               function_name=function_name,
                               nb_param_expected=expected_params,
                               nb_param_received=nb_parameters)
            else:
                for pos, param in enumerate(node.parameters):

                    parameter_type = param.type
                    expected_param_type, _ = expected_parameters[pos]

                    if (expected_param_type is types.Numeric() and not isinstance(parameter_type, types.Numeric)) or \
                            (expected_param_type is not types.Numeric() and parameter_type != expected_param_type):
                        self.add_error(ErrorCode.FUNCTION_PARAMETER_INCOMPATIBLE_DATA_TYPE, param,
                                       function_name=function_name,
                                       parameter_number=self.stringify_parameter_count(pos+1),
                                       parameter_type="<{}>".format(expected_param_type.__class__.__name__))

    @convert_type
    def visit_CallingFunction(self, node):

        if str(node.name) in builtins:
            self.builtin_function(node)

        else:
            self.visit(node.name)

            function_definition = node.definition
            if not function_definition:
                self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, node, name=node.name)
            elif not isinstance(function_definition, ast.Function):
                self.add_error(ErrorCode.INVALID_DEFINITION_TYPE, node.name, name=node.name, kind='FUNCTION')
            else:

                self.visit(node.parameters)
                if type(function_definition) is ast.Function and function_definition not in self.functions:
                    self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, node, name=node.name)

                if function_definition.attributes is None:
                    self.add_error(ErrorCode.FUNCTION_USED_AS_SUBROUTINE_FORM, node, function_name=str(node.name))

                # Check input params
                input_params = node.parameters
                expected_params = function_definition.receiving_parameters
                self.check_parameters_match(node, expected_params, input_params)
