# -*- coding:utf-8 -*-
import time

from delia_commons.errors import ErrorCode

from delia_parser import ast
from delia_parser.validate.expressions.ids import Ids
from delia_parser.validate.expressions.comparisons import Comparisons
from delia_parser.validate.expressions.operations import Operations
from delia_parser.validate.expressions.builtins import Builtins
from delia_parser.validate.convert_type import convert_type


class Expression(Ids,
                 Comparisons,
                 Operations,
                 Builtins,
                 ):

    def count_expressions(self, clause):

        def walk_clause(clause, count=0):
            if isinstance(clause, ast.Enclosed):
                return walk_clause(clause.left, count)

            elif isinstance(clause, ast.ExtendedComparison):
                for exp in clause.exps:
                    count = walk_clause(exp, count)
                return count

            elif isinstance(clause, ast.Rel):
                count += 1
                count = walk_clause(clause.left, count)
                count = walk_clause(clause.right, count)
                return count

            elif isinstance(clause, (ast.And, ast.Or, ast.Eqv, ast.Xor)):
                count = walk_clause(clause.left, count)
                count = walk_clause(clause.right, count)
                return count

            else:
                return count

        return walk_clause(clause)

    @convert_type
    def visit_ConstantRef(self, node):
        self.visit(node.name)

    @convert_type
    def visit_String(self, node):
        pass

    @convert_type
    def visit_ControlCharacter(self, node):
        pass

    @convert_type
    def visit_ConcatenatedString(self, node):
        for value in node.values:
            self.visit(value)
            if not isinstance(value, (ast.String, ast.ConstantRef)):
               self.add_error(ErrorCode.OPERATION_WITH_INCOMPATIBLE_DATA_TYPE, node)

    @convert_type
    def visit_Date(self, node):

        if node.value:
            date_value = str(node.value)
            if len(date_value) not in [6, 8]:
                self.add_error(ErrorCode.DATE_INVALID_LENGTH, node)
            elif not date_value.isdigit():
                self.add_error(ErrorCode.DATE_CONTAINING_NON_DIGIT_CHARACTERS, node)
            else:
                day = int(date_value[-2:])
                month = int(date_value[-4:-2])
                if (1 <= day <= 31) and (1 <= month <= 12):
                    if len(date_value) == 6:
                        date_fmt = "%y%m%d"
                    else:
                        date_fmt = "%Y%m%d"
                    date = time.strptime(date_value, date_fmt)
                    if date < self.default_date:
                        self.add_error(ErrorCode.DATE_BEFORE_DEFAULT_DATE, node)
                else:
                    if not (1 <= day <= 31):
                        self.add_error(ErrorCode.DATE_INVALID_MONTH_DAY, node)
                    if not (1 <= month <= 12):
                        self.add_error(ErrorCode.DATE_INVALID_MONTH, node)

    @convert_type
    def visit_Integer(self, node):
        pass

    @convert_type
    def visit_Decimal(self, node):
        pass

    @convert_type
    def visit_Float(self, node):
        pass

    @convert_type
    def visit_Double(self, node):
        pass

    @convert_type
    def visit_Boolean(self, node):
        pass
