#! /usr/bin/env python
# -*- coding:utf-8 -*-


from delia_commons.errors import ErrorCode
from delia_parser import ast, types


class ControlFlow:

    def visit_CompileDirective(self, node):

        self.visit(node.cond)
        type_cond = node.cond.type

        if not isinstance(node.cond, ast.Literal) \
                or (isinstance(node.cond, ast.ConstantRef) and not isinstance(node.cond.definition, ast.Constant)):
            self.add_error(ErrorCode.COMPILE_CONDITION_NOT_CONSTANT_STRING, node)
            return

        for case_labels, __, in node.case_stmts:
            for case_label in case_labels:

                type_case_label = case_label.type

                if not ((isinstance(type_case_label, types.Numeric) and isinstance(type_cond, types.Numeric)) or
                        (isinstance(type_case_label, types.Date) and isinstance(type_cond, types.Date)) or
                        (isinstance(type_case_label, types.String) and isinstance(type_cond, types.String))):

                    self.add_error(ErrorCode.COMPARISON_INCOMPATIBLE_DATA_TYPE,
                                   case_label,
                                   left=type_case_label.__class__.__name__,
                                   right=type_cond.__class__.__name__)

        self.visit(node.stmts_to_compile)

    def visit_Conditional(self, node):

        self.visit(node.cond)
        type_cond = node.cond.type

        for case_stmt in node.case_stmts:
            self.visit(case_stmt)
            for case_label in case_stmt.case_labels:

                type_case_label = case_label.type

                if not ((isinstance(type_case_label, types.Numeric) and isinstance(type_cond, types.Numeric)) or
                        (isinstance(type_case_label, types.Date) and isinstance(type_cond, types.Date)) or
                        (isinstance(type_case_label, types.String) and isinstance(type_cond, types.String))):

                    self.add_error(ErrorCode.COMPARISON_INCOMPATIBLE_DATA_TYPE,
                                   case_label,
                                   left=type_case_label.__class__.__name__,
                                   right=type_cond.__class__.__name__)

        self.visit(node.else_stmt)

    def visit_If(self, node):
        self.visit(node.cond)
        count = self.count_expressions(node.cond)
        if count > self.MAXIMUM_EXPRESSIONS:
            self.add_warn(ErrorCode.MAXIMUM_EXPRESSIONS_REACHED,
                          node, number=count, max=self.MAXIMUM_EXPRESSIONS)
        self.visit(node.then_else_clause)

    def visit_ThenElseClause(self, node):
        self.visit(node.then_stmts)
        self.visit(node.else_stmts)

    def visit_WhileDo(self, node):
        self.visit(node.cond)
        count = self.count_expressions(node.cond)
        if count > self.MAXIMUM_EXPRESSIONS:
            self.add_warn(ErrorCode.MAXIMUM_EXPRESSIONS_REACHED,
                          node.cond, number=count, max=self.MAXIMUM_EXPRESSIONS)
        self.visit(node.stmts)

    def visit_DoWhile(self, node):
        self.visit(node.cond)
        count = self.count_expressions(node.cond)
        if count > self.MAXIMUM_EXPRESSIONS:
            self.add_warn(ErrorCode.MAXIMUM_EXPRESSIONS_REACHED,
                          node.cond, number=count, max=self.MAXIMUM_EXPRESSIONS)
        self.visit(node.stmts)

    def visit_WhereClause(self, node):
        self.visit(node.clause)

    def visit_LabelStmt(self, node):
        label = node.label
        self.check_locale_name(label.name)
        self.labels.appendleft(label)
        self.visit(node.stmts)
        old = self.labels.popleft()
        assert(old == label)

    def check_label(self, node):
        label = node.label_name

        if isinstance(node, ast.Finish):
            kind = "FINISH"
        else:
            kind = 'REPEAT'

        if not isinstance(label.definition, ast.Label):
            self.add_error(ErrorCode.FINISH_OR_REPEAT_STATEMENT_REFERRING_TO_UNDEFINED_LABEL, node.label_name, name=node.label_name, kind=kind)
        else:
            for current_label in self.labels:
                if current_label == label.definition:
                    break
            else:
                self.add_error(ErrorCode.FINISH_OR_REPEAT_STATEMENT_INVALID_LABEL_REFERENCE, node.label_name, name=node.label_name, kind=kind)

    def visit_Finish(self, node):
        self.check_label(node)

    def visit_Repeat(self, node):
        self.check_label(node)
