#! /usr/bin/env python
# -*- coding:utf-8 -*-


from delia_commons.errors import ErrorCode
from delia_parser import ast, types


class Source:

    def visit_Source(self, node):

        self.check_name(node.name)

        if not node.used:
            return

        self.visit(node.attributes)

        for attr in node.attributes:
            if isinstance(attr, ast.SourceFreeForm):
                self.in_source_free_form = True

        self.visit(node.inputs)

        self.in_source_free_form = False

        if isinstance(node.prompt, ast.ForClause):
            for_clauses = [node.prompt]
        elif isinstance(node.prompt, list):
            assert(all(isinstance(for_clause, ast.ForClause) for for_clause in node.prompt))
            for_clauses = node.prompt
        else:
            for_clauses = []

        for for_clause in for_clauses:
            for input_item in node.inputs:
                if input_item.name == for_clause.field_name:
                    break
            else:
                self.add_error(ErrorCode.PROMPT_FIELD_NOT_IN_ACCEPT_OR_SOURCE_INPUT_LIST,
                               node.prompt.field_name, name=node.prompt.field_name)

        for input_ in node.input_set:
            if isinstance(input_.picture, (ast.FloatPicture, ast.DoublePicture)):
                self.add_error(ErrorCode.FLOAT_NOT_SUPPORTED_IN_ACCEPT_OR_SOURCE_INPUT_LIST, input_, type="Float", name=input_.name)

    def visit_SourceInputId(self, node):
        self.visit_Id(node)
        self.visit(node.input_picture)
        if node.definition and not isinstance(node.definition, ast.Field):
            self.add_error(ErrorCode.EXPECTED_FIELD, node, kind="field from the source input list")

    def visit_SourceInputArrayId(self, node):
        self.visit_ArrayId(node)

    def visit_SourceConditional(self, node):

        self.visit(node.cond)

        type_cond = node.cond.type

        for case_stmt in node.input_cases:

            self.visit(case_stmt)

            for case_label in case_stmt.case_labels:

                type_case_label = case_label.type

                if not ((isinstance(type_case_label, types.Numeric) and isinstance(type_cond, types.Numeric)) or
                        (isinstance(type_case_label, types.Date) and isinstance(type_cond, types.Date)) or
                        (isinstance(type_case_label, types.String) and isinstance(type_cond, types.String))):

                    self.add_error(ErrorCode.COMPARISON_INCOMPATIBLE_DATA_TYPE,
                                   case_label,
                                   left=type_case_label.__class__.__name__,
                                   right=type_cond.__class__.__name__)

        self.visit(node.input_else)

    def visit_SourceSeparator(self, node):
        self.visit(node.value)
        if node.value.type is not types.String():
            self.add_error(ErrorCode.SOURCE_SEPARATOR_LENGTH, node.value)
        else:
            literal_value = self.resolve(node.value)
            if literal_value and len(str(literal_value)) != 1:
                self.add_error(ErrorCode.SOURCE_SEPARATOR_LENGTH, node.value)

    def visit_SourceLineLength(self, node):
        self.visit(node.value)
        if node.value.type is not types.Integer():
            self.add_error(ErrorCode.PARAMETER_EXPECTED_INTEGER, node.value, parameter=node.attr_name)
