#! /usr/bin/env python
# -*- coding:utf-8 -*-


from delia_commons.errors import ErrorCode
from delia_parser import ast, types, scope
from delia_parser.validate.convert_type import convert_type


class Report:

    def visit_Report(self, node):

        self.check_name(node.name)

        if not node.used:
            return

        self.visit(node.parameters)
        # self.visit(node.conditions) # Visit only during the WRITE.REPORT

    def report_condition(self, node):
        self.visit(node.report_name)
        self.report_conditions.appendleft(node)
        self.visit(node.stmts)
        self.report_conditions.popleft()

    def visit_ReportHeading(self, node):
        self.report_condition(node)

    def visit_ReportFooting(self, node):
        self.report_condition(node)

    def visit_PageHeading(self, node):
        self.report_condition(node)

    def visit_PageFooting(self, node):
        self.report_condition(node)

    def visit_GroupHeading(self, node):
        self.report_condition(node)

    def visit_GroupFooting(self, node):
        self.report_condition(node)

    def visit_Print(self, node):

        if not node.report_name:
            self.add_error(ErrorCode.WRITE_REPORT_MISSING_REPORT_NAME, node)
        elif not node.report_name.definition:
            self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, node, name=node.report_name)
        elif not isinstance(node.report_name.definition, ast.Report):
            self.add_error(ErrorCode.INVALID_DEFINITION_TYPE, node, name=node.report_name, kind='REPORT')
        else:
            for report in self.report_names:
                if node.report_name == report:
                    break
            else:
                self.add_error(ErrorCode.REPORT_INVALID_SCOPE, node, name=str(node.report_name).upper())

        self.visit(node.output_list)

    def visit_Force(self, node):
        self.visit(node.report_cond)
        self.visit(node.report_name)

    def write_report_names(self, node):

        report_names = node.report_names

        self.visit(report_names)

        if not node.report_names:
            self.add_error(ErrorCode.WRITE_REPORT_MISSING_REPORT_NAME, node)
        else:

            count_report_names = {report_name: report_names.count(report_name) for report_name in report_names}
            for report_name, count in count_report_names.items():
                if count > 1:
                    self.add_error(ErrorCode.WRITE_REPORT_MULTIPLE_REFERENCE_TO_SAME_REPORT, node, name=report_name)

            for report_name in report_names:

                if not report_name.definition:
                    self.add_error(ErrorCode.NAME_UNDECLARED_USAGE, node, name=report_name)
                elif not isinstance(report_name.definition, ast.Report):
                    self.add_error(ErrorCode.INVALID_DEFINITION_TYPE, node, name=report_name, kind='REPORT')

    def visit_WriteReport(self, node):
        self.write_report_names(node)

        if node.report_names:
            for report_name in node.report_names:
                self.report_names.appendleft(report_name)

                if isinstance(report_name.definition, ast.Report):
                    for report_condition in report_name.definition.conditions:

                        self.visit(report_condition)

                        if isinstance(report_condition, ast.GroupCondition):
                            group_field_name = report_condition.field_name
                            self.add_error(ErrorCode.GROUP_CONDITION_NOT_IN_FOREACH, report_condition, name=group_field_name)

            self.visit(node.stmts)

            for report_name in node.report_names:
                self.report_names.popleft()

    @convert_type
    def visit_CumulativeFunction(self, node):

        self.visit(node.parameters)

        function_name = str(node.name).lower()

        if len(self.report_conditions) == 0:
            self.add_error(ErrorCode.CUMULATIVE_FUNCTION_NOT_IN_REPORT_OR_GROUP_FOOTING,
                           node, name=node.name)
        else:

            if function_name in ("min", "max", "avg", "sum"):

                param = node.parameters[0]

                if not isinstance(param.definition, ast.Field):

                    self.add_error(ErrorCode.CUMULATIVE_FUNCTION_ARGUMENT_NOT_A_FIELD, param,
                                   function_name=node.name)

                else:

                    # Check field in a FOR.EACH of the relation.
                    if not (isinstance(param.scope, scope.QueryScope) and
                            isinstance(param.scope.node, ast.For) and
                            param.scope.node.report_names and
                            isinstance(param.scope.name.definition, ast.Relation) and
                            param.name in param.scope.name.definition.columns):

                        self.add_error(ErrorCode.CUMULATIVE_FUNCTION_ARGUMENT_NOT_FIELD_OF_RELATION,
                                       param, name=param.name, function_name=node.name)

                    if (function_name in ("min", "max",) and not isinstance(param.type, (types.Numeric, types.Date))) \
                            or (function_name in ("sum", "avg",) and not isinstance(param.type, types.Numeric)):

                        self.add_error(ErrorCode.FUNCTION_PARAMETER_INCOMPATIBLE_DATA_TYPE, param,
                                       function_name=node.name,
                                       parameter_number=self.stringify_parameter_count(1),
                                       parameter_type='<Numeric> or <Date>')

    @convert_type
    def ReportItem(self, node):
        pass

    visit_ReportPageNum = \
        visit_ReportPageSize = \
        visit_ReportLineNum = \
        visit_ReportPageDivider = \
        visit_ReportBottomMargin = \
        visit_ReportTopMargin = \
        visit_ReportHeadingSize = \
        visit_ReportFootingSize = \
        visit_ReportLineLength = \
        ReportItem
