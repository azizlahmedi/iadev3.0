# -*- coding:utf-8 -*-


from delia_commons.errors import ErrorCode
from delia_parser import ast, types
from delia_parser.annotate.expressions.operations import get_resulting_type


class Assignment:

    def check_augmented_assignment(self, node, operator):

        exp = node.exp

        self.visit(exp)

        for rcv in node.receiving_fields:

            self.visit(rcv)

            self.check_assignment(node, rcv, exp)

            # Check data type
            if not isinstance(exp, ast.Default) and isinstance(rcv.definition, ast.Field):

                left_type = rcv.type
                right_type = exp.type
                node_type = get_resulting_type(left_type, right_type, operator)
                if (left_type is not None and right_type is not None) and \
                        (node_type is None or
                         (not isinstance(left_type, types.Date) and isinstance(right_type, types.Date)) or
                         (isinstance(left_type, types.String) or isinstance(right_type, types.String)
                          )):
                    self.add_error(ErrorCode.ASSIGNMENT_INCOMPATIBLE_DATA_TYPE,
                                   node, name=rcv.name,
                                   type=rcv.type.__class__.__name__,
                                   companion_type=exp.type.__class__.__name__)

    def check_multiple_assignment(self, node):

        exp = node.exp

        self.visit(exp)

        for rcv in node.receiving_fields:

            self.visit(rcv)

            self.check_assignment(node, rcv, exp)

            # Check data type
            if not isinstance(exp, ast.Default):

                rcv_name = rcv.name
                rcv_type = rcv.type
                exp_type = exp.type

                if rcv_type is None or exp_type is None:
                    continue

                if not ((isinstance(rcv_type, types.Numeric) and isinstance(exp_type, types.Numeric)) or
                        (isinstance(rcv_type, types.Date) and isinstance(exp_type, types.Date)) or
                        (isinstance(rcv_type, types.String) and isinstance(exp_type, types.String)) or
                        (isinstance(rcv_type, types.Boolean) and isinstance(exp_type, types.Boolean)) or
                        (isinstance(rcv_type, types.Array) and isinstance(exp_type, types.Array))):

                    if isinstance(rcv, ast.CallingFunction):

                        function_name = str(rcv.name).upper()
                        if function_name in ('YEAR', 'MONTH', 'DAY'):
                            self.add_error(ErrorCode.FUNCTION_PARAMETER_INCOMPATIBLE_DATA_TYPE,
                                           node,
                                           function_name=rcv_name,
                                           parameter_number='last',
                                           parameter_type='<Integer>')

                        elif function_name == 'SUBSTR':
                            self.add_error(ErrorCode.FUNCTION_PARAMETER_INCOMPATIBLE_DATA_TYPE,
                                           node,
                                           function_name=rcv_name,
                                           parameter_number='last',
                                           parameter_type='<String>')

                    else:
                        self.add_error(ErrorCode.ASSIGNMENT_INCOMPATIBLE_DATA_TYPE, node,
                                       name=rcv_name,
                                       type=rcv_type.__class__.__name__,
                                       companion_type=exp_type.__class__.__name__)

    def check_assignment(self, node, rcv, exp):

        if isinstance(rcv, ast.CallingFunction):

            function_name = str(rcv.name).upper()

            # Assign string slice.
            # e.g. LET SUBSTR(FIELD, 10) = 'TOTO'
            # Particular case for LET SUBSTR(field, 1) = value

            # Assign date attribute such as YEAR, MONTH or DAY.
            # e.g. LET DAY(date.1) = 31
            #  SUBTRACT MONTH(date.1) = 12
            #  ADD YEAR(date.1) = 1

            if function_name not in ('SUBSTR', 'YEAR', 'MONTH', 'DAY'):
                self.add_error(ErrorCode.FUNCTION_ASSIGNMENT_ILLEGAL, node, function_name=rcv.name)

            if isinstance(exp, ast.Default):
                self.add_error(ErrorCode.FUNCTION_ASSIGNED_TO_DEFAULT, node, function_name=rcv.name)

            if rcv.parameters and len(rcv.parameters) > 0:
                if isinstance(rcv.parameters[0].definition, ast.Constant):
                    self.add_error(ErrorCode.ASSIGNMENT_TO_CONSTANT_PROHIBITED, node, name=rcv.parameters[0].name)

        # Assign control.
        # e.g. LET USERS LANGUAGE = XXX
        elif isinstance(rcv, ast.LanguageControl):
            # Nothing to do.
            pass

        # Assign flags as BLINK, BOLD...
        elif isinstance(rcv, ast.FlagReference):
            # TODO: check if assigned in a DISPLAY scope.
            pass

        # Assign to a constant.
        elif isinstance(rcv.definition, ast.Constant):
            self.add_error(ErrorCode.ASSIGNMENT_TO_CONSTANT_PROHIBITED, node, name=rcv.definition.name)

        # Assign array to array.
        # e.g. LET ARRAY.1 = ARRAY.2
        # e.g. LET ARRAY.1[1 TO 4] = ARRAY.2[1 TO 4]
        elif isinstance(rcv.definition, ast.Array):

            if isinstance(exp, ast.Default):
                # Nothing to do.
                pass

            elif not isinstance(exp.definition, ast.Array):
                self.add_error(ErrorCode.ARRAY_ASSIGNMENT_INVALID_TYPE, node)

            elif isinstance(exp.definition, ast.Array):

                # Check array contents.
                rcv_columns = rcv.definition.columns
                exp_columns = exp.definition.columns

                if len(rcv_columns) != len(exp_columns):
                    self.add_error(ErrorCode.ARRAY_ASSIGNMENT_INCOMPATIBLE_NUMBER_OF_COLUMNS, node)
                else:
                    for i in range(len(rcv_columns)):
                        if rcv_columns[i].definition != exp_columns[i].definition:
                            self.add_error(ErrorCode.ARRAY_ASSIGNMENT_INCOMPATIBLE_NUMBER_OF_COLUMNS, node)

                # Check array index.
                if isinstance(rcv, ast.ArrayId):
                    pass
                else:
                    rcv_upper_bound = self.resolve(rcv.definition.upper_bound)
                    rcv_lower_bound = self.resolve(rcv.definition.lower_bound)
                    exp_upper_bound = self.resolve(exp.definition.upper_bound)
                    exp_lower_bound = self.resolve(exp.definition.lower_bound)
                    if not(rcv_upper_bound and rcv_lower_bound and exp_upper_bound and exp_lower_bound) or \
                        eval(str(rcv_upper_bound)) != eval(str(exp_upper_bound)) or \
                            eval(str(rcv_lower_bound)) != eval(str(exp_lower_bound)):

                        self.add_error(ErrorCode.ARRAY_ASSIGNMENT_INCOMPATIBLE_NUMBER_OF_ROWS, node)

        # Assign a field.
        # e.g. LET field.1 = XXX
        elif isinstance(rcv.definition, ast.Field):
            # Nothing to do.
            pass

        # Store returning value inside a function
        # declared as FUNCTION <function_name> <parameters> AS <resulting_picture>
        # e.g. LET <function_name> = XXX
        elif isinstance(rcv.definition, ast.Function):
            assert(isinstance(rcv, ast.ReturningFunction))
            # Check in the scope of the function
            if self.in_function != rcv.definition:
                self.add_error(ErrorCode.FUNCTION_RETURN_VALUE_ASSIGNMENT_OUTOFSCOPE, node, function_name=rcv.definition.name)
            elif rcv.definition.attributes is None:
                    self.add_error(ErrorCode.FUNCTION_SUBROUTINE_ASSIGNMENT_NOT_ALLOWED,
                                   node,
                                   function_name=rcv.definition.name)

        # Error
        elif rcv.definition:
            self.add_error(ErrorCode.INVALID_DEFINITION_TYPE, node, name=rcv.definition.name, kind='FIELD')

    def visit_Add(self, node):
        self.check_augmented_assignment(node, operator='+')

    def visit_Subtract(self, node):
        self.check_augmented_assignment(node, operator='-')

    def visit_Move(self, node):
        self.check_multiple_assignment(node)

    def visit_Let(self, node):
        self.check_multiple_assignment(node)
