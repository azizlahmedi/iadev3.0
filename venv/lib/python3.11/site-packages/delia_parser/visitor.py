# -*- coding: utf-8 -*-
from delia_parser import ast
import inspect


class ASTVisitor:
    """Performs a depth-first walk of the AST

    The ASTVisitor will walk the AST, performing either a preorder or
    postorder traversal depending on which method is called.

    methods:
    preorder(tree, visitor)
        tree: an instance of ast
        visitor: an instance with visit_XXX methods

    The ASTVisitor is responsible for walking over the tree in the
    correct order.  For each node, it checks the visitor argument for
    a method named 'visit_NodeType' where NodeType is the name of the
    node's class, e.g. Class.  If the method exists, it is called
    with the node as its sole argument.

    The visitor method for a particular node type can control how
    child nodes are visited during a preorder walk.  (It can't control
    the order during a postorder walk, because it is called _after_
    the walk has occurred.)  The ASTVisitor modifies the visitor
    argument by adding a visit method to the visitor; this method can
    be used to visit a child node of arbitrary type.
    """

    VERBOSE = False

    def __init__(self, prefix, locations_handler):
        self._cache = {}
        self.prefix = prefix
        self._lvl = 0
        self.locations_handler = locations_handler
        self.with_base_classes = False

    def default(self, node, *args):
        if node is not None and hasattr(node, "__iter__"):
            for child in node:
                self.dispatch(child, *args)

    def default_verbose(self, node, *args):
        if node is not None and hasattr(node, "__iter__"):
            if self.VERBOSE:
                print("[LVL-%d] default.node=" % self._lvl, node)
            self._lvl += 1
            for child in node:
                if self.VERBOSE:
                    print("[LVL-%d] default.child=" % self._lvl, child)
                self.dispatch(child, *args)
            self._lvl -= 1

    def dispatch(self, node, *args):
        if self.locations_handler and isinstance(node, ast.BaseAST):
            self.locations_handler(locations=node.locations)

        try:
            return self._cache[node.__class__.__name__](node, *args)
        except KeyError:
            name = node.__class__.__name__
            if self.with_base_classes:
                if hasattr(self.visitor, self.prefix + name):
                    meth = getattr(self.visitor, self.prefix + name)
                else:

                    for base_name in inspect.getmro(node.__class__):
                        if hasattr(self.visitor, self.prefix + base_name.__name__):
                            meth = getattr(self.visitor, self.prefix + base_name.__name__)
                            break
                    else:
                        meth = self.default
            else:
                meth = getattr(self.visitor, self.prefix + name, self.default)

            self._cache[name] = meth
            return self._cache[name](node, *args)

    def dispatch_verbose(self, node, *args):
        if self.locations_handler and isinstance(node, ast.BaseAST):
            self.locations_handler(locations=node.locations)

        try:
            return self._cache[node.__class__.__name__](node, *args)
        except KeyError:
            name = node.__class__.__name__
            if self.with_base_classes:
                if hasattr(self.visitor, self.prefix + name):
                    meth = getattr(self.visitor, self.prefix + name)
                else:

                    for base_name in inspect.getmro(node.__class__):
                        if hasattr(self.visitor, self.prefix + base_name.__name__):
                            meth = getattr(self.visitor, self.prefix + base_name.__name__)
                            break
                    else:
                        meth = self.default
            else:
                meth = getattr(self.visitor, self.prefix + name, self.default)

            self._cache[name] = meth
        if self.VERBOSE:
            print("[LVL-%d] dispatch" % self._lvl, name, (meth and meth.__name__ or ''))
        return meth(node, *args)

    def setUp(self, *args):
        meth = getattr(self.visitor, self.prefix + "setUp", None)
        if meth is not None:
            if self.VERBOSE:
                print("dispatch setUp", (meth and meth.__name__ or ''))
            return meth(*args)

    def tearDown(self, *args):
        meth = getattr(self.visitor, self.prefix + "tearDown", None)
        if meth is not None:
            if self.VERBOSE:
                print("dispatch tearDown", (meth and meth.__name__ or ''))
            return meth(*args)

    def preorder(self, ast, visitor, *args):
        """Do preorder walk of tree using visitor"""
        self.visitor = visitor
        self._lvl = 0
        self.setUp(*args)
        if self.VERBOSE:
            visitor.visit = self.dispatch_verbose
            self.dispatch_verbose(ast, *args)
        else:
            visitor.visit = self.dispatch
            self.dispatch(ast, *args)
        self.tearDown(*args)


_walker = ASTVisitor


def walk(ast, visitor, prefix='visit_', walker=None, verbose=False, with_base_classes=False, locations_handler=None):
    if walker is None:
        walker = _walker(prefix, locations_handler)
    walker.VERBOSE = verbose
    walker.with_base_classes = with_base_classes
    walker.preorder(ast, visitor)
    return walker.visitor


class ASTVisitorABC:

    def __init__(self, compile_ctx, visit=None):
        self.compile_ctx = compile_ctx
        self.visit = visit


class TokenVisitor:

    VERBOSE = False

    def __init__(self, prefix):
        self._cache = {}
        self.prefix = prefix

    def default(self, scanner, *args):
        for token_infos in scanner:
            self.dispatch(ast.node_wrap(token_infos), *args)

    def dispatch(self, node, *args):
        if node is None:
            name = "None"
        else:
            name = node.node_name
        meth = self._cache.get(name, None)
        if meth is None:
            meth = getattr(self.visitor, self.prefix + name, self.default)
            self._cache[name] = meth
        if self.VERBOSE:
            print("dispatch", name, (meth and meth.__name__ or ''))
        return meth(node, *args)

    def preorder(self, scanner, visitor, *args):
        """Do preorder walk of tree using visitor"""
        self.visitor = visitor
        visitor.visit = self.dispatch
        self.default(scanner, *args)


_token_walker = TokenVisitor


def token_walk(scanner, visitor, prefix='visit_', walker=None, verbose=False):
    if walker is None:
        walker = _token_walker(prefix)
    walker.VERBOSE = verbose
    walker.preorder(scanner, visitor)
    return walker.visitor
