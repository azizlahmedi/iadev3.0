# -*- coding:utf-8 -*-
from collections import deque, OrderedDict
from delia_parser import ast


class AdlScope:
    def __init__(self, node, name, prefix=0):
        self.node = node
        self.prefix = prefix
        self.name = name
        self.alias_name = name
        self.symbols = {}

    def get_def(self, symbol):
        definition, _ = self.symbols.get(symbol, (None, False))
        return definition

    def has_symbol(self, symbol):
        return symbol in self.symbols

    def add_symbol(self, symbol, definition, in_schema=False):
        self.symbols[symbol] = (definition, in_schema)

    def in_schema(self, symbol):
        _, in_schema = self.symbols.get(symbol, (None, False))
        return in_schema

    def get_arrays_from_column_name(self, column):
        arrays = []
        for array_name, (definition, _) in filter(lambda item: isinstance(item[1][0], ast.Array), self.symbols.items()):
            if column in definition.columns:
                    arrays.append(array_name)
        return arrays

    def __str__(self):
        return "%s%s" % ("" if self.prefix == 0 else "_%d_" % self.prefix, str(self.alias_name))


class AdlOfNameScope(AdlScope):
    def __init__(self, name):
        self.node = None
        self._prefix = 0
        self.name = name
        self.alias_name = None
        self.symbols = {}

    def __str__(self):
        return str(self.name)


class AdlDynScope(AdlScope):
    def __init__(self, procedure_scope):
        self._procedure_scope = procedure_scope
        self.node = None
        self._prefix = 0
        self.name = None
        self.alias_name = None

    @property
    def symbols(self):
        return self._procedure_scope.symbols

    def __str__(self):
        return "AdlDynScope"


class ProcedureScope(AdlScope):
    def __init__(self, node=None, name=None, prefix=0):
        AdlScope.__init__(self, node, name, prefix)
        self.alias_name = ast.Name("procedure")
        self.functions_key_local = []
        self.functions_key_global = []

    def add_functions_key_local(self, func):
        self.functions_key_local.append(func)

    def add_functions_key_global(self, func):
        self.functions_key_global.append(func)

    def __str__(self):
        return "procedure"


class FunctionScope(AdlScope):
    def __str__(self):
        return "ns_%s" % str(self.name)


class QueryScope(AdlScope):
    def __init__(self, procedure_scope, node, name, alias_name, prefix=0):
        AdlScope.__init__(self, node, name, prefix)
        self.procedure_scope = procedure_scope
        self.ids_not_from_query = []

        if alias_name is None:
            self.alias_name = name
        else:
            self.alias_name = alias_name

        if isinstance(self.relation_definition, ast.Relation):
            for column in self.relation_definition.columns:
                self.symbols[column] = procedure_scope.symbols.get(column, (None, False))

        elif isinstance(self.relation_definition, ast.Source):
            for input_item in self.relation_definition.input_set:
                if isinstance(input_item, ast.SourceInputId):
                    field_name = input_item.name
                    scope = procedure_scope.symbols.get(field_name, None)
                    if scope:
                        field_definition, _ = scope
                        if isinstance(field_definition, ast.Field):
                            self.symbols[field_name] = scope
                elif isinstance(input_item, ast.SourceInputArrayId):
                    array_name = input_item.of_name
                    scope = procedure_scope.symbols.get(array_name, None)
                    if scope:
                        array_definition, _ = scope
                        if isinstance(array_definition, ast.Array):
                            self.symbols[array_name] = scope

        self.fetched_expressions = []
        self.fetched_columns = OrderedDict()
        self.updated_datas = set()
        self.where_routine_params = OrderedDict()

    @property
    def relation_definition(self):
        return self.alias_name.definition

    def add_fetched_expression(self, expression):
        try:
            count = self.fetched_expressions.index(expression)
        except ValueError:
            count = len(self.fetched_expressions)
            self.fetched_expressions.append(expression)
        return count

    def add_fetched_columns(self, field_name):
        if isinstance(self.relation_definition, ast.Relation):
            if field_name in self.relation_definition.columns:
                self.fetched_columns[field_name] = field_name

    def add_updated_datas(self, data_name):
        if isinstance(self.relation_definition, ast.Relation):
            if data_name in self.relation_definition.datas:
                self.updated_datas.add(data_name)

    def __str__(self):
        return "%s%s" % ("" if self.prefix == 0 else "_%d_" % self.prefix, str(self.alias_name))


class QuerySelectScope(QueryScope):
    pass


class QueryForScope(QueryScope):
    pass


class QueryDeleteScope(QueryScope):
    pass


class JoinClauseScope(AdlScope):
    def __init__(self, procedure_scope, node, name, alias_name, prefix=0):
        AdlScope.__init__(self, node, name, prefix)
        self.procedure_scope = procedure_scope

        if alias_name is None:
            self.alias_name = name
        else:
            self.alias_name = alias_name

        if isinstance(self.relation_definition, ast.Relation):
            for column in self.relation_definition.columns:
                if column in procedure_scope.symbols:
                    self.symbols[column] = procedure_scope.symbols[column]
        self.fetched_columns = OrderedDict()

    @property
    def relation_definition(self):
        return self.alias_name.definition

    def add_fetched_columns(self, field_name):
        raise "not callable for this scope"

    def add_symbol(self, symbol, definition, in_schema=False):
        raise "not callable for this scope"

    def __str__(self):
        return "%s%s" % ("" if self.prefix == 0 else "_%d_" % self.prefix, str(self.alias_name))


class InnerJoinClauseScope(JoinClauseScope):
    pass


class OuterJoinClauseScope(JoinClauseScope):
    pass


class LeftOuterJoinClauseScope(OuterJoinClauseScope):
    pass


class RightOuterJoinClauseScope(OuterJoinClauseScope):
    pass


class FullOuterJoinClauseScope(OuterJoinClauseScope):
    pass


class WhereClauseScope(AdlScope):
    def __init__(self, procedure_scope, node, name, alias_name, prefix=0):
        AdlScope.__init__(self, node, name, prefix)
        self.procedure_scope = procedure_scope

        if alias_name is None:
            self.alias_name = name
        else:
            self.alias_name = alias_name

        if isinstance(self.relation_definition, ast.Relation):
            for column in self.relation_definition.columns:
                if column in procedure_scope.symbols:
                    self.symbols[column] = procedure_scope.symbols[column]
        self.fetched_columns = OrderedDict()

    @property
    def relation_definition(self):
        return self.alias_name.definition

    def add_fetched_columns(self, field_name):
        raise "not callable for this scope"

    def add_symbol(self, symbol, definition, in_schema=False):
        raise "not callable for this scope"

    def __str__(self):
        return ""


class WhereRoutineScope(AdlScope):
    def __init__(self, procedure_scope, node, name, alias_name, prefix=0):
        AdlScope.__init__(self, node, name, prefix)
        self.procedure_scope = procedure_scope

        if alias_name is None:
            self.alias_name = name
        else:
            self.alias_name = alias_name

        if isinstance(self.relation_definition, ast.Relation):
            for column in self.relation_definition.columns:
                if column in procedure_scope.symbols:
                    self.symbols[column] = procedure_scope.symbols[column]
        self.fetched_columns = OrderedDict()

    @property
    def relation_definition(self):
        return self.alias_name.definition

    def add_fetched_columns(self, field_name):
        if isinstance(self.relation_definition, ast.Relation):
            if field_name in self.relation_definition.columns:
                self.fetched_columns[field_name] = field_name

    def add_symbol(self, symbol, definition, in_schema=False):
        raise "not callable for this scope"

    def __str__(self):
        return ""


class DisplayScope(AdlScope):
    def __init__(self, procedure_scope, node, name, prefix=0):
        AdlScope.__init__(self, node, name, prefix)
        self.active_frame = False
        frame_definition = procedure_scope.get_def(name)
        for data_name in frame_definition.frame_data_names:
            if data_name in procedure_scope.symbols:
                self.symbols[data_name] = procedure_scope.symbols[data_name]

    @property
    def frame_name(self):
        return self.name

    @property
    def function_key_names(self):
        return self.node.function_key_names


class DequeScopes(deque):
    def set_prefix(self, scope):
        if not isinstance(scope, WhereRoutineScope):
            for scope_item in self:
                if scope.alias_name == scope_item.alias_name:
                    scope.prefix = scope_item.prefix + 1
                    break

    def append(self, scope):
        self.set_prefix(scope)
        deque.append(self, scope)

    def appendleft(self, scope):
        self.set_prefix(scope)
        deque.appendleft(self, scope)
