# -*- coding:utf-8 -*-
from delia_parser import ast, types, pictures
from delia_parser.builtins import builtins
from delia_parser.annotate.convert_type import convert_type


def get_picture(node):
    if hasattr(node, 'picture'):
        return node.picture.picture
    else:
        return node.definition.picture.picture


class Builtins:

    def builtins_function_min_max(self, node):

        if node.parameters and len(node.parameters) > 0:

            if all(param.type is types.Date() for param in node.parameters):
                node.type = types.Date()
            elif all(param.type is types.Integer() for param in node.parameters):
                node.type = types.Integer()
            else:
                node.type = types.Decimal()

            node.picture = ast.UnknownPicture()
            self.visit(node.basic_picture)

    def builtins_function_abs(self, node):
        if node.parameters and \
            len(node.parameters) == 1 and \
                isinstance(node.parameters[0].type, types.Numeric):

            param = node.parameters[0]
            type_ = param.type
            picture = get_picture(param)
            if isinstance(picture, pictures.UnknownPicture):
                node.picture = ast.UnknownPicture()
            else:
                total_digits, decimal_digits = picture.get_digits()
                integer_digits = total_digits - decimal_digits

                if type_ is types.Integer():
                    pictureDef = '%dZN' % (integer_digits - 1)
                elif integer_digits == 0:
                    pictureDef = '.%dN' % decimal_digits
                else:
                    pictureDef = '%dZN.%dN' % (integer_digits - 1, decimal_digits)

                pictureClass = self.TYPE_TO_PICTURE[type_]
                node.picture = pictureClass(pictureDef)

            node.type = type_
            self.visit(node.basic_picture)

    def builtins_function_sqrt(self, node):
        node.type = types.Decimal()
        node.picture = ast.UnknownPicture()
        self.visit(node.basic_picture)

    def builtins_function_largest_smallest(self, node):
        if node.parameters and \
            len(node.parameters) == 1 and \
            isinstance(node.parameters[0], (ast.Id, ast.ArrayId)) and \
                isinstance(node.parameters[0].definition, ast.Field):

            param = node.parameters[0]
            _type = param.type

            if isinstance(_type, types.Numeric):
                _picture = param.picture

            elif _type is types.Date():
                pictureClass = self.TYPE_TO_PICTURE[_type]
                _picture = pictureClass(value='YYYYMMDD')
                self.visit(_picture)

            elif _type is types.String():
                function_name = str(node.name)
                if str(function_name) == "largest":
                    _picture = param.picture
                else:
                    pictureClass = self.TYPE_TO_PICTURE[types.String()]
                    _picture = pictureClass(value='C')
                    self.visit(_picture)

            node.picture = _picture
            node.type = _type

    def builtins_function(self, node):

        self.visit(node.parameters)
        self.visit(node.conversion_types)
        function_name = str(node.name)

        # MIN - MAX
        if function_name in ("min", "max"):
            self.builtins_function_min_max(node)

        # ABS
        elif function_name == "abs":
            self.builtins_function_abs(node)

        # SQRT
        elif function_name == "sqrt":
            self.builtins_function_sqrt(node)

        # LARGEST - SMALLEST
        elif function_name in ("largest", "smallest"):
            self.builtins_function_largest_smallest(node)

        else:
            # OTHER BUILTINS:
            _type, pictureDef, *__ = builtins[function_name]
            pictureClass = self.TYPE_TO_PICTURE[_type]
            if pictureDef is not None:
                _picture = pictureClass(value=pictureDef)
            else:
                _picture = ast.UnknownPicture()

            node.picture = _picture
            node.type = _type
            self.visit(node.basic_picture)

    @convert_type
    def visit_CallingFunction(self, node):
        if str(node.name) in builtins:
            self.builtins_function(node)
        else:
            self.visit(node.name)
            node.definition = node.name.definition
            if not isinstance(node.definition, ast.Function):
                return

            node.type = node.name.type
            node.picture = node.name.picture

            self.visit(node.parameters)
            self.visit(node.conversion_types)

            # For subroutines, the picture of numeric calling functions change.
            if node.definition.attributes:

                if isinstance(node.basic_type, (types.Integer, types.Decimal)):
                    picture = node.basic_picture.picture
                    if isinstance(picture, pictures.UnknownPicture):
                        assert(isinstance(node.basic_picture, (ast.FloatPicture, ast.DoublePicture)))
                    else:
                        total_digits, decimal_digits = picture.get_digits()
                        integer_digits = total_digits - decimal_digits

                        if node.basic_type is types.Integer():
                            pictureDef = '-%dZN' % (integer_digits - 1)

                        elif node.basic_type is types.Decimal():
                            if decimal_digits:
                                pictureDef = '-%dZN.%dN' % (integer_digits - 1, decimal_digits)
                            else:
                                pictureDef = '-%dZN.' % (integer_digits - 1)

                        pictureClass = self.TYPE_TO_PICTURE[node.basic_type]
                        node.picture = pictureClass(value=pictureDef)
                        self.visit(node.basic_picture)

            if not node.definition.annotated:
                self.function_stmt(node.definition)
