# -*- coding:utf-8 -*-
from delia_parser import ast
from delia_parser.scope import QuerySelectScope, QueryForScope, QueryScope
from collections import OrderedDict


class Alter:

    def visit_Alter(self, node):

        relation_name = node.relation_name
        alias_name = ast.Name(relation_name)

        # Find the scope of the Alter node.
        for scope in filter(lambda scope: isinstance(scope, (QuerySelectScope, QueryForScope)) and (scope.name == relation_name or scope.alias_name == relation_name), self.scopes):
            for_or_select_node = scope.node
            rel_definition = for_or_select_node.relation_name.definition
            if isinstance(rel_definition, ast.Relation):
                rel_definition.used = True
                relation_name.definition = rel_definition
                node.scope = scope
            break

        if not node.is_relation_declared:
            return

        self.visit(node.using_clauses)

        if node.using_clauses:
            using_clause = {clause.parametre: clause.data_expression for clause in node.using_clauses}
        else:
            using_clause = {}

        using_parametres = OrderedDict()

        scope = node.scope
        if scope:

            updated_datas = scope.updated_datas
            if using_clause or updated_datas:
                scope.node.got_alter = True
                node.to_skip = False

            relation_definition = relation_name.definition
            relation_datas = relation_definition.datas
            for data in relation_datas:
                # Prior to using clause.
                if data in using_clause:
                    using_parametres[data] = using_clause[data]
                elif data in updated_datas:
                    using_parametres[data] = ast.Id(data, of_name=alias_name, locations=node.locations)

        node.using_parametres = using_parametres
        self.visit(node.using_parametres.values())
