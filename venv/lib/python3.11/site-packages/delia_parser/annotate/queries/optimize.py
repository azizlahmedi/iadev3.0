from delia_parser import ast, types, scope

DEBUG = False
TRACE_UNSUPPORTED = False
SKIP_BUILTINS = False


operators_adl_to_sql = {
    ast.Eq: '=',
    ast.Gt: '>',
    ast.Ge: '>=',
    ast.Lt: '<',
    ast.Le: '<=',
    ast.Ne: '!=',
}


funtion_adl_to_sql = {
    'trim': 'RTRIM',
    'left.trim': 'LTRIM',
    'lower.case': 'LOWER',
    'upper.case': 'UPPER',
    'substr': 'SUBSTR',
    'position': 'INSTR',
    'length': 'LENGTH',
    'convert.histo.date': 'CONVERT_HISTO_DATE',
}


class RelationExpr:

    def __init__(self, name):
        self.name = name

    def __eq__(self, other):
        return str(self.name) == str(other.name)

    def __repr__(self):
        return '_REL_%s' % str(self.name).replace('.', '_').lower()


def is_cst_or_default(node, string_conversion_supported=False):
    if isinstance(node, (ast.Literal, ast.Default)):
        return is_conversion_supported(node, string_conversion_supported)
    if isinstance(node, ast.Id) and isinstance(node.definition, ast.Constant):
        return is_conversion_supported(node, string_conversion_supported)
    return False


def is_key_or_data(node, query_node, string_conversion_supported=False):
    if isinstance(node, ast.Id):
        if isinstance(node.scope, (scope.QueryScope,
                                   scope.JoinClauseScope,
                                   scope.WhereRoutineScope,
                                   scope.WhereClauseScope)) and node.scope.node == query_node:
            return is_conversion_supported(node, string_conversion_supported)
    return False


def is_id_not_from_query(node, query_node, string_conversion_supported=False):
    if isinstance(node, ast.ArrayId):
        return is_conversion_supported(node, string_conversion_supported)
    if isinstance(node, ast.Id):
        if isinstance(node.definition, ast.Field):
            if not isinstance(node.scope, (scope.QueryScope,
                                           scope.JoinClauseScope,
                                           scope.WhereRoutineScope,
                                           scope.WhereClauseScope)) or node.scope.node != query_node:
                return is_conversion_supported(node, string_conversion_supported)
    return False


def is_cst_or_default_or_id_not_from_query(node, query_node, string_conversion_supported=False):
    if is_cst_or_default(node, string_conversion_supported):
        return True
    return is_id_not_from_query(node, query_node, string_conversion_supported)


def is_key(node, query_node, string_conversion_supported=False):
    if is_key_or_data(node, query_node, string_conversion_supported):
        rel_definition = node.scope.relation_definition
        keys = rel_definition.keys
        if node.definition.name in keys:
            return True
    return False


def is_data(node, query_node, string_conversion_supported=False):
    if is_key_or_data(node, query_node, string_conversion_supported):
        rel_definition = node.scope.relation_definition
        datas = rel_definition.datas
        if node.definition.name in datas:
            return True
    return False


def is_index(node, query_node):
    if is_key_or_data(node, query_node):
        rel_definition = node.scope.relation_definition
        indexes = rel_definition.indexes
        for index in indexes:
            if len(index) == 1 and node.definition.name in index:
                return True
    return False


def is_conversion_supported(node, string_conversion_supported=False):
    if node.conversion_types:
        if not string_conversion_supported or SKIP_BUILTINS:
            return False
        elif len(node.conversion_types) == 1 and (node.basic_type == node.conversion_types[0].type == types.String()):
            return True
        else:
            return False
    else:
        return True


def are_equals(node1, node2, query_node):
    if is_key_or_data(node1, query_node) and \
        is_key_or_data(node2, query_node) and \
            node1.definition.name == node2.definition.name:
        return True
    return False


def is_supported_builtins(node, query_node, string_conversion_supported=False):

    assert(isinstance(node, ast.CallingFunction))

    if SKIP_BUILTINS:
        return False

    if not is_conversion_supported(node, string_conversion_supported):
        return False

    function_name = str(node.name).lower()

    if function_name in ("trim", 'left.trim', 'lower.case', 'upper.case', 'substr', 'position', 'length'):

        if not node.parameters:
            return False

        if function_name in ("trim", 'left.trim', 'lower.case', 'upper.case', 'length'):
            if len(node.parameters) != 1:
                return False

        elif function_name in ("substr", "position"):
            if len(node.parameters) not in (2, 3):
                return False

        for param in node.parameters:
            acceptable = (is_key_or_data(param, query_node, string_conversion_supported) or
                          is_cst_or_default(param, string_conversion_supported))
            if not acceptable:
                return False

        return True

    return False


def _walk_to_find_what_to_replace(parent_clause, current_clause, clause_to_remove):

    if current_clause is clause_to_remove:

        if parent_clause:

            if parent_clause.left is current_clause:
                new_clause = parent_clause.right

            elif parent_clause.right is current_clause:
                new_clause = parent_clause.left

            elif isinstance(parent_clause.left, ast.Enclosed) and parent_clause.left.left is current_clause:
                new_clause = parent_clause.right

            elif isinstance(parent_clause.right, ast.Enclosed) and parent_clause.right.left is current_clause:
                new_clause = parent_clause.left

            else:
                raise NotImplementedError("Not Implemented")

            return parent_clause, new_clause
        else:
            return current_clause, None

    elif isinstance(current_clause, ast.Enclosed):
        return _walk_to_find_what_to_replace(parent_clause=parent_clause, current_clause=current_clause.left, clause_to_remove=clause_to_remove)

    elif not isinstance(current_clause, ast.Rel):
        res = _walk_to_find_what_to_replace(parent_clause=current_clause, current_clause=current_clause.left, clause_to_remove=clause_to_remove)
        if res:
            return res
        return _walk_to_find_what_to_replace(parent_clause=current_clause, current_clause=current_clause.right, clause_to_remove=clause_to_remove)
    else:
        return None


def _walk_to_replace(where_clause, parent_clause, current_clause, clause_to_replace, replacement):
    if current_clause is clause_to_replace:

        if parent_clause:

            if parent_clause.left is current_clause:
                parent_clause.left = replacement

            elif parent_clause.right is current_clause:
                parent_clause.right = replacement

            elif isinstance(parent_clause.left, ast.Enclosed) and parent_clause.left.left is current_clause:
                parent_clause.left = replacement

            elif isinstance(parent_clause.right, ast.Enclosed) and parent_clause.right.left is current_clause:
                parent_clause.right = replacement

            else:
                raise NotImplementedError("Not Implemented")
        else:
            where_clause.clause = replacement

        return True

    elif isinstance(current_clause, ast.Enclosed):
        _walk_to_replace(where_clause=where_clause, parent_clause=parent_clause, current_clause=current_clause.left, clause_to_replace=clause_to_replace, replacement=replacement)

    elif not isinstance(current_clause, ast.Rel):
        res = _walk_to_replace(where_clause=where_clause, parent_clause=current_clause, current_clause=current_clause.left, clause_to_replace=clause_to_replace, replacement=replacement)
        if res:
            return
        _walk_to_replace(where_clause=where_clause, parent_clause=current_clause, current_clause=current_clause.right, clause_to_replace=clause_to_replace, replacement=replacement)

    else:
        return False


def remove_clauses_from_where_clauses(where_clause, clause_to_removes):
    for clause_to_remove in clause_to_removes:
        clause_before, clause_after = _walk_to_find_what_to_replace(None, where_clause.clause, clause_to_remove)
        _walk_to_replace(where_clause, None, where_clause.clause, clause_before, clause_after)
    if not where_clause.clause:
        where_clause = None
    return where_clause


def convert_clause_to_expression(query_node, clause, values=None):
    if values is None:
        values = []

    if isinstance(clause, ast.Enclosed):
        result = convert_clause_to_expression(query_node, clause.left, values)
        if not result:
            # Error case
            return None
        expression, values = result
        expression = ("Enclosed", expression)
        return expression, values

    elif isinstance(clause, ast.ExtendedComparison):
        exprs = []
        for exp in clause.exps:
            result = convert_clause_to_expression(query_node, exp, values)
            if not result:
                # Error case
                return None
            expression, values = result
            exprs.append(expression)
        if isinstance(clause, ast.ExtendedComparisonAnd):
            return ("Enclosed", ("And", exprs)), values
        else:
            return ("Enclosed", ("Or", exprs)), values

    elif isinstance(clause, ast.Rel):

        op = operators_adl_to_sql[type(clause)]

        def convert_expr(expr):

            if isinstance(expr, ast.CallingFunction):

                function_name = funtion_adl_to_sql.get(str(expr.name).lower(), None)
                if not function_name:
                    # Error case
                    return None
                param_exprs = [convert_expr(param) for param in expr.parameters]
                if None in param_exprs:
                    # Error case
                    return None
                clause_expr = (function_name, param_exprs)

            elif is_key_or_data(expr, query_node, string_conversion_supported=True):
                clause_expr = (RelationExpr(expr.scope.name), str(expr.name).replace('.', '_').lower())

            elif is_cst_or_default_or_id_not_from_query(expr, query_node, string_conversion_supported=True):
                assert(not isinstance(expr, ast.Default))
                clause_expr = ('var', len(values))
                values.append(expr)

            else:
                # Error case
                return None

            conversion_types = expr.conversion_types
            if conversion_types:
                assert(len(conversion_types) == 1)
                assert(expr.basic_type == conversion_types[0].type == types.String())
                size = conversion_types[0].picture.size
                clause_expr = ('RPAD', [clause_expr, int(size), ' '])

            return clause_expr

        if isinstance(clause.left, ast.Default):
            assert(isinstance(clause.right, ast.Id))
            assert(not isinstance(clause.right, ast.Default))
            values.append((clause.left, clause.right))
            expr_left = ('var', len(values))
            expr_right = convert_expr(clause.right)
            if not expr_right:
                # Error case
                return None
            conversion_types = clause.right.conversion_types
            if conversion_types:
                if (len(conversion_types) == 1) and (clause.left.basic_type == conversion_types[0].type == types.String()):
                    expression = (op, [("RTRIM", [expr_left]), ("RTRIM", [expr_right])])
                else:
                    # Error case
                    return None
            else:
                expression = (op, [expr_left, expr_right])

        elif isinstance(clause.right, ast.Default):
            assert(isinstance(clause.left, ast.Id))
            assert(not isinstance(clause.left, ast.Default))
            expr_left = convert_expr(clause.left)
            if not expr_left:
                # Error case
                return None
            expr_right = ('var', len(values))
            values.append((clause.right, clause.left))
            conversion_types = clause.left.conversion_types
            if conversion_types:
                if (len(conversion_types) == 1) and (clause.left.basic_type == conversion_types[0].type == types.String()):
                    expression = (op, [("RTRIM", [expr_left]), ("RTRIM", [expr_right])])
                else:
                    # Error case
                    return None
            else:
                expression = (op, [expr_left, expr_right])

        elif is_key_or_data(clause.left, query_node) and is_cst_or_default_or_id_not_from_query(clause.right, query_node):
            field = clause.left
            value = clause.right
            expr = (RelationExpr(clause.left.scope.name), str(field.name).replace('.', '_').lower())
            expression = (op, [expr, ('var', len(values))])
            values.append((value, field))

        elif is_key_or_data(clause.right, query_node) and is_cst_or_default_or_id_not_from_query(clause.left, query_node):
            field = clause.right
            value = clause.left
            expr = (RelationExpr(clause.right.scope.name), str(field.name).replace('.', '_').lower())
            expression = (op, [('var', len(values)), expr])
            values.append((value, field))

        elif is_cst_or_default_or_id_not_from_query(clause.left, query_node) and is_cst_or_default_or_id_not_from_query(clause.right, query_node):
            exprs = []

            if clause.right.type is types.String() and \
                    clause.right.picture.size != clause.left.picture.size:
                assert(clause.left.type is types.String())
                exprs.append(('RTRIM', [('var', len(values))]))
                values.append(clause.left)
                exprs.append(('RTRIM', [('var', len(values))]))
                values.append(clause.right)
            else:
                exprs.append(('var', len(values)))
                values.append(clause.left)
                exprs.append(('var', len(values)))
                values.append(clause.right)

            expression = (op, exprs)

        else:
            expr_left = convert_expr(clause.left)
            expr_right = convert_expr(clause.right)
            if not expr_left or not expr_right:
                # Error case
                return None
            if clause.right.type is types.String():
                assert(clause.left.type is types.String())
                if not is_key_or_data(clause.left, query_node):
                    expr_left = ("RTRIM", [expr_left])
                if not is_key_or_data(clause.right, query_node):
                    expr_right = ("RTRIM", [expr_right])
            expression = (op, [expr_left, expr_right])

        return expression, values

    elif isinstance(clause, (ast.And, ast.Or)):
        kind = "And" if isinstance(clause, ast.And) else "Or"
        result = convert_clause_to_expression(query_node, clause.left, values)
        if not result:
            # Error case
            return None
        expr_left, values = result
        result = convert_clause_to_expression(query_node, clause.right, values)
        if not result:
            # Error case
            return None
        expr_right, values = result
        expression = (kind, [expr_left, expr_right])
        return expression, values

    else:
        # Error case
        return None


class Optimize:

    ##########################
    # Check VIA is a VIA KEY.#
    ##########################

    def optimize_via_clause(self, query_node):

        qualified_rel_alias = query_node.qualified_rel_alias
        relation_name = qualified_rel_alias.relation_name
        rel_definition = relation_name.definition

        if not isinstance(rel_definition, ast.Relation):
            return

        keys = rel_definition.keys
        via_clause = qualified_rel_alias.via_clause

        # Nothing to optimize.
        if isinstance(via_clause, ast.ViaKeyClause) or via_clause is None:
            return

        def check_via_clause_as_via_key():
            if isinstance(via_clause, ast.ViaClause):
                via_keys = []
                for exp in via_clause.lkey_value:
                    if isinstance(exp, ast.Id):
                        via_keys.append(exp.name)
                    elif isinstance(exp, ast.Eq):
                        assert(isinstance(exp.left, ast.Id))
                        via_keys.append(exp.left.name)
                    else:
                        return False
                if sorted(str(key) for key in via_keys) == sorted(str(key) for key in keys):
                    return True
                else:
                    return False
            else:
                return False

        if check_via_clause_as_via_key():
            lkey_value_reordered = []
            for key in keys:
                lkey_value_reordered.extend([exp for exp in via_clause.lkey_value if key == (exp.name if isinstance(exp, ast.Id) else exp.left.name)])
            qualified_rel_alias.via_clause = ast.ViaKeyClause()
            qualified_rel_alias.via_clause.lkey_value = lkey_value_reordered

    def list_in_where_clause_ids_not_from_query(self, query_node):

        qualified_rel_alias = query_node.qualified_rel_alias
        relation_name = qualified_rel_alias.relation_name
        rel_definition = relation_name.definition
        where_clause = qualified_rel_alias.where_clause

        if not isinstance(rel_definition, ast.Relation):
            return []

        # No where clause.
        if not where_clause:
            return []

        ids_not_from_query = []

        def find_ids_not_from_query(clause):

            if isinstance(clause, ast.Enclosed):
                find_ids_not_from_query(clause.left)

            elif isinstance(clause, ast.ExtendedComparison):
                for exp in clause.exps:
                    find_ids_not_from_query(exp)

            elif isinstance(clause, ast.Rel):

                if is_id_not_from_query(clause.right, query_node, string_conversion_supported=True):
                    ids_not_from_query.append(clause.right)

                if is_id_not_from_query(clause.left, query_node, string_conversion_supported=True):
                    ids_not_from_query.append(clause.left)

            elif isinstance(clause, (ast.And, ast.Or)):
                find_ids_not_from_query(clause.left)
                find_ids_not_from_query(clause.right)

            elif isinstance(clause, (ast.Eqv, ast.Xor)):
                return

            elif isinstance(clause, ast.Boolean):
                return

            else:
                raise Exception()

        find_ids_not_from_query(where_clause.clause)

        return ids_not_from_query

    ##############################################
    # Check WHERE clause can move to VIA clause. #
    ##############################################

    def optimize_where_clause(self, query_node, all_datas=False, ids_not_assigned=[]):

        qualified_rel_alias = query_node.qualified_rel_alias
        relation_name = qualified_rel_alias.relation_name
        rel_definition = relation_name.definition
        via_clause = qualified_rel_alias.via_clause
        where_clause = qualified_rel_alias.where_clause

        if not isinstance(rel_definition, ast.Relation):
            return

        # No where clause.
        if not where_clause:
            return

        # Should be found at the validation level.
        if not isinstance(where_clause.clause, ast.Logical):
            return

        clauses_to_move_from_where_to_via = []
        clauses_to_remove_from_where = []

        def check_what_clause_to_move_from_where_to_via(clause):

            if isinstance(clause, ast.Enclosed):
                check_what_clause_to_move_from_where_to_via(clause.left)

            elif isinstance(clause, ast.Rel):

                if are_equals(clause.left, clause.right, query_node):
                    clauses_to_remove_from_where.append(clause)

                elif is_key(clause.left, query_node) and is_cst_or_default_or_id_not_from_query(clause.right, query_node):
                    clauses_to_move_from_where_to_via.append(clause)

                elif is_data(clause.left, query_node):
                    if is_cst_or_default(clause.right):
                        clauses_to_move_from_where_to_via.append(clause)
                    elif is_id_not_from_query(clause.right, query_node) and (
                            is_index(clause.left, query_node) or all_datas or clause.right in ids_not_assigned):
                        clauses_to_move_from_where_to_via.append(clause)

                elif is_key(clause.right, query_node) and is_cst_or_default_or_id_not_from_query(clause.left, query_node):
                    clauses_to_move_from_where_to_via.append(clause)

                elif is_data(clause.right, query_node):
                    if is_cst_or_default(clause.left):
                        clauses_to_move_from_where_to_via.append(clause)
                    elif is_id_not_from_query(clause.left, query_node) and (
                            is_index(clause.right, query_node) or all_datas or clause.left in ids_not_assigned):
                        clauses_to_move_from_where_to_via.append(clause)

            elif isinstance(clause, ast.And):
                check_what_clause_to_move_from_where_to_via(clause.left)
                check_what_clause_to_move_from_where_to_via(clause.right)

            elif isinstance(clause, (ast.Or, ast.Eqv, ast.Xor)):
                pass

            else:
                raise Exception()

        check_what_clause_to_move_from_where_to_via(where_clause.clause)

        if not clauses_to_move_from_where_to_via and not clauses_to_remove_from_where:
            return

        if DEBUG:
            print(">" * 10)
            print("BEFORE: via_clause", via_clause.lkey_value if hasattr(via_clause, 'lkey_value') else None)
            print("BEFORE: where_clause", where_clause.clause if hasattr(where_clause, 'clause') else None)
            print("> TO MOVE:", clauses_to_move_from_where_to_via)
            print("> TO REMOVE:", clauses_to_remove_from_where)

        # ViaKey to Via
        if isinstance(via_clause, ast.ViaKeyClause):
            via_clause = ast.ViaClause(via_clause.lkey_value)

        ################
        # Optimize VIA.#
        ################
        for clause in clauses_to_move_from_where_to_via:

            new_clause = clause

            # Move to the left relation key or data relation.
            if isinstance(clause, ast.Rel):
                if is_key_or_data(clause.right, query_node):
                    if isinstance(clause, ast.Eq):
                        new_clause = ast.Eq(left=ast.ViaFieldId(clause.right.name), right=clause.left)
                    if isinstance(clause, ast.Ne):
                        new_clause = ast.Ne(left=ast.ViaFieldId(clause.right.name), right=clause.left)
                    if isinstance(clause, ast.Ge):
                        new_clause = ast.Le(left=ast.ViaFieldId(clause.right.name), right=clause.left)
                    if isinstance(clause, ast.Gt):
                        new_clause = ast.Lt(left=ast.ViaFieldId(clause.right.name), right=clause.left)
                    if isinstance(clause, ast.Le):
                        new_clause = ast.Ge(left=ast.ViaFieldId(clause.right.name), right=clause.left)
                    if isinstance(clause, ast.Lt):
                        new_clause = ast.Gt(left=ast.ViaFieldId(clause.right.name), right=clause.left)
                elif is_key_or_data(clause.left, query_node):
                    if isinstance(clause, ast.Eq):
                        new_clause = ast.Eq(left=ast.ViaFieldId(clause.left.name), right=clause.right)
                    if isinstance(clause, ast.Ne):
                        new_clause = ast.Ne(left=ast.ViaFieldId(clause.left.name), right=clause.right)
                    if isinstance(clause, ast.Ge):
                        new_clause = ast.Ge(left=ast.ViaFieldId(clause.left.name), right=clause.right)
                    if isinstance(clause, ast.Gt):
                        new_clause = ast.Gt(left=ast.ViaFieldId(clause.left.name), right=clause.right)
                    if isinstance(clause, ast.Le):
                        new_clause = ast.Le(left=ast.ViaFieldId(clause.left.name), right=clause.right)
                    if isinstance(clause, ast.Lt):
                        new_clause = ast.Lt(left=ast.ViaFieldId(clause.left.name), right=clause.right)
                else:
                    raise Exception

            if not via_clause:
                via_clause = ast.ViaClause([new_clause])
            else:
                via_clause.lkey_value.append(new_clause)

        ##################
        # Optimize WHERE.#
        ##################

        where_clause = remove_clauses_from_where_clauses(where_clause, clauses_to_remove_from_where + clauses_to_move_from_where_to_via)

        if DEBUG:
            print("AFTER: via_clause", via_clause.lkey_value if hasattr(via_clause, 'lkey_value') else None)
            print("AFTER: where_clause", where_clause.clause if hasattr(where_clause, 'clause') else None)
            print("<" * 10)

        qualified_rel_alias.via_clause = via_clause
        qualified_rel_alias.where_clause = where_clause

        previous_scopes = []
        while 1:
            if self.current_scope == query_node.parent_scope:
                break
            previous_scope = self.scopes.popleft()
            previous_scopes.append(previous_scope)

        self.visit(qualified_rel_alias.via_clause)

        for last_scope in previous_scopes:
            self.scopes.appendleft(last_scope)

        # Re-optimize via clause !
        self.optimize_via_clause(query_node)

    def jsonize_via_clause(self, query_node):

        qualified_rel_alias = query_node.qualified_rel_alias
        relation_name = qualified_rel_alias.relation_name
        rel_definition = relation_name.definition
        via_clause = qualified_rel_alias.via_clause

        if not isinstance(rel_definition, ast.Relation):
            return

        columns = rel_definition.columns

        if via_clause is None:
            return

        expressions = []
        values = []

        for pos, via_key in enumerate(via_clause.lkey_value):

            if isinstance(via_key, ast.Rel):

                if via_key.left.name in columns:
                    ident = (RelationExpr(relation_name), str(via_key.left.name).replace('.', '_').lower())
                else:
                    # Error case.
                    return

                operators = {
                    ast.Eq: '=',
                    ast.Gt: '>',
                    ast.Ge: '>=',
                    ast.Lt: '<',
                    ast.Le: '<=',
                    ast.Ne: '!=',
                }

                op = operators[type(via_key)]
                expressions.append((op, [ident, ('var', pos)]))
                values.append((via_key.right, via_key.left))

            elif isinstance(via_key, ast.ImplicitSelect):

                if via_key.field_name in columns:
                    ident = (RelationExpr(relation_name), str(via_key.field_name).replace('.', '_').lower())
                else:
                    # Error case.
                    return

                expressions.append(('=', [ident, ('var', pos)]))
                values.append(via_key)

            elif isinstance(via_key, ast.Id):

                if via_key.name in columns:
                    ident = (RelationExpr(relation_name), str(via_key.name).replace('.', '_').lower())
                else:
                    # Error case.
                    return

                expressions.append(('=', [ident, ('var', pos)]))
                values.append(via_key)

        if len(expressions) > 1:
            qualified_rel_alias.via_expressions = ("And", expressions)
        elif len(expressions) == 1:
            qualified_rel_alias.via_expressions = expressions[0]
        else:
            qualified_rel_alias.via_expressions = ()

        qualified_rel_alias.via_values = values
        qualified_rel_alias.is_via_key = isinstance(via_clause, ast.ViaKeyClause)

        if DEBUG:
            print("via_expressions", qualified_rel_alias.via_expressions)
            print("via_values", qualified_rel_alias.via_values)
            print("is_via_key", qualified_rel_alias.is_via_key)

    def optimize_where_clause_better_for_permdb(self, query_node, all_datas=False, ids_not_assigned=[]):

        qualified_rel_alias = query_node.qualified_rel_alias
        relation_name = qualified_rel_alias.relation_name
        rel_definition = relation_name.definition
        where_clause = qualified_rel_alias.where_clause
        via_expressions = qualified_rel_alias.via_expressions
        via_values = qualified_rel_alias.via_values

        if not isinstance(rel_definition, ast.Relation):
            return

        # No where clause.
        if not where_clause:
            return

        def check_can_convert_where_to_via(clause):

            if isinstance(clause, ast.Enclosed):
                return check_can_convert_where_to_via(clause.left)

            elif isinstance(clause, ast.ExtendedComparison):
                for exp in clause.exps:
                    if not check_can_convert_where_to_via(exp):
                        return False
                return True

            elif isinstance(clause, ast.Rel):

                left_is_key_or_data = is_key_or_data(clause.left, query_node, string_conversion_supported=True)
                if left_is_key_or_data:
                    left_is_cst_or_default_or_id_not_from_query = False
                    left_is_key = is_key(clause.left, query_node, string_conversion_supported=True)
                    left_is_data = not left_is_key
                    if left_is_data:
                        left_is_data_indexed = is_index(clause.left, query_node)
                    else:
                        left_is_data_indexed = False
                else:
                    left_is_key = False
                    left_is_data = False
                    left_is_data_indexed = False
                    left_is_cst_or_default_or_id_not_from_query = is_cst_or_default_or_id_not_from_query(clause.left, query_node, string_conversion_supported=True)

                if left_is_cst_or_default_or_id_not_from_query:
                    left_is_cst_or_default = is_cst_or_default(clause.left, string_conversion_supported=True)
                    if left_is_cst_or_default:
                        left_is_id_not_from_query = False
                    else:
                        left_is_id_not_from_query = True
                else:
                    left_is_cst_or_default = False
                    left_is_id_not_from_query = False

                right_is_key_or_data = is_key_or_data(clause.right, query_node, string_conversion_supported=True)
                if right_is_key_or_data:
                    right_is_key = is_key(clause.right, query_node, string_conversion_supported=True)
                    right_is_data = not right_is_key
                    if right_is_data:
                        right_is_data_indexed = is_index(clause.right, query_node)
                    else:
                        right_is_data_indexed = False
                    right_is_cst_or_default_or_id_not_from_query = False
                else:
                    right_is_key = False
                    right_is_data = False
                    right_is_data_indexed = False
                    right_is_cst_or_default_or_id_not_from_query = is_cst_or_default_or_id_not_from_query(clause.right, query_node, string_conversion_supported=True)

                if right_is_cst_or_default_or_id_not_from_query:
                    right_is_cst_or_default = is_cst_or_default(clause.right, string_conversion_supported=True)
                    if right_is_cst_or_default:
                        right_is_id_not_from_query = False
                    else:
                        right_is_id_not_from_query = True
                else:
                    right_is_cst_or_default = False
                    right_is_id_not_from_query = False

                left_is_id_not_from_query_not_assigned = left_is_id_not_from_query and (all_datas or clause.left in ids_not_assigned)
                right_is_id_not_from_query_not_assigned = right_is_id_not_from_query and (all_datas or clause.right in ids_not_assigned)

                # Same as VIAKEY (but with OR supported)
                if ((left_is_key and right_is_cst_or_default_or_id_not_from_query) or
                    (left_is_data_indexed and right_is_cst_or_default_or_id_not_from_query) or
                    (left_is_data and right_is_cst_or_default) or
                    (left_is_data and right_is_id_not_from_query_not_assigned) or
                    (left_is_cst_or_default_or_id_not_from_query and right_is_key) or
                    (left_is_cst_or_default_or_id_not_from_query and right_is_data_indexed) or
                    (left_is_cst_or_default and right_is_data) or
                    (left_is_id_not_from_query_not_assigned and right_is_data)
                ):
                    return True

                # Both key or data
                if left_is_key_or_data and right_is_key_or_data:
                    return True

                # Check Both constant
                if left_is_cst_or_default and right_is_cst_or_default:
                    return True

                # Both Id not assigned
                if left_is_id_not_from_query_not_assigned and right_is_id_not_from_query_not_assigned:
                    return True

                # Id not assigned and constant
                if (left_is_id_not_from_query_not_assigned and right_is_cst_or_default) or \
                        (right_is_id_not_from_query_not_assigned and left_is_cst_or_default):
                    return True

                if not (left_is_key_or_data or left_is_cst_or_default_or_id_not_from_query):
                    left_is_supported_builtins = isinstance(clause.left, ast.CallingFunction) and is_supported_builtins(clause.left, query_node, string_conversion_supported=True)
                else:
                    left_is_supported_builtins = False

                if not (right_is_key_or_data or right_is_cst_or_default_or_id_not_from_query):
                    right_is_supported_builtins = isinstance(clause.right, ast.CallingFunction) and is_supported_builtins(clause.right, query_node, string_conversion_supported=True)
                else:
                    right_is_supported_builtins = False

                # Check if a supported builtin
                if left_is_supported_builtins and right_is_supported_builtins:
                    return True

                if left_is_supported_builtins and (right_is_key_or_data or right_is_cst_or_default):
                    return True

                if right_is_supported_builtins and (left_is_key_or_data or left_is_cst_or_default):
                    return True

                return False

            elif isinstance(clause, (ast.And, ast.Or)):
                if not check_can_convert_where_to_via(clause.left):
                    return False
                return check_can_convert_where_to_via(clause.right)

            elif isinstance(clause, (ast.Eqv, ast.Xor)):
                return False

            else:
                raise Exception()

        optimizable = check_can_convert_where_to_via(where_clause.clause)
        if not optimizable:

            if TRACE_UNSUPPORTED:
                print("_" * 20)
                print(qualified_rel_alias.relation_name.definition.columns)
                print(where_clause.clause)

            return

        if DEBUG:
            print(">" * 10)
            print("BEFORE: where_clause", where_clause.clause if hasattr(where_clause, 'clause') else None)
            print("BEFORE: via_expressions", via_expressions)
            print("BEFORE: via_values", via_values)
            print("BEFORE: is_via_key", qualified_rel_alias.is_via_key)

        result = convert_clause_to_expression(query_node, where_clause.clause, via_values)
        assert(result)
        expressions, via_values = result

        # Remove or Add Enclosed expression
        if via_expressions == ():
            if expressions[0] == 'Enclosed':
                expressions = expressions[1]
        else:
            expressions = ('Enclosed', expressions)

        if via_expressions == ():
            qualified_rel_alias.via_expressions = expressions
        elif via_expressions[0] == "And":
            qualified_rel_alias.via_expressions[1].append(expressions)
        else:
            qualified_rel_alias.via_expressions = ("And", [via_expressions] + [expressions])

        qualified_rel_alias.is_via_key = False
        qualified_rel_alias.is_where_optimized = True

        if DEBUG:
            print("AFTER: via_expressions", qualified_rel_alias.via_expressions)
            print("AFTER: via_values", qualified_rel_alias.via_values)
            print("AFTER: is_via_key", qualified_rel_alias.is_via_key)
            print("<" * 10)

    def jsonize_join_clause(self, query_node):
        qualified_rel_alias = query_node.qualified_rel_alias
        join_clause_list = qualified_rel_alias.join_clause_list
        relation_name = qualified_rel_alias.relation_name
        rel_definition = relation_name.definition

        if not isinstance(rel_definition, ast.Relation):
            return

        # No join clause.
        if not join_clause_list:
            return

        for join_clause in join_clause_list:

            if DEBUG:
                print(">" * 10)
                print("BEFORE: join_clause", join_clause.clause if hasattr(join_clause, 'clause') else None)

            result = convert_clause_to_expression(query_node, join_clause.clause)
            if not result:
                # Error case, catch by the validator.
                join_clause.join_expressions = join_clause.join_values = None
            else:
                join_clause.join_expressions, join_clause.join_values = result

            if DEBUG:
                print("AFTER: join_expressions", join_clause.join_expressions)
                print("AFTER: join_values", join_clause.join_values)
                print("<" * 10)
