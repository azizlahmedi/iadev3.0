# -*- coding:utf-8 -*-
from delia_parser import ast, types
from delia_parser.annotate.queries.alter import Alter
from delia_parser.annotate.queries.select import Select
from delia_parser.annotate.queries.insert import Insert
from delia_parser.annotate.queries.foreach import Foreach
from delia_parser.annotate.queries.delete import Delete
from delia_parser.annotate.queries.optimize import (
    Optimize,
    RelationExpr,
    is_cst_or_default_or_id_not_from_query,
    is_key_or_data,
    is_index,
)
from delia_parser.annotate.convert_type import convert_type
import operator
from _functools import reduce

from delia_parser.scope import (
    QueryScope,
    QuerySelectScope,
    QueryForScope,
    InnerJoinClauseScope,
    LeftOuterJoinClauseScope,
    WhereRoutineScope,
    WhereClauseScope,
    RightOuterJoinClauseScope,
    FullOuterJoinClauseScope
    )
from copy import deepcopy


class Query(Alter,
            Select,
            Insert,
            Foreach,
            Delete,
            Optimize):

    sql_function_default_value = {types.Date(): "_date(year=1752, month=9, day=14)",
                                  types.String(): "_(' ')",
                                  types.Integer(): '0',
                                  types.Decimal(): '0'}

    def visit_Changing(self, node):
        field = node.left
        self.visit(field)
        scope = field.scope
        if isinstance(scope, QueryScope):
            if isinstance(scope.node, ast.For):
                scope.node.got_changing = True

    def visit_NotChanging(self, node):
        self.visit_Changing(node)

    @convert_type
    def visit_AggregateFunction(self, node):
        name = node.name
        parameters = node.parameters
        for param in parameters:
            self.visit_RelationFieldId(param)

        if len(parameters) == 1:

            param = parameters[0]

            if isinstance(param.definition, ast.Field):
                # TODO: pyname et sql Ã  deplacer dans le code_gen.
                param_scope = param.scope
                param_pyname = str(param.name).lower().replace('.', '_')
                param_scope_name = param_scope.name

                if isinstance(param_scope, QueryScope):

                    funtion_adl_to_sql = {
                        'r.count': 'count',
                        'r.sum': 'sum',
                        'r.avg': 'avg',
                        'r.min': 'min',
                        'r.max': 'max',
                    }

                    sql_funtion = funtion_adl_to_sql[str(name).lower()].upper()

                    if sql_funtion in ('SUM', 'AVG'):
                        node.type = types.Decimal()
                        node.picture = ast.UnknownPicture()
                        self.visit(node.basic_picture)

                    if sql_funtion == ('COUNT'):
                        node.type = types.Integer()
                        node.picture = ast.UnknownPicture()
                        self.visit(node.basic_picture)

                    elif sql_funtion in ('MIN', 'MAX'):
                        node.type = param.type
                        node.picture = param.picture

                    expression = (sql_funtion, self.sql_function_default_value[node.type], [(RelationExpr(param_scope_name), param_pyname)])
                    node.position = param_scope.add_fetched_expression(expression)

    def relation_name_alias(self, relation_name, alias_name):
        self.visit_Name(relation_name)
        if alias_name is not None:
            alias_name.definition = relation_name.definition

    def rebuild_viakey_clause(self, node):
        # Purpose: create the scope of the keys in order to check fetched columns.
        relation_name = node.relation_name
        rel_definition = relation_name.definition
        via_clause = node.qualified_rel_alias.via_clause

        if isinstance(rel_definition, ast.Relation) and \
                isinstance(via_clause, ast.ViaKeyClause) and \
                not via_clause.lkey_value:
            via_keys = rel_definition.keys
            lkey_value = []
            for key in via_keys:
                lkey_value.append(ast.Id(key, locations=node.locations))
            via_clause.lkey_value = lkey_value
            self.visit(via_clause)

    def rebuild_sort_list(self, node):
        relation_name = node.relation_name
        rel_definition = relation_name.definition
        indexes = rel_definition.indexes
        columns = rel_definition.columns
        qualified_rel_alias = node.qualified_rel_alias

        if (isinstance(node, (ast.For, ast.Select)) and
                self.procedure_scope.in_schema(relation_name) and
                indexes and
                qualified_rel_alias.where_clause and
                not qualified_rel_alias.via_clause and
                not qualified_rel_alias.sorted_clause and
                not qualified_rel_alias.join_clause_list and
                not qualified_rel_alias.grouped_clause):

            relation_col_name_from_where_clause = set()
            index_name_from_where_clause = set()

            def collect_info_from_where_clause(clause):

                if isinstance(clause, ast.Enclosed):
                    collect_info_from_where_clause(clause.left)

                elif isinstance(clause, ast.Rel):

                    if (is_key_or_data(clause.left, node) and
                            is_cst_or_default_or_id_not_from_query(clause.right, node)):

                        relation_col_name_from_where_clause.add(clause.left.name)

                        if is_index(clause.left, node):
                            index_name_from_where_clause.add(clause.left.name)

                    if (is_key_or_data(clause.right, node) and
                            is_cst_or_default_or_id_not_from_query(clause.left, node)):

                        relation_col_name_from_where_clause.add(clause.right.name)

                        if is_index(clause.right, node):
                            index_name_from_where_clause.add(clause.right.name)

                elif isinstance(clause, ast.And):
                    collect_info_from_where_clause(clause.left)
                    collect_info_from_where_clause(clause.right)

                elif isinstance(clause, (ast.Or, ast.Eqv, ast.Xor)):
                    pass

                else:
                    raise Exception()

            collect_info_from_where_clause(qualified_rel_alias.where_clause.clause)

            if index_name_from_where_clause:

                index_pos = None
                index_name = None
                for name in index_name_from_where_clause:
                    current_indice_pos = columns.index(name)
                    if index_pos is None or current_indice_pos <= index_pos:
                        index_pos = current_indice_pos
                        index_name = name

                relation_col_pos_from_where_clause = [columns.index(name) for name in relation_col_name_from_where_clause]

                if 0 in relation_col_pos_from_where_clause:
                    is_index_to_sort = False
                else:
                    is_index_to_sort = True

                if is_index_to_sort:
                    sorted_clause = ast.SortedOnClause([ast.SortItem(ast.Ascending(), ast.RelationFieldId(index_name, locations=node.locations))], locations=node.locations)
                    self.visit(sorted_clause)
                    qualified_rel_alias.sorted_clause = sorted_clause

    def build_sort_list(self, node):
        relation_name = node.relation_name
        rel_definition = relation_name.definition
        qualified_rel_alias = node.qualified_rel_alias
        sorted_clause = qualified_rel_alias.sorted_clause
        join_clause_list = qualified_rel_alias.join_clause_list
        grouped_clause = qualified_rel_alias.grouped_clause

        implicit_sort = not join_clause_list and not grouped_clause
        sort_list = []

        self.visit(sorted_clause)

        if isinstance(rel_definition, ast.Relation):
            keys = rel_definition.keys

            if isinstance(sorted_clause, ast.SortedOnClause):
                sort_list += sorted_clause.sort_list

                if implicit_sort:
                    items = [item.field.name for item in sort_list]
                    for key in keys:
                        if key not in items:
                            sort_list.append(ast.SortItem(ast.Ascending(), ast.RelationFieldId(key, locations=node.locations), locations=node.locations))

            elif isinstance(sorted_clause, ast.SortedClause):
                direction_instance = sorted_clause.direction
                sort_list += [ast.SortItem(direction_instance, ast.RelationFieldId(field, locations=node.locations), locations=node.locations) for field in keys]

            elif implicit_sort:
                sort_list += [ast.SortItem(ast.Ascending(), ast.RelationFieldId(key, locations=node.locations), locations=node.locations) for key in keys]

        self.visit(sort_list)
        qualified_rel_alias.sort_list = sort_list

    def update_datas_and_others_fields(self, field):
        if isinstance(field.definition, ast.Field):
            scope = field.scope
            if isinstance(scope, (QuerySelectScope, QueryForScope)):
                scope.add_updated_datas(field.name)
        for scope in self.scopes:
            if isinstance(scope, QueryScope) and field in scope.ids_not_from_query:
                scope.ids_not_from_query.remove(field)

    def select(self, node):

        is_foreach = isinstance(node, ast.For)

        relation_name = node.relation_name
        alias_name = node.alias_name
        qualified_rel_alias = node.qualified_rel_alias

        self.relation_name_alias(relation_name, alias_name)

        if not node.is_relation_declared:
            return

        rel_definition = relation_name.definition
        rel_definition.used = True

        if is_foreach:
            query_scope = QueryForScope(self.procedure_scope, node, relation_name, alias_name)
        else:
            query_scope = QuerySelectScope(self.procedure_scope, node, relation_name, alias_name)

        if is_foreach:
            if node.report_names is not None:
                self.reports.extend(node.report_names)
                for report_name in node.report_names:
                    self.visit_Name(report_name)

        where_clause = qualified_rel_alias.where_clause
        join_clause_list = qualified_rel_alias.join_clause_list or []
        grouped_clause = qualified_rel_alias.grouped_clause

        # self.visit(node.control_clause) Useless
        self.visit(qualified_rel_alias.via_clause)
        self.optimize_via_clause(node)
        self.rebuild_viakey_clause(node)

        node.scope = query_scope
        node.parent_scope = self.current_scope

        self.scopes.appendleft(query_scope)

        for join_clause in join_clause_list:
            join_relation_name = join_clause.relation_name
            join_alias_name = join_clause.alias_name
            self.relation_name_alias(join_relation_name, join_alias_name)
            if isinstance(join_clause, ast.InnerJoinClause):
                join_clause_scope = InnerJoinClauseScope(self.procedure_scope, node, join_relation_name, join_alias_name)
            elif isinstance(join_clause, ast.LeftOuterJoinClause):
                join_clause_scope = LeftOuterJoinClauseScope(self.procedure_scope, node, join_relation_name, join_alias_name)
            elif isinstance(join_clause, ast.RightOuterJoinClause):
                join_clause_scope = RightOuterJoinClauseScope(self.procedure_scope, node, join_relation_name, join_alias_name)
            elif isinstance(join_clause, ast.FullOuterJoinClause):
                join_clause_scope = FullOuterJoinClauseScope(self.procedure_scope, node, join_relation_name, join_alias_name)
            self.scopes.appendleft(join_clause_scope)
            self.visit(join_clause.clause)

        # TODO: make me better !
        # Purge fetched from join clause
        query_scope.fetched_columns.clear()

        if where_clause:
            where_clause_scope = WhereClauseScope(self.procedure_scope, node, relation_name, alias_name)
            self.scopes.appendleft(where_clause_scope)
            self.visit(where_clause)
            self.scopes.popleft()
            query_scope.ids_not_from_query = self.list_in_where_clause_ids_not_from_query(node)
            self.rebuild_sort_list(node)

        for _ in range(len(join_clause_list)):
            self.scopes.popleft()

        for join_clause in join_clause_list:
            join_relation_scope = QueryForScope(self.procedure_scope, node, join_clause.relation_name, join_clause.alias_name)
            join_clause.scope = join_relation_scope
            self.scopes.appendleft(join_relation_scope)

        if is_foreach and node.report_names:

            # List of assigned data in every report conditions.
            updated_datas_in_report_conditions = set()

            for report_name in node.report_names:
                if isinstance(report_name.definition, ast.Report):

                    report_name.definition.used = True
                    report_name.definition.query_scope = query_scope

                    self.visit(report_name.definition.dest)

                    for report_condition in report_name.definition.conditions:

                        # Report conditions are isolated, so MOVE in one condition does not affect ALTER in other condition.
                        query_scope.updated_datas = set()

                        self.report_condition(report_condition)

                        for data in query_scope.updated_datas:
                            updated_datas_in_report_conditions.add(data)

                        if isinstance(report_condition, ast.GroupCondition):
                            node.got_changing = True

            # Set the list of updated datas for ALTER in the body of the FOR.
            query_scope.updated_datas = updated_datas_in_report_conditions

        if is_foreach and isinstance(rel_definition, ast.Source):
            self.annote_source(rel_definition)
            source_location = deepcopy(rel_definition.location)
            self.visit(source_location)
            node.source_location = source_location

        if is_foreach:
            self.visit(node.stmts)
        else:
            self.visit(node.then_else_clause.then_stmts)

        if where_clause:

            if not join_clause_list and not grouped_clause:
                self.optimize_where_clause(node, ids_not_assigned=query_scope.ids_not_from_query)
                self.jsonize_via_clause(node)

            if self.procedure_scope.in_schema(relation_name):
                self.optimize_where_clause_better_for_permdb(node, ids_not_assigned=query_scope.ids_not_from_query)

            if where_clause and not qualified_rel_alias.is_where_optimized:
                where_routine_scope = WhereRoutineScope(self.procedure_scope, node, relation_name, alias_name)
                self.scopes.appendleft(where_routine_scope)
                self.visit(where_clause)
                self.scopes.popleft()
                query_scope.fetched_columns.update(where_routine_scope.fetched_columns)
                query_scope.where_routine_params.update(where_routine_scope.fetched_columns)
            self.jsonize_join_clause(node)
        else:
            self.jsonize_via_clause(node)
            self.jsonize_join_clause(node)

        self.visit(grouped_clause)
        self.build_sort_list(node)

        for _ in range(len(join_clause_list)):
            self.scopes.popleft()

        self.scopes.popleft()

        if not is_foreach:
            self.visit(node.then_else_clause.else_stmts)

        if is_foreach and node.report_names:
            for report_name in node.report_names:
                self.reports.pop()

        if isinstance(rel_definition, ast.Relation):

            if node.got_alter:
                for key in rel_definition.keys:
                    query_scope.add_fetched_columns(key)

            if is_foreach and node.got_changing:
                for field in qualified_rel_alias.sort_list:
                    query_scope.add_fetched_columns(field.field.name)
