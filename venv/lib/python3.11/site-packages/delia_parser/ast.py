# -*- coding: utf-8 -*-

import collections
from delia_tokenizer.tokenize import *
from delia_parser import types

"""
    Delia abstract syntax node definitions
"""

def flatten(seq):
    if isinstance(seq, tuple):
        return seq
    res = []
    for elt in seq:
        if isinstance(elt, list):
            for elt2 in flatten(elt):
                res.append(elt2)
        elif not isinstance(seq, tuple):
            res.append(elt)
    return res


def flatten_nodes(seq):
    return [n for n in flatten(seq) if isinstance(n, Node)]


class Node:
    """
    Abstract base class for ast nodes.
    This class is the ancestor of all the Node classes.
    """
    def get_child_nodes(self):
        """
        :return: Return only children type Node.
        :rtype: list
        """
        pass  # implemented by subclasses

    def __iter__(self):
        for n in self.get_child_nodes():
            yield n


def node_wrap(obj):
    # TODO try to cast to the most appropriate node class
    if isinstance(obj, tuple):
        return TokenNode(obj)
    elif isinstance(obj, Node) or isinstance(obj, list):
        return obj
    elif obj is None:
        return None
    else:
        raise


class EmptyNode(Node):
    pass


class BaseAST(Node):
    """
      This class contains the basic support for an AST.
      Most people will create ASTs that are subclasses of
      BaseAST.

      :ivar path: the path to the file that was parsed.
      :type path: str
      :ivar lineno: the number of the line on which the error was encountered
      :type lineno: int
      :ivar column: the column number where the error was encountered
      :type column: int
    """

    def __init__(self, target, option, values, locations=None):
        self.nodes = values
        self.node_name = target
        self.locations = locations

    @property
    def locations(self,):
        if self._locations is None:
            for child in self.get_child_nodes():
                if isinstance(child, BaseAST) and child.locations is not None:
                    return child.locations
        return self._locations

    @locations.setter
    def locations(self, loc):
        self._locations = loc

    @property
    def lineno(self,):
        if self.locations is None:
            for child in self.get_child_nodes():
                if isinstance(child, BaseAST) and child.locations is not None:
                    return child.locations[0]
            return None
        else:
            return self.locations[0]

    @property
    def column(self,):
        if self.locations is None:
            for child in self.get_child_nodes():
                if isinstance(child, BaseAST) and child.locations is not None:
                    return child.locations[1]
            return None
        else:
            return self.locations[1]

    @property
    def path(self,):
        if self.locations is None:
            for child in self.get_child_nodes():
                if isinstance(child, BaseAST) and child.locations is not None:
                    return child.locations[2]
            return None
        else:
            return self.locations[2]

    @property
    def macro_stack(self,):
        if self.locations is None:
            for child in self.get_child_nodes():
                if isinstance(child, BaseAST) and child.locations is not None:
                    return child.locations[3]
            return None
        else:
            return self.locations[3]

    def get_child_nodes(self):
        return flatten_nodes(self.nodes)

    def __repr__(self):
        return "<%s %s>" % (self.__class__.__name__, self.get_child_nodes())


class Root(BaseAST):

    def __init__(self, procedure=None, schema=None):
        self._location = None
        self.procedure = procedure
        self.schema = schema

    def set_procedure(self, procedure):
        self.procedure = procedure

    def set_schema(self, schema):
        self.schema = schema

    def get_child_nodes(self):
        return self.schema, self.procedure,

    def __repr__(self):
        return "<Root>"


class Decl(BaseAST):
    def __init__(self, locations=None):
        self._used = False
        self.locations = locations

    @property
    def used(self):
        return self._used

    @used.setter
    def used(self, v):
        self._used = v


class Decls(BaseAST):
    def __init__(self, decls=[], locations=None):
        self.locations = locations
        self.__decls = decls

    def __getitem__(self, index):
        return self.__decls[index]

    def __iter__(self):
        return iter(self.__decls)

    def __len__(self):
        return len(self.__decls)

    def get_child_nodes(self):
        return tuple(self.__decls)


class Stmt(BaseAST):
    def __init__(self, locations=None):
        self.locations = locations

    def get_child_nodes(self):
        return ()


class Stmts(BaseAST):
    def __init__(self, stmts=[], locations=None):
        self.locations = locations
        self._macro_infos = None
        self._in_macro = False
        for node in stmts:
            if isinstance(node, BaseAST):
                self.locations = node.locations
                break
        self.value = stmts

    @property
    def macro_infos(self):
        return self._macro_infos

    @macro_infos.setter
    def macro_infos(self, v):
        self._macro_infos = v

    @property
    def in_macro(self):
        return self._in_macro

    @in_macro.setter
    def in_macro(self, v):
        self._in_macro = v

    def __getitem__(self, index):
        return self.value[index]

    def __iter__(self):
        return iter(self.value)

    def __len__(self):
        return len(self.value)

    def get_child_nodes(self):
        return tuple(self.value)

    def isEmpty(self):
        return len(self) == 0


class Schema(Decl):

    """
    :ivar name: Schema name.
    :type name: Name
    :ivar decls: Schema declaration list.
    :type decls: list
    """

    type = types.Schema()

    def __init__(self, schema_name, decls, locations=None):
        """
        :param name: Schema name.
        :type name: Nam
        :param decls: Schema declaration list.
        :type decls: list
        :param lineno: line numero.
        :type lineno: int
        :param path: path.
        :type path: str
        """
        self.name = schema_name
        self.decls = decls
        self.locations = locations
        self._used = True

    def get_child_nodes(self):
        return self.decls,

    def __repr__(self):
        return "<Schema:%s>" % self.name


class Subroutine(Decl):

    """
    :ivar name: Subroutine name.
    :type name: Name
    :ivar receiving_parameters: receiving parameter list.
    :type receiving_parameters: list
    :ivar returning_parameters: returning parameter list.
    :type returning_parameters: list
    :ivar attributes: Subroutine attributes.
    :type attributes: Attributes
    :ivar decls: Subroutine declation list.
    :type decls: list
    :ivar stmts: Subroutine  statement list.
    :type stmts: list
    """

    def __init__(
            self,
            name,
            receiving_parameter_list=[],
            returning_parameter_list=[],
            attributes=None,
            decls=[],
            stmts=[],
            locations=None):
        """
        :param name: Subroutine name.
        :type name: Name
        :param receiving_parameter_list: receiving parameter list.
        :type receiving_parameter_list: list
        :param returning_parameter_list: returning parameter list.
        :type returning_parameter_list: list
        :ivar attributes: Subroutine attributes.
        :type attributes: Attributes
        :param decls: Subroutine  declation list.
        :type decls: list
        :param stmts: Subroutine  statement list.
        :type stmts: list
        """

        self.name = name
        self.receiving_parameters = receiving_parameter_list
        self.returning_parameters = returning_parameter_list
        self.attributes = attributes
        self.decls = decls
        self.stmts = stmts
        self.locations = locations
        self._used = False
        self.annotated = False
        self.scope = None

    @property
    def type(self):
        try:
            return self.attributes.type
        except AttributeError:
            return None

    @property
    def picture(self):
        try:
            return self.attributes.picture
        except AttributeError:
            return None

    def get_child_nodes(self):
        return self.receiving_parameters, self.returning_parameters, \
            self.attributes, self.decls, self.stmts,

    def __repr__(self):
        return "<%s:%s>" % (self.__class__.__name__, self.name)


class Procedure(Subroutine):
    type = types.Procedure()

    def __init__(self,
                 name,
                 receiving_parameter_list=[],
                 returning_parameter_list=[],
                 decls=Decls([]),
                 stmts=Stmts([]),
                 locations=None):

        Subroutine.__init__(self,
                            name=name,
                            receiving_parameter_list=receiving_parameter_list,
                            returning_parameter_list=returning_parameter_list,
                            attributes=None,
                            decls=decls,
                            stmts=stmts,
                            locations=locations)

        # Params declared in schema, so don't need to generate the fields.
        self.params_in_schema = set()

        # CONTROLS FOR PROCEDURE: Default values.
        self.separator = ControlCharacter("@cr")
        self.check_subscripts = True
        self.verify_accept_input = False
        self.no_accept_terminator = False


class Function(Subroutine):
    def __init__(self,
                 name,
                 receiving_parameter_list=[],
                 returning_parameter_list=[],
                 attributes=None,
                 stmts=Stmts([]),
                 locations=None):
        Subroutine.__init__(self,
                            name=name,
                            receiving_parameter_list=receiving_parameter_list,
                            returning_parameter_list=returning_parameter_list,
                            attributes=attributes,
                            decls=None,
                            stmts=stmts,
                            locations=locations)


class FLI(Function):

    """
    :ivar file_spec: file specified.
    :type file_spec: str
    """

    def __init__(self,
                 name,
                 receiving_parameter_list=[],
                 returning_parameter_list=[],
                 attributes=None,
                 file_spec=None,
                 locations=None):
        """
        :param file_spec: file specified.
        :type file_spec: str
        """
        Function.__init__(self,
                          name=name,
                          receiving_parameter_list=receiving_parameter_list,
                          returning_parameter_list=returning_parameter_list,
                          attributes=attributes,
                          stmts=None,
                          locations=locations)
        self.file_spec = file_spec
        self._used = False


class FunctionKey(Function):

    """
    :ivar sequence: represents the characters in the function key sequence.
    :type sequence: ConcatenatedString
    :ivar is_globally: is GLOBALLY.
    :type is_globally: bool
    """

    def __init__(self,
                 name,
                 stmts=Stmts([]),
                 sequence=None,
                 is_globally=False,
                 locations=None):
        """
        :param sequence: represents the characters in the
                         function key sequence.
        :type sequence: ConcatenatedString
        :param is_globally: is GLOBALLY.
        :type is_globally: bool
        """
        Function.__init__(self,
                          name=name,
                          stmts=stmts,
                          locations=locations)
        self.is_globally = is_globally
        self.sequence = sequence
        self._used = False


class SameAsClause(BaseAST):

    """
    :ivar subject_name: subject name.
    :type subject_name: str
    """

    def __init__(self, subject_name, locations=None):
        """
        :param subject_name: subject name.
        :type subject_name: str
        """
        self.subject_name = subject_name
        self.locations = locations
        self._used = False

    @property
    def definition(self):
        return self.subject_name.definition

    @definition.setter
    def definition(self, v):
        self.subject_name.definition = v

    @property
    def picture(self):
        return self.subject_name.picture

    @picture.setter
    def picture(self, v):
        self.subject_name.picture = v

    @property
    def type(self):
        return self.subject_name.type

    def get_child_nodes(self):
        return ()

    @property
    def used(self):
        return self._used

    @used.setter
    def used(self, v):
        self._used = v
        if v and self.subject_name.definition:
            self.subject_name.definition.used = True

    def __repr__(self):
        return "<Same AS %s>" % self.subject_name


class Array(Decl):

    """
    :ivar name: array name.
    :type name: Name
    :ivar lower_bound: specifies the lower boundary for the subscripts
                       or indexes which are used to access the array.
    :type lower_bound: Literal
    :ivar upper_bound: specifies the upper boundary for the subscripts
                       or indexes which are used to access the array.
    :type upper_bound: Literal
    :ivar check: Causes to check (or not to check) if the value of each
                 subscript used to access in the array is within the
                 specified boundaries.
    :type check: bool
    :ivar array_columns: Specifies the fields to be included in the array.
    :type array_columns: ArrayColumns
    :ivar columns: Specifies the fields to be included in the array.
    :type columns: List of Names
    :ivar type: array type.
    :type type: Type
    """

    type = types.Array()

    def __init__(self, array_name, lower_bound, upper_bound, check, array_columns, locations=None):
        """
        :param array_name: array name.
        :type array_name: Name
        :param lower_bound: specifies the lower boundary for the subscripts
                            or indexes which are used to access the array.
        :type lower_bound: Literal
        :param upper_bound: specifies the upper boundary for the subscripts
                            or indexes which are used to access the array.
        :type upper_bound: Literal
        :param check: Causes to check (or not to check) if the value of each
                      subscript used to access in the array is within the
                      specified boundaries.
        :type check: bool
        :param array_columns: Specifies the fields to be included in the array.
        :type array_columns: ColumnsArray
        """
        self.name = array_name
        self._lower_bound = lower_bound
        self._upper_bound = upper_bound
        self.check = check
        self.array_columns = array_columns
        self.locations = locations
        self._used = False
        self.check_subscripts = False

    @property
    def columns(self):
        return self.array_columns.columns

    @property
    def upper_bound(self):
        return self._upper_bound

    @property
    def lower_bound(self):
        return self._lower_bound

    def get_child_nodes(self):
        return self.lower_bound, self.upper_bound, self.columns,

    def __repr__(self):
        return "<Array:%s[%s TO %s]>" % (
            repr(self.name), repr(self.lower_bound), repr(self.upper_bound))

    @property
    def used(self):
        return self._used

    @used.setter
    def used(self, v):
        self._used = v
        if v and isinstance(self.array_columns, ArrayColumns):
            self.array_columns.used = True


class SameAsArray(SameAsClause, Array):
    """
    :ivar name: array name.
    :type name: Name
    :ivar subject_name: array/relation name.
    :type subject_name: Name
    :ivar type: array type.
    :type type: Type
    """

    type = types.Array()

    def __init__(self, array_name, subject_name, locations=None):
        """
        :param name: array name.
        :type name: Name
        :param subject_name: array/relation name.
        :type subject_name: Name
        """
        SameAsClause.__init__(self, subject_name, locations=None)
        self.name = array_name
        self.locations = locations
        self._used = False

    @property
    def columns(self):
        if isinstance(self.definition, (Array, Relation)):
            return self.definition.columns
        else:
            return None

    @property
    def upper_bound(self):
        if isinstance(self.definition, Array):
            return self.definition.upper_bound
        else:
            return None

    @property
    def lower_bound(self):
        if isinstance(self.definition, Array):
            return self.definition.lower_bound
        else:
            return None

    @property
    def check_subscripts(self):
        if isinstance(self.definition, Array):
            return self.definition.check_subscripts
        else:
            return None

    def __repr__(self):
        return "<Array:%s ( SAME AS %s)>" % (repr(self.name), repr(self.subject_name))


class ArrayColumns(Decl):
    """
    :ivar columns: Specifies the fields to be included in the array..
    :type columns: List fo Names
    """
    def __init__(self, columns, locations=None):
        """
        :param columns: Specifies the fields to be included in the array..
        :type columns: List for Names
        """
        self.columns = columns
        self.locations = locations
        self._used = False

    def get_child_nodes(self):
        return self.columns,

    @property
    def used(self):
        return self._used

    @used.setter
    def used(self, v):
        self._used = v
        if v and self.columns:
            for col in self.columns:
                if col.definition:
                    col.definition.used = True

    def __repr__(self):
        return "<ArrayColumns:(%s)>" % (repr(self.columns))


class SameAsArrayColumns(SameAsClause, ArrayColumns):
    """
        :param subject_name: array/relation name.
        :type subject_name: Name
    """
    def __init__(self, subject_name, locations=None):
        """
        :param subject_name: array/relation name.
        :type subject_name: Name
        """
        SameAsClause.__init__(self, subject_name, locations=None)
        self.locations = locations

    @property
    def columns(self):
        if isinstance(self.definition, (Array, Relation)):
            return self.definition.columns
        else:
            return None

    @property
    def used(self):
        return self._used

    @used.setter
    def used(self, v):
        self._used = v
        if self._used and self.definition:
            self.definition.used = True
        if v and self.columns:
            for col in self.columns:
                if col.definition:
                    col.definition.used = True

    def __repr__(self):
        return "<ArrayColumns:( SAME AS %s)>" % (repr(self.subject_name))


class LanguageControlItem(BaseAST):
    """
        Procedure Controlled Field: (USERS|DATE|DIGIT SEPARATOR)
    """
    def __init__(self, value=None, locations=None):
        """
        :param value:
        :type value: Literal
        """
        self.value = value
        self.locations = locations

    def get_child_nodes(self):
        return self.value,

    def __repr__(self):
        return "<%s %s>" % (self.__class__.__name__, repr(self.value))


class UsersLanguageIdentifier(LanguageControlItem):
    pass


class DateLanguageIdentifier(LanguageControlItem):
    pass


class DigitSeparatorLanguageIdentifier(LanguageControlItem):
    pass


class ControlsForLanguage(Decl):
    """
    :ivar control_items: control_item_list
    :type control_items: list of LanguageControlItem
    """
    def __init__(self, control_item_list, locations=None):
        """
        :param control_item_list: control_item_list
        :type control_item_list: list of LanguageControlItem
        """
        self.control_items = control_item_list
        self.locations = locations

    def get_child_nodes(self):
        return self.control_items,

    def __repr__(self):
        return "<ControlsForLanguage={}>".format(self.control_items)


class ProcedureControlItem(BaseAST):
    """
        Procedure Controlled Field: (SEPARATOR|NO ACCEPT TERMINATOR|VERIFY ACCEPT INPUT|CHECK SUBSCRIPTS)
    """

    def __init__(self, value=None, locations=None):
        """
        :param value:
        :type value: Literal
        """
        self.value = value
        self.locations = locations

    def get_child_nodes(self):
        return ()

    def __repr__(self):
        if self.value is None:
            return "<%s>" % (self.__class__.__name__)
        else:
            return "<%s %s>" % (self.__class__.__name__, repr(self.value))


class ProcedureVerifyAcceptInput(ProcedureControlItem):
    pass


class ProcedureSeparator(ProcedureControlItem):

    def get_child_nodes(self):
        return self.value,


class ProcedureCheckSubscripts(ProcedureControlItem):

    def get_child_nodes(self):
        return self.value,


class ProcedureNoAcceptTerminator(ProcedureControlItem):
    pass


class ControlsForProcedure(Decl):
    """
    :ivar control_items: control_item_list
    :type control_items: list of ProcedureControlItem
    """
    def __init__(self, control_item_list, locations=None):
        """
        :param control_item_list: control_item_list
        :type control_item_list: list of ProcedureControlItem
        """
        self.control_items = control_item_list
        self.locations = locations

    def get_child_nodes(self):
        return self.control_items,

    def __repr__(self):
        return "<ControlsForProcedure=%s>" % (self.control_items)


class Constant(Decl):

    """
    :ivar name: constant name.
    :type name: Name
    :ivar value: constant value.
    :type value: Literal
    :ivar type: constant type.
    :type type: Type
    """

    def __init__(self, constant_name, literal, locations=None):
        """
        :param constant_name: constant name.
        :type constant_name: Name
        :param value: constant value.
        :type value: Literal
        """
        self.name = constant_name
        self.value = literal
        self.locations = locations
        self._used = False

    @property
    def type(self):
        return self.value.type

    @property
    def size(self):
        return self.value.size

    @property
    def picture(self):
        return self.value.picture

    def get_child_nodes(self):
        return self.value,

    def __repr__(self):
        return "<Constant:%s=%s>" % (self.name, str(self.value))


class Field(Decl):

    """
    :ivar name: field name.
    :type name: str
    :ivar attributes: field attributes.
    :type attributes: Attributes
    :ivar type: field type.
    :type type: Type
    """

    def __init__(self, field_name, attributes, locations=None):
        """
        :param field_name: field name.
        :type field_name: str
        :param attributes: field attributes.
        :type attributes: Attributes
        """
        BaseAST.__init__(self, field_name, None, attributes, locations)
        self.name = field_name
        self.attributes = attributes
        self._used = False

    @property
    def picture(self):
        return self.attributes.picture

    @property
    def type(self):
        return self.attributes.type

    @property
    def size(self):
        return self.attributes.size

    @property
    def definition(self):
        return self

    def get_child_nodes(self):
        return self.name, self.attributes,

    @property
    def used(self):
        return self._used

    @used.setter
    def used(self, v):
        self._used = v
        if v and isinstance(self.definition.attributes, SameAsAttributes):
            self.attributes.used = True

    def __repr__(self):
        return "<Field:%s %s>" % (self.name, repr(self.attributes))


class Attributes(Decl):

    """
    :ivar picture: field picture
    :type picture: Picture
    :ivar field_clauses: field clause.
    :type field_clauses: FieldClause
    :ivar type: attribute type.
    :type type: Type
    """

    def __init__(self, picture_clause, field_clauses, locations=None):
        """
        :param picture_clause: field picture.
        :type picture_clause: Picture
        :param field_clauses: field clause.
        :type field_clauses: FieldClause
        """
        self.picture = picture_clause
        self.field_clauses = field_clauses
        self.locations = locations

    @property
    def type(self):
        return self.picture.type

    @property
    def size(self):
        return self.picture.size

    @property
    def clauses(self):
        return self.field_clauses

    def get_child_nodes(self):
        return self.picture, self.field_clauses,

    def __repr__(self):
        return repr(self.picture)


class SameAsAttributes(SameAsClause, Attributes):

    """
    :ivar picture: field picture
    :type picture: Picture
    :ivar subject_name: subject name.
    :type subject_name: str
    :ivar field_clauses: field clause.
    :type field_clauses: FieldClause
    :ivar type: attribute type.
    :type type: Type
    """

    def __init__(self, subject_name, field_clauses, locations=None):
        """
        :param subject_name: subject name.
        :type subject_name: str
        :param field_clauses: field clause.
        :type field_clauses: FieldClause
        """
        SameAsClause.__init__(self, subject_name, locations=None)
        self.field_clauses = field_clauses
        self.merge_clauses = field_clauses[:]  # Contains clauses of the field completed by annotator by that of SameAs
        self.locations = locations

    @property
    def type(self):
        try:
            return self.subject_name.definition.type
        except AttributeError:
            return None

    @property
    def picture(self):
        try:
            return self.subject_name.definition.picture
        except AttributeError:
            return None

    def get_child_nodes(self):
        if self.field_clauses is not None:
            return self.subject_name, self.field_clauses,
        else:
            return self.subject_name,

    @property
    def clauses(self):
        return self.merge_clauses

    def __repr__(self):
        return "<Same AS %s>" % self.subject_name


class Picture(BaseAST):

    """
    :ivar value: picture value.
    :type value: str
    :ivar type: picture type.
    :type type: Type
    """

    def __init__(self, value=None, locations=None, literal_value=None):
        """
        :param value: picture value
        :type value: str
        """
        # Build picture from literal value. Ex: "123.45" -> "ZZN.NN"
        if literal_value is not None:
            value = self.from_value(literal_value)

        self.value = value
        self.locations = locations
        self.picture = None

    @property
    def size(self):
        return self.picture.size

    def get_child_nodes(self):
        return ()

    def __repr__(self):
        return "%s" % (repr(self.value))


class StringPicture(Picture):
    type = types.String()

    def from_value(self, value):
        return '{}C'.format(len(value))


class DatePicture(Picture):
    type = types.Date()

    def __repr__(self):
        if not self.value:
            return "DATE"
        else:
            return "DATE %s" % (repr(self.value))


class NumericPicture(Picture):
    pass


class IntegerPicture(NumericPicture):
    type = types.Integer()

    def from_value(self, value):
        if value.startswith('-'):
            picture = '-%dZ' % (len(value) - 1)
        else:
            picture = '%dZ' % len(value)
        return picture


class DecimalPicture(NumericPicture):
    type = types.Decimal()

    def from_value(self, value):
        integer, decimal = value.split('.')

        if value.startswith('-'):
            if decimal:
                picture = '-%dZ.%dN' % (len(integer) - 1, len(decimal))
            else:
                picture = '-%dZ.' % (len(integer) - 1)
        elif decimal:
            picture = '%dZ.%dN' % (len(integer), len(decimal))
        else:
            picture = '%dZ.' % (len(integer))

        return picture


class FloatPicture(NumericPicture):
    type = types.Decimal()

    def __repr__(self):
        if not self.value:
            return "FLOAT"
        else:
            return "FLOAT %s" % (repr(self.value))


class DoublePicture(NumericPicture):
    type = types.Decimal()

    def __repr__(self):
        if not self.value:
            return "LONG.FLOAT"
        else:
            return "LONG.FLOAT %s" % (repr(self.value))


class UnknownPicture(Picture):

    def __repr__(self):
        return "<UnknownPicture>"


class Frame(Decl):

    """
    - B{Rules:}
        - frame_decl: B{FRAME} name B{FROM} frame_format_location [border]
        [frame_area] [frame_data_info frame_data_names ]
        [controlled_field_list]
    :ivar name: frame name.
    :type name: Name
    :ivar frame_format_location: frame_format_location.
    :type frame_format_location: FrameFormatLocation
    :ivar border: border.
    :type border: bool
    :ivar frame_area: frame area.
    :type frame_area: FrameArea
    :ivar frame_data_info: frame data info.
    :type frame_data_info: FrameDataInfo
    :ivar frame_data_names: frame data names.
    :type frame_data_names: list of Name
    :ivar controlled_field_list: controlled field.
    :type controlled_field_list: list of FrameControlledField
    """

    type = types.Frame()

    def __init__(
        self, frame_name, frame_format_location, border, frame_area,
        frame_data_info, frame_data_names, controlled_field_list,
        locations=None
    ):
        """
        :param frame_name: frame name.
        :type frame_name: Name
        :param frame_format_location: frame_format_location .
        :type frame_format_location: FrameFormatLocation
        :param border: border.
        :type border: FrameBorder
        :param frame_area: frame area.
        :type frame_area: FrameArea
        :param frame_data_info: frame data info.
        :type frame_data_info: FrameDataInfo
        :param frame_data_names: frame data names.
        :type frame_data_names: list of Name
        :param controlled_field_list: controlled field.
        :type controlled_field_list: list of FrameControlledField
        """

        self.name = frame_name
        self.frame_format_location = frame_format_location
        self.border = border
        self.frame_area = frame_area
        self.frame_data_info = frame_data_info
        self.frame_data_names = frame_data_names
        self.controlled_field_list = controlled_field_list
        self.locations = locations
        self._used = False
        self.activated = False
        self.help_msg = collections.OrderedDict()

    def get_child_nodes(self):
        children = [self.frame_format_location]
        if self.frame_area is not None:
            children.append(self.frame_area)
        if self.frame_data_info is not None:
            children.append(self.frame_data_info)
        if self.frame_data_names is not None:
            children.append(self.frame_data_names)
        if self.controlled_field_list is not None:
            children.append(self.controlled_field_list)
        return tuple(children)

    def __repr__(self):
        return "<Frame:%s>" % self.name


class FrameFormatLocation(BaseAST):
    pass


class FrameFormatRef(FrameFormatLocation):
    """
    :ivar frame_format_name: frame format name.
    :type frame_format_name: Name
    """

    def __init__(self, frame_format_name):
        """
        :param frame_format_name: frame format name.
        :type frame_format_name: Name
        """
        self.frame_format_name = frame_format_name
        self._location = None

    @property
    def definition(self):
        return self.frame_format_name.definition

    @property
    def locations(self):
        return self.frame_format_name.locations

    def get_child_nodes(self):
        return self.frame_format_name,

    def __str__(self):
        return str(self.frame_format_name)

    def __repr__(self):
        return "<FrameFormatRef:%s>" % self.frame_format_name


class FrameFormatFile(FrameFormatLocation):
    """
    :ivar file_spec: file spec.
    :type file_spec: FileSpec
    """

    def __init__(self, file_spec):
        self.file_spec = file_spec
        self._location = None

    def get_child_nodes(self):
        return self.file_spec,

    def __repr__(self):
        return "<FrameFormatFile:%s>" % repr(self.file_spec)


class FileSpec(Decl):
    """
    - File Specification: concatenated_string|FILE concatenated_string|TERMINAL |TEXT concatenated_string)
    :ivar value: file name.
    :type value: ConcatenatedString
    """

    def __init__(self, file_name, locations=None):
        """
        :param file_name: file name.
        :type file_name: ConcatenatedString
        """
        self.value = file_name
        self.locations = locations

    def get_child_nodes(self):
        return self.value,

    def __repr__(self):
        return "<%s:%s>" % (self.__class__.__name__, repr(self.value))


class File(FileSpec):
    pass


class Text(FileSpec):
    pass


class Terminal(FileSpec):
    def __init__(self, locations=None):
        """
        :param file_name: file name.
        :type file_name: ConcatenatedString
        """
        self.value = "TERMINAL"
        self.locations = locations

    def get_child_nodes(self):
        return ()


class FrameArea(BaseAST):
    """
    :ivar first_line: specifies the first line of the frame area.
    :type first_line: Literal
    :ivar last_line: specifies the last line of the frame area.
    :type last_line: Literal
    """
    def __init__(self, first_line, last_line, locations=None):
        """
        :param first_line: specifies the first line of the frame area.
        :type first_line: Literal
        :param last_line: specifies the last line of the frame area.
        :type last_line: Literal
        """
        self.first_line = first_line
        self.last_line = last_line
        self.locations = locations

    def get_child_nodes(self):
        return self.first_line, self.last_line,

    def __repr__(self):
        return "<FrameArea:%s to %s>" % (self.first_line.value, self.last_line.value)


class FrameDataInfo(BaseAST):
    """
    :ivar character1: Specifies the characters that will be used to mark data areas. Character1 will be used unless fields adjoin, in which case character2 will also be used.
    :type character1: String
    :ivar character2: Specifies the characters that will be used to mark data areas. Character1 will be used unless fields adjoin, in which case character2 will also be used.
    :type character2: String
    """
    def __init__(self, character1, character2, locations=None):
        """
        :param character1: Specifies the characters that will be used to mark data areas. Character1 will be used unless fields adjoin, in which case character2 will also be used.
        :type character1: String
        :param character2: Specifies the characters that will be used to mark data areas. Character1 will be used unless fields adjoin, in which case character2 will also be used.
        :type character2: String
        """
        self.character1 = character1
        self.character2 = character2
        self.locations = locations

    def get_child_nodes(self):
        return self.character1, self.character2,

    def __repr__(self):
        if self.character2 is not None:
            return "<FrameDataInfo:%s OR %s>" % (repr(self.character1), repr(self.character2))
        else:
            return "<FrameDataInfo:%s>" % repr(self.character1)


class FrameControlledField(BaseAST):
    """
    :ivar fields_ref: The field references refer to fields of the frame being declared
    :type fields_ref: list of field name
    :ivar control_items: control_item_list
    :type control_items: list of FrameControlItem
    """
    def __init__(self, field_ref_list, control_item_list, locations=None):
        """
        :param field_ref_list: The field references refer to fields of the frame being declared
        :type field_ref_list: list of field name
        :param control_item_list: control_item_list
        :type control_item_list: list of FrameControlItem
        """
        self.fields_ref = field_ref_list
        self.control_items = control_item_list
        self.locations = locations

    def get_child_nodes(self):
        return self.fields_ref, self.control_items,

    def __repr__(self):
        return "<FrameControlledField:(%s) %s>" % (repr(self.fields_ref), repr(self.control_items))


class FrameControlItem(BaseAST):
    """
        Frame Controlled Field: (BLANK|BLINK|BOLD|COLOR|DIM|HELP|INITIAL_TOKEN|MINIMUM_LENGTH|OPAQUE|PROTECTED|REQUIRED|REVERSE|TERMINATE_FIELD|UNDERLINE)
    """
    form = None

    def __init__(self, value=None, locations=None):
        """
        :param value:
        :type value: Literal
        """
        self.value = value
        self.locations = locations

    def get_child_nodes(self):
        return ()

    def __repr__(self):
        if self.value is None:
            return "<%s>" % (self.__class__.__name__)
        else:
            return "<%s %s>" % (self.__class__.__name__, repr(self.value))


class FrameControlBlank(FrameControlItem):
    form = "BLANK"


class FrameControlBlink(FrameControlItem):
    form = "BLINK"


class FrameControlBold(FrameControlItem):
    form = "BOLD"


class FrameControlColor(FrameControlItem):
    form = "COLOR"

    def get_child_nodes(self):
        return self.value,


class FrameControlDim(FrameControlItem):
    form = "DIM"


class FrameControlHelp(FrameControlItem):
    form = "HELP"

    def get_child_nodes(self):
        return self.value,

    def __str__(self):
        return "".join([literal.value for literal in self.value])


class FrameControlInitial(FrameControlItem):
    form = "INITIAL"


class FrameControlMinimumLength(FrameControlItem):
    form = "MINIMUM.LENGTH"

    def get_child_nodes(self):
        return self.value,


class FrameControlOpaque(FrameControlItem):
    form = "OPAQUE"


class FrameControlProtected(FrameControlItem):
    form = "PROTECTED"


class FrameControlRequired(FrameControlItem):
    form = "REQUIRED"


class FrameControlReverse(FrameControlItem):
    form = "REVERSE"


class FrameControlTerminateField(FrameControlItem):
    form = "TERMINATE.FIELD"


class FrameControlUnderline(FrameControlItem):
    form = "UNDERLINE"


class FrameFormat(Decl):
    """
    - B{Rules:}
        - frm_frmt_decl: B{FRAME_FORMAT} name frame_format_def
    :ivar name: frame format name.
    :type name: Name
    :ivar frame_format_def: frame format definition ( list of ConcatenatedString).
    :type frame_format_def: list of ConcatenatedString
    """
    type = types.FrameFormat()

    def __init__(self, frame_format_name, frame_format_def, locations=None):
        """
        :param frame_format_name: frame format name.
        :type frame_format_name: Name
        :param frame_format_def: frame format definition ( list of ConcatenatedString).
        :type frame_format_def: list of ConcatenatedString
        """
        self.name = frame_format_name
        self.frame_format_def = frame_format_def
        self.locations = locations
        self._used = False

    def get_child_nodes(self):
        return self.frame_format_def,

    def __repr__(self):
        return "<FrameFormat:%s>" % self.name


class Relation(Decl):
    """
    :ivar name: relation name.
    :type name: Name
    :ivar dest: destination name.
    :type dest: str
    :ivar keys: key name list.
    :type keys: list
    :ivar datas: data name list.
    :type datas: list
    :ivar indexes: index name list.
    :type indexes: list
    :ivar index_on_all: INDEX ON ALL KEYS
    :type index_on_all: bool
    :ivar type: relation type.
    :type type: Type
    """

    type = types.Relation()

    def __init__(self, relation_name, dest, keys, datas=[], relation_indexes=[], index_on_all=False, locations=None):
        """
        :param name: relation name.
        :type name: Name
        :param dest: destination name.
        :type dest: str
        :param keys: key name list.
        :type keys: list
        :param datas: data name list.
        :type datas: list
        :param relation_indexes: index name list.
        :type indexes: list
        :param index_on_all: INDEX ON ALL KEYS
        :type index_on_all: bool
        """
        self.name = relation_name
        self.dest = dest
        self.keys = keys
        self.datas = datas
        self.indexes = relation_indexes
        self.index_on_all = index_on_all
        self.locations = locations
        if index_on_all:
            self.indexes = [[name] for name in self.datas]
        self._used = False

    def get_child_nodes(self):
        return self.keys, self.datas, self.indexes,

    @property
    def columns(self):
        return self.keys + self.datas

    def __repr__(self):
        return "<Relation:%s ( Key %s Data %s index %s)>" % (repr(self.name), repr(self.keys), repr(self.datas), repr(self.indexes))


class SameAsRelation(SameAsClause, Relation):
    """
    :ivar name: relation name.
    :type name: Name
    :ivar dest: destination name.
    :type dest: str
    :ivar subject_name: relation name.
    :type subject_name: Name
    :ivar indexes: index name list.
    :type indexes: list
    :ivar index_on_all: INDEX ON ALL KEYS
    :type index_on_all: bool
    :ivar type: relation type.
    :type type: Type
    """

    type = types.Relation()

    def __init__(self, relation_name, dest, subject_name, relation_indexes=[], index_on_all=None, locations=None):
        """
        :param name: relation name.
        :type name: Name
        :param dest: destination name.
        :type dest: str
        :param subject_name: relation name.
        :type subject_name: Name
        :param relation_indexes: index name list.
        :type indexes: list
        :param index_on_all: INDEX ON ALL KEYS
        :type index_on_all: bool
        """
        SameAsClause.__init__(self, subject_name, locations=None)
        self.name = relation_name
        self.dest = dest
        self.index_on_all = index_on_all
        self.locations = locations
        if index_on_all:
            self.default_indexes = [[name] for name in self.datas]
        else:
            self.default_indexes = relation_indexes
        self._used = False

    @property
    def keys(self):
        if isinstance(self.definition, Relation):
            return self.definition.keys
        else:
            return None

    @property
    def datas(self):
        if isinstance(self.definition, Relation):
            return self.definition.datas
        else:
            return None

    @property
    def columns(self):
        if isinstance(self.definition, Relation):
            return self.keys + self.datas
        else:
            return None

    @property
    def indexes(self):
        if self.default_indexes:
            return self.default_indexes
        else:
            if isinstance(self.definition, Relation):
                return self.definition.indexes
            else:
                return None

    def get_child_nodes(self):
        return self.indexes,

    def __repr__(self):
        return "<Relation:%s ( SAME AS %s index %s)>" % (repr(self.name), repr(self.subject_name), repr(self.indexes))


class Report(Decl):
    """
    :ivar name: report name.
    :type name: Name
    :ivar append: Appends the report to an existing object.
    :type append: bool
    :ivar char_set: report characters set.
    :type char_set: ReportCharSet
    :ivar dest: specifies the destination.
    :type dest: ReportFile
    :ivar parameters: report parameter declarations.
    :type parameters: list
    :ivar conditions: report condition declarations.
    :type conditions: list
    :ivar type: report type.
    :type type: Type
    """

    type = types.Report()

    def __init__(self, report_name, append, report_char_set, report_dest, report_parameters, report_conditions, locations=None):
        """
        :param report_name: report name.
        :type report_name: Name
        :param append: Appends the report to an existing object.
        :type append: bool
        :param report_char_set: report characters set.
        :type report_char_set: ReportCharSet
        :param report_dest: specifies the destination.
        :type report_dest: ReportFile
        :param report_parameters: report parameter declarations.
        :type report_parameters: list
        :param report_conditions: report condition declarations.
        :type report_conditions: list
        """
        self.name = report_name
        self.append = append
        self.char_set = report_char_set
        self.dest = report_dest
        self.parameters = report_parameters
        self.conditions = report_conditions
        self.locations = locations
        self._used = False

        # List of fields used in cumulative functions. (AVG/SUM/MIN/MAX)
        # Cumulative functions in GROUP.FOOTING.
        self.avg = []
        self.sum = []
        self.min = []
        self.max = []
        # Cumulative function COUNT in GROUP.FOOTING
        self.count = False

        # Cumulative functions in REPORT.FOOTING.
        self.avg_all = []
        self.sum_all = []
        self.min_all = []
        self.max_all = []
        # Cumulative function COUNT in REPORT.FOOTING
        self.count_all = False
        self.query_scope = None

    def get_child_nodes(self):
        return self.parameters, self.conditions,

    def __repr__(self):
        return "<Report:%s>" % self.name


class ReportCharSet(BaseAST):
    """report characters set (ASCII|BINARY|KANA|)"""
    def __init__(self, locations=None):
        self.locations = locations

    def get_child_nodes(self):
        return ()

    def __repr__(self):
        return "<%s>" % self.__class__.__name__


class ReportCharSetAscii(ReportCharSet):
    pass


class ReportCharSetBinary(ReportCharSet):
    pass


class ReportCharSetKana(ReportCharSet):
    pass


class ReportCharSetDefault(ReportCharSet):
    pass


class ReportOutport(FileSpec):
    def __init__(self, file_name=None, locations=None):
        """
        :param file_name: file name.
        :type file_name: ConcatenatedString
        """
        self.value = "OUTPORT"
        self.locations = locations

    def get_child_nodes(self):
        return ()


class ReportParameter(Decl):
    """report parameters (BOTTOM_MARGIN|FOOTING_SIZE|HEADING_SIZE|LINE_LENGTH|LINE_LENGTH|LINE_NUM
                         |PAGE_NUM|TOP_MARGIN|PAGE_DIVIDER|PAGE_TOP|)"""
    def __init__(self, parameter_name, value, locations=None):
        self.value = value
        self.parameter_name = parameter_name
        self.locations = locations
        self.report_name = None

    def get_child_nodes(self):
        return self.value,

    def __repr__(self):
        return "<%s %s>" % (self.__class__.__name__, repr(self.value))


class BottomMargin(ReportParameter):
    pass


class FootingSize(ReportParameter):
    pass


class HeadingSize(ReportParameter):
    pass


class LineLength(ReportParameter):
    pass


class LineNum(ReportParameter):
    pass


class PageNum(ReportParameter):
    pass


class TopMargin(ReportParameter):
    pass


class PageDivider(ReportParameter):
    pass


class PageSize(ReportParameter):
    pass


class PageTop(ReportParameter):
    pass


class ReportCondition(Decl):
    """
    :ivar report_cond_name: report condition name
    :type report_cond_name: str
    :ivar stmts: Report Condition statement
    :type stmts: list
    """
    def __init__(self, report_cond_name, report_cond_stmt_list, locations=None):
        """
        :param report_cond_name: report condition name
        :type report_cond_name: str
        :param report_cond_stmt_list: Report Condition statement
        :type report_cond_stmt_list: list
        """
        self.report_cond_name = report_cond_name
        self.stmts = report_cond_stmt_list  # May be has value None if it is used with Force statement.
        self.locations = locations
        self.report_name = None
        self.relation_name = None

    def get_child_nodes(self):
        return self.stmts,

    def __repr__(self):
        return "<%s>" % (self.__class__.__name__)


class PageFooting(ReportCondition):
    pass


class PageHeading(ReportCondition):
    pass


class ReportFooting(ReportCondition):
    pass


class ReportHeading(ReportCondition):
    pass


class GroupCondition(Decl):
    """
    :param group_cond_name: group condition name
    :type group_cond_name: str
    :param group_name: group name
    :type group_name: Name
    :param field_name: field name
    :type field_name: Name
    :param stmts: Group Condition statement
    :type stmts: list
    """
    def __init__(self, group_cond_name, group_name, field_name, group_cond_stmt_list, locations=None):
        """
        :param group_cond_name: group condition name
        :type group_cond_name: str
        :param group_name: group name
        :type group_name: Name
        :param field_name: field name
        :type field_name: Name
        :param group_cond_stmt_list: Group Condition statement
        :type group_cond_stmt_list: list
        """
        self.group_cond_name = group_cond_name
        self.stmts = group_cond_stmt_list  # May be has value None if it is used with Force statement.
        self.name = group_name
        self.field_name = field_name
        self.locations = locations
        self._used = False
        self.report_name = None

    def get_child_nodes(self):
        return self.stmts,

    def __repr__(self):
        return "<%s>" % (self.__class__.__name__)


class GroupHeading(GroupCondition):
    pass


class GroupFooting(GroupCondition):
    pass


class Screen(Decl):
    def __init__(self, attributes, locations=None):
        self.attributes = attributes
        self.locations = locations
        self._used = False

    def get_child_nodes(self):
        return self.attributes,

    def __repr__(self):
        return "<Screen:{}>".format(", ".join(map(repr, self.attributes)))


class ScreenAttribute(BaseAST):
    """
        Screen attributes: (ABORT_PROCEDURE|BACKUP_CHARACTER|BACKUP_FIELD|
                            FIELD_FILLER|GET_HELP|SKIP_FIELD|TERMINATE_FIELD|
                            FIELD_FLAGS|FUNCTION_LENGTH|FUNCTION_SEPARATOR|
                            LINE_LENGTH|MESSAGE_AREA|SCREEN_SIZE)
    """

    def __init__(self, locations=None):
        self.locations = locations

    def get_child_nodes(self):
        return ()


class ScreenAbortProcedure(ScreenAttribute):
    """
    :ivar value: Character that terminates procedure execution.
    :type value: String
    """
    def __init__(self, value, locations=None):
        """
        :param value: Character that terminates procedure execution.
        :type value: String
        """
        self.value = value
        self.locations = locations

    def get_child_nodes(self):
        return self.value,

    def __repr__(self):
        return "<ScreenAbortProcedure:{}>".format(repr(self.value))


class ScreenBackupCharacter(ScreenAttribute):
    """
    :ivar value: Character that backspaces over a character during input.
    :type value: String
    """
    def __init__(self, value, locations=None):
        """
        :param value: Character that backspaces over a character during input.
        :type value: String
        """
        self.value = value
        self.locations = locations

    def get_child_nodes(self):
        return self.value,

    def __repr__(self):
        return "<ScreenBackupCharacter:{}>".format(repr(self.value))


class ScreenBackupField(ScreenAttribute):
    """
    :ivar value: Character that backspaces over an input.
    :type value: String
    """
    def __init__(self, value, locations=None):
        """
        :param value: Character that backspaces over an input.
        :type value: String
        """
        self.value = value
        self.locations = locations

    def get_child_nodes(self):
        return self.value,

    def __repr__(self):
        return "<ScreenBackupField:{}>".format(repr(self.value))


class ScreenFieldFiller(ScreenAttribute):
    """
    :ivar value: Character that initially appears in the data areas for most fields.
    :type value: String
    """
    def __init__(self, value, locations=None):
        """
        :param value: Character that initially appears in the data areas for most fields.
        :type value: String
        """
        self.value = value
        self.locations = locations

    def get_child_nodes(self):
        return self.value,

    def __repr__(self):
        return "<ScreenFieldFiller:{}>".format(repr(self.value))


class ScreenFunctionLength(ScreenAttribute):
    """
    :ivar value: Number of characters in every function key sequence, excluding FUNCTION.SEPARATOR
    :type value: Integer
    """
    def __init__(self, length, locations=None):
        """
        :param length: Number of characters in every function key sequence, excluding FUNCTION.SEPARATOR
        :type length: Integer
        """
        self.length = length
        self.locations = locations

    def get_child_nodes(self):
        return self.length,

    def __repr__(self):
        return "<ScreenFunctionLength:{}>".format(repr(self.length))


class ScreenFunctionSeparator(ScreenAttribute):
    """
    :ivar value: First character of every function key sequence.
    :type value: String
    """
    def __init__(self, separator, locations=None):
        """
        :param separator: First character of every function key sequence.
        :type separator: String
        """
        self.separator = separator
        self.locations = locations

    def get_child_nodes(self):
        return self.separator,

    def __repr__(self):
        return "<ScreenFunctionSeparator:{}>".format(repr(self.separator))


class ScreenGetHelp(ScreenAttribute):
    """
    :ivar value: Character that displays the HELP message for the current field.
    :type value: String
    """
    def __init__(self, value, locations=None):
        """
        :param value: Character that displays the HELP message for the current field.
        :type value: String
        """
        self.value = value
        self.locations = locations

    def get_child_nodes(self):
        return self.value,

    def __repr__(self):
        return "<ScreenGetHelp:{}>".format(repr(self.value))


class ScreenLineLength(ScreenAttribute):
    """
    :ivar size: Maximum number of characters in a line.
    :type size: Integer
    """
    def __init__(self, size, locations=None):
        """
        :param size: Maximum number of characters in a line.
        :type size: Integer
        """
        self.size = size
        self.locations = locations

    def get_child_nodes(self):
        return self.size,

    def __repr__(self):
        return "<ScreenLength:{}>".format(repr(self.size))


class ScreenMessageArea(ScreenAttribute):
    """
    :ivar first_line: screen message area first line.
    :type first_line: Integer
    :ivar last_line: screen message area last line.
    :type last_line: Integer
    """
    def __init__(self, first_line, last_line, locations=None):
        """
        :param first_line: screen message area first line.
        :type first_line: Integer
        :param last_line: screen message area last line.
        :type last_line: Integer
        """
        self.first_line = first_line
        self.last_line = last_line
        self.locations = locations

    def get_child_nodes(self):
        return self.first_line, self.last_line,

    def __repr__(self):
        return "<ScreenMessageArea:{from_}{to}>".format(from_=repr(self.first_line),
                                                        to="" if self.last_line is None else " TO %s" % (repr(self.last_line),))


class ScreenSize(ScreenAttribute):
    """
    :ivar size: Number of lines on screen.
    :type size: Integer
    """
    def __init__(self, size, locations=None):
        """
        :param size: Number of lines on screen.
        :type size: Integer
        """
        self.size = size
        self.locations = locations

    def get_child_nodes(self):
        return self.size,

    def __repr__(self):
        return "<ScreenSize:{}>".format(repr(self.size))


class ScreenSkipField(ScreenAttribute):
    """
    :ivar value: Character that causes a field being input be skipped without any change in its value.
    :type value: String
    """
    def __init__(self, value, locations=None):
        """
        :param value: Character that causes a field being input be skipped without any change in its value.
        :type value: String
        """
        self.value = value
        self.locations = locations

    def get_child_nodes(self):
        return self.value,

    def __repr__(self):
        return "<ScreenSkipField:{}>".format(repr(self.value))


class ScreenTerminateField(ScreenAttribute):
    """
    :ivar value: Character that terminates field input.
    :type value: String
    """
    def __init__(self, value, locations=None):
        """
        :param value: Character that terminates field input.
        :type value: String
        """
        self.value = value
        self.locations = locations

    def get_child_nodes(self):
        return self.value,

    def __repr__(self):
        return "<ScreenTerminateField:{}>".format(repr(self.value))


class Source(Decl):
    """
    :ivar name: source name.
    :type name: str
    :ivar location: location.
    :type location: FileSpec
    :ivar attributes: source attributes list.
    :type attributes: list
    :ivar inputs: input item list.
    :type inputs: list
    :ivar prompt: Tells where the report is to be printed.
    :type prompt: BaseAST
    """
    type = types.Source()

    def __init__(self, source_name, location, source_attr_list, input_list, source_prompt, locations=None):
        """
        :param source_name: source name.
        :type source_name: str
        :param location: location.
        :type location: FileSpec
        :param source_attr_list: source_attr_list.
        :type source_attr_list: list
        :param input_list: input item list.
        :type input_list: list
        :param source_prompt: Tells where the report is to be printed.
        :type source_prompt: BaseAST
        """
        self.name = source_name
        self.location = location
        self.attributes = source_attr_list
        self.inputs = input_list
        self.prompt = source_prompt
        self.locations = locations
        self.input_set = None
        self._used = False

    def get_child_nodes(self):
        return self.location, self.attributes, self.inputs, self.prompt,

    def __repr__(self):
        return "<Source:%s>" % self.name


class SourceAttribute(Decl):
    """source attribute (no_echo | BINARY FORM | FIXED FORM | FREE FORM | INVALIDS TO file_spec | LINE_LENGTH decl_arith_exp | no_verify | SEPARATOR char_literal)"""
    def __init__(self, attr_name, value=None, locations=None):
        self.value = value
        self.attr_name = attr_name
        self.locations = locations
        self._used = False

    def get_child_nodes(self):
        return self.value,

    def __repr__(self):
        return "<%s %s>" % (self.__class__.__name__, repr(self.value))


class SourceBinaryForm(SourceAttribute):
    pass


class SourceFixedForm(SourceAttribute):
    pass


class SourceFreeForm(SourceAttribute):
    pass


class SourceInvalids(SourceAttribute):
    pass


class SourceLineLength(SourceAttribute):
    pass


class SourceSeparator(SourceAttribute):
    pass


class SourceInport(FileSpec):
    def __init__(self, file_name=None, locations=None):
        """
        :param file_name: file name.
        :type file_name: ConcatenatedString
        """
        self.value = "INPORT"
        self.locations = locations

    def get_child_nodes(self):
        return ()


class SourceConditional(Decl):
    """
    :ivar cond: cond value.
    :type cond: Expr
    :ivar input_cases: input case.
    :type input_cases: list of InputCase
    :ivar input_else: input item list..
    :type input_else: list
    """
    def __init__(self, arith_exp, input_case_list, input_else, locations=None):
        """
        :param cond: cond value.
        :type cond: Expr
        :param input_case_list: input case.
        :type input_case_list: list of InputCase
        :param input_else: input item list.
        :type input_else: list
        """
        self.cond = arith_exp
        self.input_cases = input_case_list
        self.input_else = input_else
        self.locations = locations
        self.source_name = None
        self._used = False

    def get_child_nodes(self):
        return self.cond, self.input_cases, self.input_else,


class InputCase(Decl):
    """
    :ivar case_labels: case_labels.
    :type case_labels: list of Literal
    :ivar inputs: input item list.
    :type inputs: list
    """
    def __init__(self, case_labels, input_list, locations=None):
        """
        :param case_labels: case_labels.
        :type case_labels: list of (Literal,B{OR})
        :ivar input_list: input item list.
        :type input_list: list
        """
        self.case_labels = case_labels
        self.inputs = input_list
        self.locations = locations
        self._used = False

    def get_child_nodes(self):
        return self.case_labels, self.inputs,

    def __repr__(self):
        return "<CaseInput %s: %s>" % (repr(self.case_labels), repr(self.inputs))


class Label(Decl):
    """
    :ivar name: label name.
    :type name: Name
    """
    type = types.Label()

    def __init__(self, label_name, locations=None):
        """
        :param name: label name.
        :type name: Name
        """
        self.name = label_name
        self.locations = label_name.locations
        self.report_ind = 0
        self._used = False

    def get_child_nodes(self):
        return ()

    def __repr__(self):
        return "<Label:%s>" % self.name


class LabelStmt(Stmt):
    """
    :ivar label: label.
    :type label: Label
    :ivar stmts: statement list.
    :type stmts: list
    """
    def __init__(self, label, stmts):
        """
        :param label: label.
        :type label: Label
        :param stmts: statement list.
        :type stmts: list
        """
        self.label = label
        self.stmts = stmts
        self.locations = label.locations

    def get_child_nodes(self):
        return self.label, self.stmts,


class StructStmt(Stmt):
    pass


class SimpleStmt(Stmt):
    pass


class RelationAccess(StructStmt):
    def __init__(self, relation_name, locations=None):
        StructStmt.__init__(self, locations)
        self.scope = None
        self.where_routine_scope = None
        self.relation_name = relation_name

    @property
    def is_relation_declared(self):
        if isinstance(self.relation_name.definition, Relation):
            for column in self.relation_name.definition.columns:
                if column.definition is None:
                    return False
            return True
        else:
            return False


class CompileDirective(StructStmt):
    """
    :ivar cond: cond value.
    :type cond: Literal
    :ivar else_stmt: else clause.
    :type else_stmt: Stmt
    :ivar case_stmts: case stmts .
    :type case_stmts: list of CaseStmt
    :ivar stmt_used: The statements selected for compilation from among a number of statements.
    :type stmt_used: Stmt
    """
    def __init__(self, cond, case_stmt_list, else_clause, locations=None):
        self.cond = cond
        self.case_stmts = case_stmt_list
        self.else_stmt = else_clause
        self.locations = locations
        self.stmts_to_compile = []

    def get_child_nodes(self):
        return self.cond, self.case_stmts, self.else_stmt,

    def __repr__(self):
        return "<CompileDirective: cond=%s, case_stmts=%s, else_stmt=%s>" % (repr(self.cond), repr(self.case_stmts), repr(self.else_stmt))


class Conditional(StructStmt):
    """
    :ivar cond: cond value.
    :type cond: Literal
    :ivar else_stmt: else clause.
    :type else_stmt: Stmt
    :ivar case_stmts: case stmts .
    :type case_stmts: list of CaseStmt
    """
    def __init__(self, arith_exp, case_stmt_list, else_clause, locations=None):
        self.cond = arith_exp
        self.case_stmts = case_stmt_list
        self.else_stmt = else_clause
        self.locations = locations

    def get_child_nodes(self):
        return self.cond, self.case_stmts, self.else_stmt


class CaseStmt(StructStmt):
    """
    :ivar stmt: statement.
    :type stmt: Stmt
    :ivar case_labels: case_labels.
    :type case_labels: list of Literal
    """
    def __init__(self, case_labels, stmts, locations=None):
        """
        :param case_labels: case_labels.
        :type case_labels: list of (Literal,B{OR})
        :param stmt: statement.
        :type stmt: Stmt
        """
        self.case_labels = case_labels
        self.stmts = stmts
        self.locations = locations

    def get_child_nodes(self):
        return self.case_labels, self.stmts,

    def __repr__(self):
        return "<CaseStmt %s: %s>" % (repr(self.case_labels), repr(self.stmts))


class Display(StructStmt):
    """
    :ivar protected: PROTECTED.
    :type protected: bool
    :ivar frame_names: refers to frames that were previously declared in FRAME declaration statements.
    :type frame_names: list
    :ivar function_key_names: refers to function keys  that were previously declared in FunctionKey declaration statements.
    :type function_key_names: list
    :ivar stmt: Specifies a statement that will be executed by the DISPLAY statement.
    :type stmt: Stmt
    """

    def __init__(self, protected, frame_name_list, function_key_name_list, stmts, locations=None):
        """
        :param protected: token PROTECTED.
        :type protected: bool
        :param frame_name_list: refers to frames that were previously declared in FRAME declaration statements.
        :type frame_name_list: list
        :param function_key_name_list: refers to function keys  that were previously declared in FunctionKey declaration statements.
        :type function_key_name_list: list
        :param stmt: Specifies a statement that will be executed by the DISPLAY statement.
        :type stmt: Stmt
        """
        StructStmt.__init__(self, locations=locations)
        self._location = None
        self.protected = protected
        self.frame_names = frame_name_list
        self.function_key_names = function_key_name_list
        self.stmts = stmts
        self.scopes = []

    def get_child_nodes(self):
        return self.frame_names, self.function_key_names, self.stmts,


class ConditionalLoopStmt(StructStmt):
    def __init__(self, cond, stmts, locations=None):
        StructStmt.__init__(self, locations=locations)
        self.stmts = stmts
        self.cond = cond

    def get_child_nodes(self):
        raise NotImplementedError("Abstract method")


class WhileDo(ConditionalLoopStmt):
    """
    :ivar cond: condition.
    :type cond: Logical
    :ivar stmt: statement.
    :type stmt: Stmt
    """
    def __init__(self, cond, stmts, locations=None):
        """
        :param stmt: statement.
        :type stmt: Stmt
        :param cond: condition.
        :type cond: Logical
        """
        ConditionalLoopStmt.__init__(self, cond=cond, stmts=stmts, locations=locations)

    def get_child_nodes(self):
        return self.cond, self.stmts,


class DoWhile(ConditionalLoopStmt):
    """
    :ivar stmt: statement.
    :type stmt: Stmt
    :ivar cond: condition.
    :type cond: Logical
    """
    def __init__(self, stmts, cond, locations=None):
        """
        :param cond: condition.
        :type cond: Logical
        :param stmt: statement.
        :type stmt: Stmt
        """
        ConditionalLoopStmt.__init__(self, cond=cond, stmts=stmts, locations=locations)

    def get_child_nodes(self):
        return self.stmts, self.cond,


class For(RelationAccess):
    """
    :ivar qualified_rel_alias: qualified  relation alias.
    :type qualified_rel_alias: QualifiedRelationAlias
    :ivar report_names: Prepares one or more reports. Each report-name listed becomes one report.
    :type report_names: list
    :ivar control_clause: control clause.
    :type control_clause: ControlClause
    :ivar stmt: Specifies a statement that will be executed on each item accessed by the FOR EACH statement.
    :type stmt: Stmt
    """
    def __init__(self, qualified_rel_alias, report_name_list, control_clause, stmts, locations=None):
        """
        :param qualified_rel_alias: qualified  relation alias.
        :type qualified_rel_alias: QualifiedRelationAlias
        :param report_name_list: report name list.
        :type report_name_list: list
        :param control_clause: control clause.
        :type control_clause: ControlClause
        :param stmt: Specifies a statement that will be executed on each item accessed by the FOR EACH statement.
        :type stmt: Stmt
        """

        self.qualified_rel_alias = qualified_rel_alias
        self.report_names = report_name_list
        self.control_clause = control_clause
        self.stmts = stmts

        RelationAccess.__init__(self, self.qualified_rel_alias.relation_name, locations=locations)

        self.got_alter = False
        self.got_changing = False
        self.source_location = None
        self._location = None

    @property
    def is_relation_declared(self):
        if isinstance(self.relation_name.definition, (Relation, Source)):
            if isinstance(self.relation_name.definition, Relation):
                for column in self.relation_name.definition.columns:
                    if column.definition is None:
                        return False
            return True
        else:
            return False

    def get_child_nodes(self):
        return self.qualified_rel_alias, self.report_names, self.control_clause, self.stmts,

    @property
    def alias_name(self):
        return self.qualified_rel_alias.alias_name


class ControlClause(BaseAST):
    """
    :ivar group_condition_name_list: group_condition_name_list
    :type names: list of group conditions.
    """
    def __init__(self, group_condition_name_list, locations=None):
        """
        :param group_condition_name_list: group_condition_name_list
        :type names: list of group conditions.
        """
        self.group_condition_names = group_condition_name_list
        self.locations = locations

    def get_child_nodes(self):
        return self.group_condition_names,

    def __repr__(self):
        return "<ControlClause={}>".format(self.group_condition_names)


class If(StructStmt):
    """
    :ivar cond: condition.
    :type cond: Logical
    :ivar then_else_clause: then else clause.
    :type then_else_clause: ThenElseClause
    """
    def __init__(self, cond, then_else_clause, locations):
        """
        :param cond: condition.
        :type cond: Logical
        :param then_else_clause: then else clause.
        :type then_else_clause: ThenElseClause
        """
        self.cond = cond
        self.then_else_clause = then_else_clause
        self.locations = locations

    def get_child_nodes(self):
        return self.cond, self.then_else_clause,


class Insert(RelationAccess):
    """
    :ivar relation_name: relation name.
    :type relation_name: str
    :ivar using_clauses: using clause.
    :type using_clauses: list
    :ivar duplicate_clause: duplicate clause.
    :type duplicate_clause: DuplicateClause
    """
    def __init__(self, relation_name, using_clause_list, duplicate_clause, locations=None):
        """
        :param relation_name: relation name.
        :type relation_name: Name
        :param using_clause_list: using clause.
        :type using_clause_list: list
        :param duplicate_clause: duplicate clause.
        :type duplicate_clause: DuplicateClause
        """
        RelationAccess.__init__(self, relation_name, locations=locations)
        self.using_clauses = using_clause_list
        self.duplicate_clause = duplicate_clause

        self.using_keys = collections.OrderedDict()
        self.using_datas = collections.OrderedDict()

    def get_child_nodes(self):
        return self.using_clauses, self.duplicate_clause,


class UsingClause(StructStmt):
    """
    :ivar data_expression: expresion.
    :type data_expression: Exp
    :ivar parametre: parametre name.
    :type parametre: Name
    """
    def __init__(self, data_exp, param, locations=None):
        """
        :param data_exp: expression.
        :type data_exp: Exp
        :param param: parametre name.
        :type param: Name
        """
        self.data_expression = data_exp
        self.parametre = param
        self.locations = locations

    def get_child_nodes(self):
        return self.data_expression, self.parametre,


class DuplicateClause(StructStmt):
    """
    :ivar clause: statement.
    :type clause: Stmt
    """
    def __init__(self, stmt, locations=None):
        """
        :param stmt: statement.
        :type stmt: Stmt
        """
        self.clause = stmt
        self.locations = locations

    def get_child_nodes(self):
        return self.clause,


class Pause(SimpleStmt):
    """
    :ivar exp: Specifies the number of seconds for which execution is suspended.
    :type exp: Arith
    """
    def __init__(self, exp, locations=None):
        """
        :param exp: number of seconds.
        :type exp: Logical
        """
        self.exp = exp
        self.locations = locations

    def get_child_nodes(self):
        return self.exp,


class PauseForInput(Pause):
    """
    :ivar exp: Specifies the number of seconds for which execution is suspended.
    :type exp: Arith
    :ivar then_else_clause: then else clause.
    :type then_else_clause: ThenElseClause
    """
    def __init__(self, exp, then_else_clause, locations=None):
        """
        :param exp: number of seconds.
        :type exp: Logical
        :param then_else_clause: then else clause.
        :type then_else_clause: ThenElseClause
        """
        self.exp = exp
        self.then_else_clause = then_else_clause
        self.locations = locations

    def get_child_nodes(self):
        return self.exp, self.then_else_clause,


class Protected(StructStmt):
    """
    :ivar stmt: Statement.
    :type stmt: Stmt
    """
    def __init__(self, stmts, locations):
        """
        :param stmt: statement.
        :type stmt: Statement
        """
        self.stmts = stmts
        self.locations = locations

    def get_child_nodes(self):
        return self.stmts,


class Select(RelationAccess):
    """
    :ivar qualified_rel_alias: qualified  relation alias.
    :type qualified_rel_alias: QualifiedRelationAlias
    :ivar then_else_clause: then else clauses.
    :type then_else_clause: ThenElseClause
    """
    def __init__(self, qualified_rel_alias, then_else_clause, locations):
        """
        :param qualified_rel_alias: qualified  relation alias.
        :type qualified_rel_alias: QualifiedRelationAlias
        :param then_else_clause: then else clauses.
        :type then_else_clause: ThenElseClause
        """
        self.qualified_rel_alias = qualified_rel_alias
        self.then_else_clause = then_else_clause
        RelationAccess.__init__(self, self.qualified_rel_alias.relation_name, locations=locations)

        self.got_alter = False

    @property
    def alias_name(self):
        return self.qualified_rel_alias.alias_name

    def get_child_nodes(self):
        return self.qualified_rel_alias, self.then_else_clause,


class WriteReport(StructStmt):
    """
    :ivar report_names: Prepares one or more reports. Each report-name listed becomes one report.
    :type report_names: list
    :ivar stmts: statements.
    :type stmts: list
    """
    def __init__(self, report_name_list, stmts, locations):
        """
        :param report_name_list: report name list.
        :type report_name_list: list
        :param stmts: statements.
        :type stmts: list
        """
        self.report_names = report_name_list
        self.stmts = stmts
        self.locations = locations
        self.no_report_decls = False

    def get_child_nodes(self):
        return self.report_names, self.stmts,


class Abort(SimpleStmt):
    """
    :ivar output_list: Specifies the output to be printed at the terminal when the abort statement is executed..
    :type output_list: list
    """
    def __init__(self, output_list, locations=None):
        """
        :param output_list: output list.
        :type output_list: list
        """
        self.output_list = output_list
        self.locations = locations

    def get_child_nodes(self):
        return self.output_list,


class Accept(SimpleStmt):
    """
    :ivar from_terminal: Reads input from the terminal rather than from the input port.
    :type from_terminal: bool
    :ivar echo: Causes characters not to be printed as they are being typed during input.
    :type echo: Echo|NoEcho|None
    :ivar verify: Causes ignore any VERIFY clauses included in the FIELD declarations of the fields receiving input.
    :type verify: Verify|NoVerify|None
    :ivar field_names: field name list.
    :type field_names: list
    :ivar prompt_clause: .
    :type prompt_clause: list
    """
    def __init__(self, from_terminal, echo, verify, field_name_list, prompt_clauses, locations=None):
        """
        :param from_terminal: Reads input from the terminal rather than from the input port.
        :type from_terminal: bool
        :param echo: Causes characters not to be printed as they are being typed during input.
        :type echo: Echo|NoEcho|None
        :param verify: Causes ignore any VERIFY clauses included in the FIELD declarations of the fields receiving input.
        :type verify: Verify|NoVerify|None
        :param field_name_list: field name list.
        :type field_name_list: list
        :param prompt_clause: .
        :type prompt_clause: list
        """
        self.from_terminal = from_terminal
        self.echo = echo
        self.verify = verify
        self.field_names = field_name_list
        self.prompt_clauses = prompt_clauses
        self.locations = locations
        self.in_local_function_key = False

    def get_child_nodes(self):
        return self.field_names, self.prompt_clauses,


class ForClause(BaseAST):
    """
    :ivar field_clauses: List field clause.
    :type field_clauses: list
    :ivar field_name: field name.
    :type field_name: Name
    """
    def __init__(self, field_clauses, field_name, locations=None):
        """
        :param field_clauses: List field clause.
        :type field_clauses: lise
        :param field_name: field name.
        :type field_name: Name
        """
        self.field_clauses = field_clauses
        self.field_name = field_name
        self.locations = locations

    def get_child_nodes(self):
        return self.field_clauses, self.field_name,


class Assign(SimpleStmt):
    """
    :ivar exp: Is any valid numeric expression.
    :type exp: Arith
    :ivar receiving_fields: Specifies the fields receiving the result of the addition.
    :type receiving_fields: list
    :ivar conversion_type: Specifies whether the expression resulting from the ADD statement will be rounded or truncated (if necessary).
    :type conversion_type: ConversionType
    :ivar echo: Causes the characters you type to be displayed at the terminal.
    :type echo: Echo|NoEcho|None
    """
    def __init__(self, exp, receiving_field_list, conversion_type=None, echo=None, locations=None):
        """
        :param exp: expression.
        :type exp: Arith
        :param receiving_field_list: receiving fields list.
        :type receiving_field_list: list
        :param conversion_type: conversion type.
        :type conversion_type: ConversionType
        :param echo: echo.
        :type echo: Echo|NoEcho|None
        """
        self.exp = exp
        self.receiving_fields = receiving_field_list
        self.conversion_type = conversion_type
        self.echo = echo
        self.locations = locations
        self.in_local_function_key = False

    def get_child_nodes(self):
        return self.exp, self.receiving_fields,


class Add(Assign):
    pass


class Subtract(Assign):
    pass


class Move(Assign):
    pass


class Let(Assign):
    pass


class Alter(RelationAccess):
    """
    :ivar relation_name: relation name.
    :type relation_name: str
    :ivar using_clauses: using clause.
    :type using_clauses: list
    """
    def __init__(self, relation_name, using_clause_list, locations=None):
        """
        :param relation_name: relation name.
        :type relation_name: str
        :param using_clause_list: using clause.
        :type using_clause_list: list
        """
        RelationAccess.__init__(self, relation_name, locations=locations)
        self.using_clauses = using_clause_list

        self.to_skip = True
        self.using_parametres = collections.OrderedDict()

    def get_child_nodes(self):
        return self.using_clauses,


class Checkpoint(SimpleStmt):
    """
    :ivar name_list: name list.
    :type name_list: list
    """
    def __init__(self, name_list, locations=None):
        """
        :param name_list: names list.
        :type name_list: list
        """
        self.name_list = name_list
        self.locations = locations

    def get_child_nodes(self):
        return self.name_list,


class Clear(SimpleStmt):
    def __init__(self, locations=None):
        self.locations = locations

    def get_child_nodes(self):
        return ()


class ClearFrame(Clear):
    """
    :ivar frame_names: is a list of the frames that you wish to clear.
    :type frame_names: list
    """
    def __init__(self, frame_name_list, locations=None):
        """
        :ivar frame_name_list: is a list of the frames that you wish to clear.
        :type frame_name_list: list
        """
        self.frame_names = frame_name_list
        self.locations = locations
        self.function_key = None

    @property
    def in_function_key(self):
        return isinstance(self.function_key, FunctionKey)

    @property
    def in_local_function_key(self):
        return self.in_function_key and not self.function_key.is_globally

    @property
    def in_global_function_key(self):
        return self.in_function_key and self.function_key.is_globally

    def get_child_nodes(self):
        return self.frame_names,


class ClearTerminalInport(Clear):
    pass


class ClearTerminalOutport(Clear):
    pass


class DeleteFile(SimpleStmt):
    """
    :ivar file_spec: file specified.
    :type file_spec: str
    """
    def __init__(self, file_spec, locations=None):
        """
        :param file_spec: file specified.
        :type file_spec: str
        """
        self.file_spec = file_spec
        self.locations = locations

    def get_child_nodes(self):
        return self.file_spec,


class DeleteRelation(RelationAccess):
    """
    :ivar qualified_rel_alias: qualified relation.
    :type qualified_rel_alias: QualifiedRelationAlias
    :ivar all: all.
    :type all: bool
    """
    def __init__(self, qualified_relation, _all, locations=None):
        """
        :param qualified_rel_alias: qualified  relation alias.
        :type qualified_rel_alias: QualifiedRelationAlias
        :param all:  ALL.
        :type all: bool
        """
        self.qualified_rel_alias = qualified_relation
        RelationAccess.__init__(self, self.qualified_rel_alias.relation_name, locations=locations)
        self.all = _all

    @property
    def alias_name(self):
        return self.qualified_rel_alias.alias_name

    def get_child_nodes(self):
        return self.qualified_rel_alias,


class Finish(SimpleStmt):
    """
    :ivar label_name: label name.
    :type label_name: Name
    """
    def __init__(self, label_name, locations=None):
        """
        :param label_name: label name.
        :type label_name: Name
        """
        self.label_name = label_name
        self.locations = locations

        self.report_names = []

    def get_child_nodes(self):
        return ()


class Force(SimpleStmt):
    """
    :ivar report_cond: report condition.
    :type report_cond: [ReportCondition|GroupCondition|Name]
    :ivar report_name: report name.
    :type report_name: Name
    """
    def __init__(self, report_cond, report_name, locations):
        """
        :param report_cond: report condition.
        :type report_cond: [ReportCondition|GroupCondition|Name]
        :param report_name: report name.
        :type report_name: Name
        """
        self.report_cond = report_cond
        self.report_name = report_name
        self.locations = locations

    def get_child_nodes(self):
        return self.report_cond,


class FunctionStmt(SimpleStmt):
    """
    :ivar name: function name.
    :type name: Name
    :ivar calling_parameters: A list of values supplied to the subroutine.
    :type calling_parameters: list
    :ivar calling_parameters: A list of field names where the value(s) of any RETURNING parameter(s).
    :type accepting_parameters: list
    """
    def __init__(self, name, calling_parameters, accepting_parameters, locations=None):
        """
        :param name: function name.
        :type name: Name
        :param calling_parameters: parameters.
        :type calling_parameters: list
        :param accepting_parameters: parameters.
        :type accepting_parameters: list
        """
        self.name = name
        self.calling_parameters = calling_parameters
        self.accepting_parameters = accepting_parameters
        self.locations = locations
        self._definition = None
        self.in_local_function_key = False

    def get_child_nodes(self):
        return self.name, self.calling_parameters, self.accepting_parameters,


class RunStmt(FunctionStmt):
    pass


class Input(SimpleStmt):
    """
    :ivar echo: controls the echo of characters on the screen during input.
    :type echo: bool
    :ivar verify: controls whether the value entered for a field is checked against the value constraints specified in the field's VERIFY clause.
    :type verify: bool
    :ivar field_names: specifies the frame fields in which the data read from the terminal is to be stored.
    :type field_names: list of Id
    :ivar function_key_names: refers to function keys  that were previously declared in FunctionKey declaration statements.
    :type function_key_names: list
    """
    def __init__(self, echo, verify, field_name_list, function_key_name_list, locations=None):
        """
        :param echo: controls the echo of characters on the screen during input.
        :type echo: bool
        :param verify: controls whether the value entered for a field is checked against the value constraints specified in the field's VERIFY clause.
        :type verify: bool
        :param field_name_list: specifies the frame fields in which the data read from the terminal is to be stored.
        :type field_name_list: list
        :param function_key_name_list: refers to function keys  that were previously declared in FunctionKey declaration statements.
        :type function_key_name_list: list
        """
        self.field_names = field_name_list
        self.function_key_names = function_key_name_list
        self.echo = echo
        self.verify = verify
        self.locations = locations

        self.functions_key = []
        self.frame_stack = []

    def get_child_nodes(self):
        return self.field_names, self.function_key_names,


class ConversionType(BaseAST):
    """
    The conversion type to be used during assignment to a numeric field may be specified in either of the following ways :ROUND[ED] TRUNC[ATED]
    """
    def __init__(self, locations=None):
        self.locations = locations

    def get_child_nodes(self):
        return ()


class Rounded(ConversionType):
    pass


class Truncated(ConversionType):
    pass


class AsPicture(ConversionType):
    """
    :ivar picture: indicating the alternate picture.
    :type picture: Picture
    """
    def __init__(self, picture_clause, locations=None):
        """
        :param picture_clause: picture clause.
        :type picture_clause: Picture
        """
        self.picture = picture_clause
        self.locations = locations

    @property
    def type(self):
        return self.picture.type

    def get_child_nodes(self):
        return self.picture,

    def __repr__(self):
        return "<AsPicture: AS %s>" % (repr(self.picture))


class AsByte(AsPicture):
    """
    :ivar index: index.
    :type index: Literal
    """
    type = types.Byte()

    def __init__(self, index, locations=None):
        """
        :param index: index.
        :type index: Literal
        """
        self.index = index
        self.locations = locations

    def get_child_nodes(self):
        return ()


class AsId(AsPicture):
    """
    :ivar id: indicating that the picture to be used is the picture associated with field name in its declaration.
    :type id: Id
    """
    def __init__(self, _id, locations=None):
        """
        :param id: id.
        :type id: Id
        """
        self.id = _id
        self._type = None
        self._picture = None
        self.locations = locations

    @property
    def type(self):
        if self._type is not None:
            return self._type
        else:
            return self.id.type

    @type.setter
    def type(self, v):
        self._type = v

    @property
    def picture(self):
        if self._picture is not None:
            return self._picture
        else:
            return self.id.picture

    @picture.setter
    def picture(self, v):
        self._picture = v

    def get_child_nodes(self):
        return self.id,

    def __repr__(self):
        return "<AsId: AS %s>" % (repr(self.id))


class AsArrayId(AsId):
    """
    :ivar id: indicating that the picture to be used is the picture associated with array name in its declaration.
    :type id: ArrayId
    """
    def __init__(self, _id, locations=None):
        """
        :param id: id.
        :type id: ArrayId
        """
        self.id = _id
        self._type = None
        self._picture = None
        self.locations = locations

    @property
    def type(self):
        if self._type is not None:
            return self._type
        else:
            return self.id.type

    @type.setter
    def type(self, v):
        self._type = v

    @property
    def picture(self):
        if self._picture is not None:
            return self._picture
        else:
            return self.id.picture

    @picture.setter
    def picture(self, v):
        self._picture = v

    def get_child_nodes(self):
        return self.id,

    def __repr__(self):
        return "<AsArrayId: AS %s>" % (repr(self.id))


class AsConstant(AsPicture):
    """
    :ivar id: indicating that the picture to be used is the picture associated with constant name in its declaration.
    :type id: ConstantRef
    """
    def __init__(self, _id, locations=None):
        """
        :param id: id.
        :type id: ConstantRef
        """
        self.id = _id
        self._type = None
        self._picture = None
        self.locations = locations

    @property
    def type(self):
        if self._type is not None:
            return self._type
        else:
            return self.id.type

    @type.setter
    def type(self, v):
        self._type = v

    @property
    def picture(self):
        if self._picture is not None:
            return self._picture
        else:
            return self.id.picture

    @picture.setter
    def picture(self, v):
        self._picture = v

    def get_child_nodes(self):
        return self.id,

    def __repr__(self):
        return "<AsConstant: AS %s>" % (repr(self.id))


class Echo(BaseAST):
    """
    Causes the characters you type to be displayed at the terminal.
    """
    def __init__(self, attr_name, locations=None):
        self.attr_name = attr_name
        self.locations = locations

    def get_child_nodes(self):
        return ()


class NoEcho(Echo):
    """
    Causes the characters you type to be not displayed at the terminal.
    """
    pass


class Verify(BaseAST):
    """
    Causes to check value constraints specified in VERIFY clauses of field declarations.
    """
    def __init__(self, attr_name, locations=None):
        self.locations = locations
        self.attr_name = attr_name

    def get_child_nodes(self):
        return ()


class NoVerify(Verify):
    """
    Causes ignore any VERIFY clauses included in the FIELD declarations of the fields receiving input.
    """
    pass


class Logout(SimpleStmt):
    def __repr__(self):
        return "<Logout>"


class Nothing(SimpleStmt):
    def __repr__(self):
        return "<Nothing>"


class Print(SimpleStmt):
    """
    :ivar report_name: Specifies the report to which the output is to be written if output is to be printed in a named report.
    :type report_name: Name
    :ivar output_list: Is a list of data values and other output items.
    :type output_list: list
    """
    def __init__(self, report_name, output_list, locations):
        """
        :param report_name: report name.
        :type report_name: Name
        :param output_list: output list.
        :type output_list: list
        """
        self.report_name = report_name
        self.output_list = output_list
        self.locations = locations

    def get_child_nodes(self):
        return self.output_list,


class Prompt(SimpleStmt):
    """
    :ivar output_list: is a data value or other output item which prompts the user for input.
    :type output_list: list
    """
    def __init__(self, output_list, locations):
        """
        :param output_list: output list.
        :type output_list: list
        """
        self.output_list = output_list
        self.locations = locations

    def get_child_nodes(self):
        return self.output_list,


class Repeat(SimpleStmt):
    """
    :ivar label_name: label name.
    :type label_name: Name
    """
    def __init__(self, label_name, locations):
        """
        :param label_name: label name.
        :type label_name: Name
        """
        self.label_name = label_name
        self.locations = locations

        self.report_names = []

    def get_child_nodes(self):
        return ()


class Restore(SimpleStmt):
    """
    :ivar frame_names: refers to frames that were previously declared in FRAME declaration statements.
    :type frame_names: list
    """
    def __init__(self, frame_name_list, locations=None):
        """
        :param frame_name_list: refers to frames that were previously declared in FRAME declaration statements.
        :type frame_name_list: list
        """
        self.frame_names = frame_name_list
        self.locations = locations
        self.function_key = None

    @property
    def in_function_key(self):
        return isinstance(self.function_key, FunctionKey)

    @property
    def in_local_function_key(self):
        return self.in_function_key and not self.function_key.is_globally

    @property
    def in_global_function_key(self):
        return self.in_function_key and self.function_key.is_globally

    def get_child_nodes(self):
        return self.frame_names,


class Return(SimpleStmt):
    """
    :ivar using_clauses: using clause.
    :type using_clauses: list
    """
    def __init__(self, using_clause_list, locations):
        """
        :param using_clause_list: using clause.
        :type using_clause_list: list
        """
        self.using_clauses = using_clause_list
        self.locations = locations
        self.returning_parameters = []

    def get_child_nodes(self):
        return self.using_clauses,


class SetCursor(SimpleStmt):
    """
    :ivar after: after
    :type after: bool
    :ivar field: refers to a field of a frame being displayed.
    :type field: Id
    """
    def __init__(self, after, field_id, locations):
        """
        :param after: after
        :type after: bool
        :param field_id: field
        :type field: Id
        """
        self.after = after
        self.field = field_id
        self.locations = locations

    def get_child_nodes(self):
        return self.field,


class Type(SimpleStmt):
    """
    :ivar output_list: Is a data value or other output item
    :type output_list: list
    """
    def __init__(self, output_list, locations=None):
        """
        :param output_list: output list.
        :type output_list: list
        """
        self.output_list = output_list
        self.locations = locations

    def get_child_nodes(self):
        return self.output_list,


class TypeToMessageArea(Type):
    pass


class TypeToTerminal(Type):
    pass


class Wait(SimpleStmt):
    """
    :ivar output_list: Is a data value or other output item
    :type output_list: list
    """
    def __init__(self, output_list, locations=None):
        """
        :param output_list: output list.
        :type output_list: list
        """
        self.output_list = output_list
        self.locations = locations

    def get_child_nodes(self):
        return self.output_list,


class WriteInvalids(SimpleStmt):
    """
    :ivar name: source name.
    :type name: str
    :ivar output_list: Is a data value or other output item
    :type output_list: list
    """
    def __init__(self, source_name, output_list, locations):
        """
        :param source_name: source name.
        :type source_name: str
        :param output_list: output list.
        :type output_list: list
        """
        self.source_name = source_name
        self.output_list = output_list
        self.locations = locations

    def get_child_nodes(self):
        return self.source_name, self.output_list,


class Expr(BaseAST):
    # Expression is an artificial node class
    """
    :ivar conversion_type: The conversion rules described here also apply to the conversion of character data according to an alternate picture.
    :type conversion_type: list of AsPicture
    """
    def __init__(self, locations=None):
        self.locations = locations
        self._conversion_types = []
        self._definition = None
        self._basic_type = None
        self._basic_picture = None

    @property
    def definition(self):
        return self._definition

    @definition.setter
    def definition(self, value):
        self._definition = value

    @property
    def conversion_types(self,):
        return self._conversion_types

    @conversion_types.setter
    def conversion_types(self, cvt):
        self._conversion_types = cvt

    @property
    def type(self):
        if len(self.conversion_types) > 0:
            return self.conversion_types[-1].type
        else:
            return self.basic_type

    @type.setter
    def type(self, typ):
        self._basic_type = typ

    @property
    def picture(self):
        if len(self.conversion_types) > 0:
            return self.conversion_types[-1].picture
        else:
            return self.basic_picture

    @picture.setter
    def picture(self, value):
        self._basic_picture = value

    @property
    def basic_type(self):
        return self._basic_type

    @property
    def basic_picture(self):
        return self._basic_picture

    @basic_picture.setter
    def basic_picture(self, pic):
        self._basic_picture = pic

    def get_child_nodes(self):
        return ()


class Logical(Expr):
    def __init__(self, left, right, locations=None):
        Expr.__init__(self, locations=locations)
        self.left = left
        self.right = right
        self.type = types.Boolean()

    def get_child_nodes(self):
        return self.left, self.right,

    def __repr__(self):
        return "%s(%s, %s)" % (self.__class__.__name__, repr(self.left), repr(self.right))


class And(Logical):
    pass


class Or(Logical):
    pass


class Eqv(Logical):
    pass


class Xor(Logical):
    pass


class Rel(Logical):
    """ REL: arith_exp [EQ|GE|GT|LE|LT|NE] arith_exp """
    pass


class Eq(Rel):
    pass


class Ge(Rel):
    pass


class Gt(Rel):
    pass


class Le(Rel):
    pass


class Lt(Rel):
    pass


class Ne(Rel):
    pass


class Is(Rel):
    """
    provides a logical expression that tests whether the current value of a data expression can be converted in a specified manner without error or undefined results
    """
    pass


class UnaryRel(Rel):
    def __init__(self, exp, locations=None):
        Rel.__init__(self, exp, None, locations)

    def get_child_nodes(self):
        return self.left,

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, repr(self.left))


class Not(UnaryRel):
    pass


class Changing(UnaryRel):
    def __init__(self, exp, locations=None):
        UnaryRel.__init__(self, exp, locations=locations)


class NotChanging(Changing):
    pass


class Illegal(UnaryRel):
    pass


class FileExists(UnaryRel):
    pass


class TextExists(UnaryRel):
    pass


class Enclosed(UnaryRel):
    pass


class ExtendedComparison(Rel):
    """ bool_exp: bool_exp [AND |OR|] [EQ|GE|GT|LE|LT|NE] arith_exp """

    def __init__(self, locations=None):
        Rel.__init__(self, None, None, locations=locations)
        self.exps = []

    def get_child_nodes(self):
        return self.exps,

    def add(self, exp):
        self.exps.append(exp)

    def __repr__(self):
        return "%s(%r)" % (self.__class__.__name__, self.exps)


class ExtendedComparisonAnd(ExtendedComparison):
    pass


class ExtendedComparisonOr(ExtendedComparison):
    pass


class Literal(Expr):
    def __init__(self, value, locations=None):
        Expr.__init__(self, locations)
        self.value = value

    @property
    def size(self):
        return len(self.value)

    def __repr__(self):
        return repr(self.value)

    def __str__(self):
        return str(self.value)


class String(Literal):
    def __init__(self, value, locations=None):
        Literal.__init__(self, value, locations)
        self.type = types.String()
        self.picture = StringPicture(literal_value=value, locations=locations)

    def __len__(self):
        return self.size


class ControlCharacter(String):
    """character constant (@integer, @CR, and @FF)"""

    def __init__(self, token, locations=None):
        Expr.__init__(self, locations)
        self.token = token
        self.type = types.String()
        self.picture = StringPicture(value='C', locations=locations)

    def __len__(self):
        return 1

    @property
    def value(self):
        if self.token.lower() == "@cr":
            return "\\n"
        elif self.token.lower() == "@ff":
            return "\\f"
        else:
            return self.token[1:]


class ConcatenatedString(String):
    """
    :ivar values: list value
    :type values: list
    :ivar value: eval concatenated string
    :type value: str
    """

    def __init__(self, value, locations=None):
        Expr.__init__(self, locations)
        self._values = []
        self.append(value)
        self.type = types.String()
        self.resolved_values = None

    def append(self, new_value):
        if self.values is None:
            self.values = []
        self.values.append(new_value)

    @property
    def value(self):
        if isinstance(self.resolved_values, list):
            return "".join(map(lambda val: getattr(val, "value"), self.resolved_values))
        elif len(self.values) == 1:
            return self.values[0]
        return self.resolved_values

    @property
    def values(self):
        return self._values

    @values.setter
    def values(self, new_values):
        self._values = new_values

    @classmethod
    def from_values(cls, values):
        result = None
        for value in values:
            if result is None:
                result = cls(value)
            else:
                result.append(value)
        return result


class Date(Literal):
    def __init__(self, value, locations=None):
        Literal.__init__(self, value, locations)
        self.type = types.Date()
        self.picture = UnknownPicture()


class Numeric(Literal):
    def __init__(self, value, locations=None):
        Literal.__init__(self, value, locations)
        self.type = types.Numeric()

    def __repr__(self):
        return str(self.value)


class Integer(Numeric):
    def __init__(self, value, locations=None):
        Numeric.__init__(self, value, locations=locations)
        self.type = types.Integer()
        self.picture = IntegerPicture(literal_value=value, locations=locations)


class Decimal(Numeric):
    def __init__(self, value, locations=None):
        Numeric.__init__(self, value, locations=locations)
        self.type = types.Decimal()
        self.picture = DecimalPicture(literal_value=value, locations=locations)


class Float(Numeric):
    def __init__(self, value, locations=None):
        Numeric.__init__(self, value, locations=locations)
        self.type = types.Decimal()
        self.picture = UnknownPicture()


class Double(Numeric):
    def __init__(self, value, locations=None):
        Numeric.__init__(self, value, locations=locations)
        self.type = types.Decimal()
        self.picture = UnknownPicture()


class Boolean(Literal):
    def __init__(self, value, locations=None):
        Literal.__init__(self, value, locations)
        self.type = types.Boolean()


class ConstantRef(Literal):
    """
    :ivar name: constant name
    :type name: Name
    :ivar value: constant value
    :type value: Literal
    """
    def __init__(self, constant_name, locations=None):
        Expr.__init__(self, locations)
        self.name = constant_name

    @property
    def definition(self):
        return self.name.definition

    @property
    def basic_type(self):
        return self.name.type

    @property
    def basic_picture(self):
        return self.name.picture

    @property
    def value(self):
        try:
            return self.definition.value
        except AttributeError:
            return None

    def get_child_nodes(self):
        return self.name,

    def __eq__(self, item):
        if isinstance(item, ConstantRef):
            return self.name == item.name
        else:
            return False

    def __str__(self):
        return str(self.name)

    def __repr__(self):
        return "ConstantRef:<%s>" % repr(self.name)

    def __hash__(self):
        return hash(str(self))


class Id(Expr):
    def __init__(self, name, of_name=None, locations=None):
        Expr.__init__(self, locations=locations)
        self.name = name
        self.of_name = of_name
        self.scope = None

    @property
    def definition(self):
        return self.name.definition

    @property
    def basic_type(self):
        return self.name.type

    @property
    def basic_picture(self):
        return self.name.picture

    def get_child_nodes(self):
        return self.name,

    # TODO: to rework, it's so ugly ...
    def __hash__(self):
        return hash(repr(self))

    def __repr__(self):
        if self.of_name is None:
            return "<Id:%s>" % (repr(self.name),)
        return "<Id:%s OF %s>" % (repr(self.name), repr(self.of_name),)

    def __eq__(self, other):
        if isinstance(other, Id):
            return self.name == other.name and self.of_name == other.of_name
        return False


class ReturningFunction(Id):
    pass


class ArrayId(Id):
    def __init__(self, name, index, of_name=None, locations=None):
        Id.__init__(self, name, of_name=of_name, locations=locations)
        self.index = index
        self.check_subscripts = None
        self.array_definition = None

    def __repr__(self):
        return "<ArrayId:%s>" % (repr(self.name),)


class ArrayIndex(Expr):
    def __init__(self, index, locations=None):
        Expr.__init__(self, locations=locations)
        self.index = index

    def __repr__(self):
        return "<ArrayIndex(%s)>" % (repr(self.index))


class ArrayIndexAll(ArrayIndex):
    def __init__(self, locations=None):
        Expr.__init__(self, locations=locations)

    def __repr__(self):
        return "<ArrayIndex(ALL)>"


class ArrayIndexTo(ArrayIndex):
    def __init__(self, lower, upper, locations=None):
        Expr.__init__(self, locations=locations)
        self.lower = lower
        self.upper = upper

    def __repr__(self):
        return "<ArrayIndex(%s to %s)>" % (repr(self.lower), repr(self.upper))


class AcceptInputId(Id):

    def __init__(self, name, of_name=None, input_picture=None, locations=None):
        Id.__init__(self, name, of_name, locations)
        self.input_picture = input_picture


class AcceptInputArrayId(ArrayId):

    def __init__(self, name, index, of_name=None, input_picture=None, locations=None):
        ArrayId.__init__(self, name, index, of_name, locations)
        self.input_picture = input_picture


class SourceInputId(Id):
    def __init__(self, name, input_picture=None):
        Id.__init__(self, name)
        self.input_picture = input_picture


class SourceInputArrayId(ArrayId):
    def __init__(self, name, index, of_name=None, locations=None):
        ArrayId.__init__(self, name, index, of_name, locations)


class RelationFieldId(Id):
    def __repr__(self):
        if self.of_name is None:
            return "<RelationFieldId:%s>" % (repr(self.name),)
        return "<RelationFieldId:%s OF %s>" % (repr(self.name), repr(self.of_name),)


class ViaFieldId(Id):
    pass


class ReferenceId(Id):
    pass


class Op(Expr):
    pass


class Default(Expr):
    def __repr__(self):
        return "<Default>"


class Arith(Op):
    def __init__(self, left, right, locations=None):
        Op.__init__(self, locations)
        self.left = left
        self.right = right

    def get_child_nodes(self):
        return self.left, self.right,

    def __repr__(self):
        return "%s(%s, %s)" % (self.__class__.__name__, repr(self.left), repr(self.right))


class Unary(Op):
    def __init__(self, right, locations=None):
        Op.__init__(self, locations)
        self.right = right

    def get_child_nodes(self):
        return self.right,

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, repr(self.right))


class Uminus(Unary):
    """ arith_exp: B{MINUS} arith_exp """
    pass


class Uplus(Unary):
    """ arith_exp: B{PLUS} arith_exp """
    pass


class Pow(Arith):
    """ arith_exp: arith_exp B{POW} arith_exp """
    pass


class Mul(Arith):
    """ arith_exp: arith_exp B{STAR} arith_exp """
    pass


class Div(Arith):
    """ arith_exp: arith_exp B{SLASH} arith_exp """
    pass


class FloorDiv(Arith):
    """ arith_exp: arith_exp B{DOUBLESLASH} arith_exp """
    pass


class Mod(Arith):
    """ arith_exp: arith_exp B{MOD} arith_exp """
    pass


class Plus(Arith):
    """ arith_exp: arith_exp B{PLUS} arith_exp """
    pass


class Minus(Arith):
    """ arith_exp: arith_exp B{MINUS} arith_exp """
    pass


class ImplicitSelect(Expr):
    """
    :ivar field_name: field name.
    :type field_name: str
    :ivar qualified_rel_alias: qualified relation alias.
    :type qualified_rel_alias: QualifiedRelationAlias
    """
    def __init__(self, field_name, relation_name, via_clause, locations=None):
        """
        :param field_name: field name.
        :type field_name: str
        :param relation_name: relation name.
        :type relation_name: str
        :param via_clause: via clause.
        :type via_clause: ViaClause
        """
        Expr.__init__(self, locations)
        self.field_name = field_name
        self.qualified_rel_alias = QualifiedRelationAlias(relation_name, None, None, via_clause, None, None, None)

    @property
    def is_relation_declared(self):
        if isinstance(self.relation_name.definition, Relation):
            for column in self.relation_name.definition.columns:
                if column.definition is None:
                    return False
            return True
        else:
            return False

    @property
    def definition(self):
        return self.field_name.definition

    @property
    def basic_type(self):
        return self.field_name.type

    @property
    def basic_picture(self):
        return self.field_name.picture

    @property
    def relation_name(self):
        return self.qualified_rel_alias.relation_name

    @property
    def alias_name(self):
        return self.qualified_rel_alias.alias_name

    def get_child_nodes(self):
        return self.field_name, self.qualified_rel_alias


class CallingFunction(Expr):
    """
    :ivar name: function name.
    :type name: Name
    :ivar parameters: parameters.
    :type parameters: list
    """
    def __init__(self, name, parameters, locations=None):
        """
        :param name: function name.
        :type name: Name
        :param parameters: parameters.
        :type parameters: list
        """
        Expr.__init__(self, locations)
        self.name = name
        self.parameters = parameters
        self.skip = False

    def get_child_nodes(self):
        return self.name, self.parameters,

    def __repr__(self):
        return "<CallingFunction:%s(%r)>" % (repr(self.name), ",".join([repr(param) for param in self.parameters]))


class CumulativeFunction(CallingFunction):
    def __init__(self, name, parameters, locations=None):
        CallingFunction.__init__(self, name, parameters, locations=locations)
        self.report_name = None
        self.in_report_footing = False
        self.in_group_footing = False
        self.group_footing_condition = None

    def get_child_nodes(self):
        return self.name,

    def __repr__(self):
        return "<%s:%s>" % (self.__class__.__name__, repr(self.name))


class AggregateFunction(CallingFunction):
    def __init__(self, name, parameters, locations=None):
        CallingFunction.__init__(self, name, parameters, locations=locations)
        self.position = -1

    def get_child_nodes(self):
        return self.name, self.parameters,

    def __repr__(self):
        return "<%s:%s>" % (self.__class__.__name__, repr(self.name))


class LanguageControl(Expr):
    def __init__(self, locations=None):
        Expr.__init__(self, locations)

    def __repr__(self):
        return "<%s>" % self.__class__.__name__


class UsersLanguage(LanguageControl):
    def __init__(self, locations=None):
        LanguageControl.__init__(self, locations)
        self.type = types.String()
        self.picture = StringPicture(value='64C')
        self.name = "USER LANGUAGE"


class DateLanguage(LanguageControl):
    def __init__(self, locations=None):
        LanguageControl.__init__(self, locations)
        self.type = types.String()
        self.picture = StringPicture(value='64C')
        self.name = "DATE LANGUAGE"


class DigitSeparator(LanguageControl):
    def __init__(self, locations=None):
        LanguageControl.__init__(self, locations)
        self.type = types.String()
        self.picture = StringPicture(value='2C')
        self.name = "DIGIT SEPARATOR"


class ReportItem(Expr):

    def __init__(self, item_name, report_name, locations=None):
        Expr.__init__(self, locations)
        self.report_name = report_name
        self._report_name = None
        self.item_name = item_name

    def get_child_nodes(self):
        if self._report_name is not None:
            return self._report_name,
        return self.report_name,

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, ("" if self.report_name is None else repr(self.report_name)))


class ReportBottomMargin(ReportItem):
    pass


class ReportFootingSize(ReportItem):
    pass


class ReportHeadingSize(ReportItem):
    pass


class ReportLineLength(ReportItem):
    pass


class ReportLineNum(ReportItem):
    pass


class ReportPageNum(ReportItem):
    pass


class ReportPageSize(ReportItem):
    pass


class ReportTopMargin(ReportItem):
    pass


class ReportPageTop(ReportItem):
    def __init__(self, item_name, report_name, locations=None):
        ReportItem.__init__(self, item_name, report_name, locations)
        self.in_page_report_headers_or_page_footers = False


class ReportPageDivider(ReportItem):
    pass


class FlagReference(Expr):
    def __init__(self, name, locations=None):
        Expr.__init__(self, locations=locations)
        self.name = name
        self.type = types.Boolean()

    def get_child_nodes(self):
        return self.name,

    def __repr__(self):
        return "%s(%s)" % (self.__class__.__name__, repr(self.name))


class FlagName(FlagReference):
    def __init__(self, name, flag_param=None, locations=None):
        FlagReference.__init__(self, name, locations=locations)
        self.flag_param = flag_param

    def __repr__(self):
        if self.flag_param is None:
            return "%s(%s)" % (self.__class__.__name__, repr(self.field_name))
        else:
            return "%s(%s)" % (self.flag_param.__class__.__name__, repr(self.field_name))


class FlagBlank(FlagReference):
    pass


class FlagBlink(FlagReference):
    pass


class FlagBold(FlagReference):
    pass


class FlagDim(FlagReference):
    pass


class FlagEntered(FlagReference):
    pass


class FlagInitial(FlagReference):
    pass


class FlagLow(FlagReference):
    pass


class FlagMinimun(FlagReference):
    pass


class FlagOpaque(FlagReference):
    pass


class FlagProtected(FlagReference):
    pass


class FlagRequired(FlagReference):
    pass


class FlagReverse(FlagReference):
    pass


class FlagTerminate(FlagReference):
    pass


class FlagUnderline(FlagReference):
    pass


class FlagValue(FlagReference):
    pass


class FlagVerify(FlagReference):
    pass


class QualifiedRelationAlias(BaseAST):
    """
    :ivar relation_name: relation name.
    :type relation_name: Name
    :ivar alias_name: alias name.
    :type alias_name: Name
    :ivar join_clause_list: list of join clause
    :type join_clause_list: list of JoinClause
    :ivar via_clause: via clause.
    :type via_clause: ViaClause
    :ivar where_clause: where clause.
    :type where_clause: WhereClause
    :ivar grouped_clause: grouped clause.
    :type grouped_clause: GroupedClause
    :ivar sorted_clause: sorted clause.
    :type sorted_clause: SortedClause
    """
    def __init__(self, relation_name, alias_name, join_clause_list, via_clause, where_clause, grouped_clause, sorted_clause):
        """
        :param relation_name: relation name.
        :type relation_name: Name
        :param alias_name: alias name.
        :type alias_name: Name
        :param join_clause_list: list of join clause
        :type join_clause_list: list of JoinClause
        :param via_clause: via clause.
        :type via_clause: ViaClause
        :param where_clause: where clause.
        :type where_clause: WhereClause
        :param grouped_clause: grouped clause.
        :type grouped_clause: GroupedClause
        :param sorted_clause: sorted clause.
        :type sorted_clause: SortedClause
        """
        self.locations = None
        self.relation_name = relation_name
        self.alias_name = alias_name
        self.join_clause_list = join_clause_list
        self.via_clause = via_clause
        if via_clause:
            self.original_via_clause = via_clause.clone()
        else:
            self.original_via_clause = None
        self.where_clause = where_clause
        self.with_where_clause = where_clause is not None
        self.grouped_clause = grouped_clause
        self.sorted_clause = sorted_clause
        self.sort_list = []

        self.via_expressions = ()
        self.via_values = []
        self.is_via_key = False
        self.is_where_optimized = False

    def get_child_nodes(self):
        return self.via_clause, self.where_clause, self.grouped_clause, self.sorted_clause,


class ViaClause(BaseAST):
    """
    :ivar lkey_value: key value list.
    :type lkey_value: list
    """
    def __init__(self, lkey_value, locations=None):
        """
        :param lkey_value: key value list.
        :type lkey_value: list
        """
        self.lkey_value = lkey_value
        self.locations = locations

    def get_child_nodes(self):
        return self.lkey_value,

    def clone(self):
        return ViaClause(self.lkey_value[:], self.locations)

    def __repr__(self):
        return "<VIA>"


class ViaKeyClause(ViaClause):
    """
    :ivar lkey_value: key value list.
    :type lkey_value: list
    """
    def __init__(self, locations=None):
        """
        :param lkey_value: key value list.
        :type lkey_value: list
        """
        self.lkey_value = None
        self.locations = locations

    def get_child_nodes(self):
        return self.lkey_value,

    def clone(self):
        return ViaKeyClause(self.locations)

    def __repr__(self):
        return "<VIA KEY>"


class JoinClause(BaseAST):
    """
    :ivar relation_name: relation name.
    :type relation_name: Name
    :ivar alias_name: alias name.
    :type alias_name: Name
    :ivar clause: bool exp.
    :type clause: Logical
    """
    def __init__(self, relation_name, alias_name, exp, locations=None):
        """
        :param relation_name: relation name.
        :type relation_name: Name
        :param alias_name: alias name.
        :type alias_name: Name
        :param exp: bool exp.
        :type exp: Logical
        """
        self.relation_name = relation_name
        self.alias_name = alias_name
        self.clause = exp
        self.locations = locations

        self.join_expressions = ()
        self.join_values = []

    def get_child_nodes(self):
        return self.relation_name, self.clause,

    def __repr__(self):
        return "<JOIN>"


class InnerJoinClause(JoinClause):
    def __repr__(self):
        return "<INNER JOIN>"


class OuterJoinClause(JoinClause):
    def __repr__(self):
        return "<OUTER JOIN>"


class LeftOuterJoinClause(OuterJoinClause):
    def __repr__(self):
        return "<LEFT OUTER JOIN>"


class RightOuterJoinClause(OuterJoinClause):
    def __repr__(self):
        return "<RIGHT OUTER JOIN>"


class FullOuterJoinClause(OuterJoinClause):
    def __repr__(self):
        return "<FULL OUTER JOIN>"


class WhereClause(BaseAST):
    """
    :ivar clause: bool exp.
    :type clause: Logical
    """
    def __init__(self, exp, locations=None):
        """
        :param exp: bool exp.
        :type exp: Logical
        """
        self.clause = exp
        self.locations = locations

    def get_child_nodes(self):
        return self.clause,

    def __repr__(self):
        return "<WHERE>"


class SortItem(BaseAST):
    """
    :ivar order: Order.
    :type order: Order
    :ivar field: Field.
    :type field: RelationId
    """
    def __init__(self, order, field, locations=None):
        """
        :param order: Order.
        :type order: Order
        :param field: Field.
        :type field: RelationId
        """
        self.order = order
        self.field = field
        self.locations = locations

    def get_child_nodes(self):
        return self.field,

    def __eq__(self, item):
        if isinstance(item, SortItem):
            return self.field == item.field
        else:
            return False


class Direction(BaseAST):
    def __init__(self, locations=None):
        self.locations = locations

    def get_child_nodes(self):
        return ()


class Ascending(Direction):
    pass


class Descending(Direction):
    pass


class GroupedClause(BaseAST):
    """
    :ivar group_list: group list.
    :type group_list: list of RelationId
    """
    def __init__(self, group_list, locations=None):
        """
        :param group_list: group list.
        :type group_list: list of RelationId
        """
        self.group_list = group_list
        self.locations = locations

    def get_child_nodes(self):
        return self.group_list,


class SortedClause(BaseAST):
    """
    :ivar direction: direction.
    :type direction: Order
    """
    def __init__(self, direction, locations=None):
        """
        :param direction: direction.
        :type direction: Order
        """
        self.direction = direction
        self.locations = locations

    def get_child_nodes(self):
        return ()


class SortedOnClause(SortedClause):
    """
    :ivar sort_list: sort list.
    :type sort_list: list of SortItem
    """
    def __init__(self, sort_list, locations=None):
        """
        :param sort_list: sort list.
        :type sort_list: list of SortItem
        """
        self.sort_list = sort_list
        self.locations = locations

    def get_child_nodes(self):
        return self.sort_list,


class ThenElseClause(StructStmt):
    """
    :ivar then_stmt: then statement.
    :type then_stmt: Stmt
    :ivar else_stmt: else statement.
    :type else_stmt: Stmt
    """
    def __init__(self, then_stmts, else_stmts=None, locations=None):
        """
        :param then_stmt: then statement.
        :type then_stmt: Stmt
        :param else_stmt: else statement.
        :type else_stmt: Stmt
        """
        self.then_stmts = then_stmts
        self.else_stmts = else_stmts
        self.locations = locations

    def get_child_nodes(self):
        return self.then_stmts, self.else_stmts,


class Name(BaseAST):

    """
    :ivar value: name value.
    :type value: str
    :ivar definition: definition.
    :type definition: BaseAST
    :ivar type: type.
    :type type: types.Type
    :ivar scope: scope name.
    :type scope: str
    """
    def __init__(self, value, locations=None):
        """
        :param value: name value.
        :type value: str
        """
        self.value = value
        self.locations = locations
        self._definition = None
        self.lower_value = str(self.value).lower()

    @property
    def definition(self):
        return self._definition

    @definition.setter
    def definition(self, value):
        self._definition = value

    @property
    def type(self):
        try:
            return self.definition.type
        except AttributeError:
            return None

    @property
    def picture(self):
        try:
            return self.definition.picture
        except AttributeError:
            return None

    def get_child_nodes(self):
        return ()

    def __eq__(self, item):
        if isinstance(item, Name):
            return self.lower_value == item.lower_value
        elif isinstance(item, str):
            return self.lower_value == item
        else:
            return False

    def __str__(self):
        return self.lower_value

    def __hash__(self):
        return hash(str(self))

    def __repr__(self):
        return self.value


class FieldClause(BaseAST):
    """
    :ivar clause_value: expression.
    :type clause_value: Exp
    """
    def __init__(self, clause_value, locations=None):
        """
        :param clause_value: expression.
        :type clause_value: Exp
        """
        self.clause_value = clause_value
        self.locations = locations

    def get_child_nodes(self):
        return self.clause_value,


class DefaultValue(FieldClause):
    """
    :ivar clause_value: specifies that the value following DEFAULT should be assumed if a value is not supplied for the field.
    :type clause_value: Literal
    """
    @property
    def definition(self):
        if self.clause_value.definition is not None:
            return self.clause_value.definition
        return self.clause_value

    @property
    def picture(self):
        try:
            return self.definition.picture
        except AttributeError:
            return None

    @property
    def type(self):
        try:
            return self.definition.type
        except AttributeError:
            return None

    @property
    def value(self):
        try:
            return self.definition.value
        except AttributeError:
            return None


class VerifyClause(FieldClause):
    """
    :ivar clause_value: specifies value constraints for a character field or adds to the standard value constraints for a numeric or date field.
    :type clause_value: Logical
    """
    pass


class PromptClause(FieldClause):
    """
    :ivar clause_value: causes the specified character string to appear in place of the usual prompt for that field.
    :type clause_value: String
    """
    pass


class ErrorClause(FieldClause):
    """
    :ivar clause_value: causes the specified character string to appear in place of the usual error message for that field.
    :type clause_value: String
    """
    pass


class EditClause(FieldClause):
    """
    :ivar clause_value: causes the specified character string to appear in place of the usual error message for that field.
    :type clause_value: String
    """
    pass


class InputOutputItem(BaseAST):
    def __init__(self, value, locations=None):
        self.value = value
        self.locations = locations

    def get_child_nodes(self):
        return self.value,


class Tab(InputOutputItem):
    """
    :ivar value: causes tabbing over the number of character positions specified by the numeric expression.
    :type value: Expr
    """
    def __repr__(self):
        return "<Tab:%s>" % (repr(self.value))


class TabTo(InputOutputItem):
    """
    :ivar value: causes tabbing to the character position specified by the numeric expression.
    :type value: Expr
    """
    def __init__(self, value, locations=None):
        InputOutputItem.__init__(self, value, locations=locations)
        self.in_source_free_form = False  # To facilitate the validation.

    def __repr__(self):
        return "<TabTo:%s>" % (repr(self.value))


class Skip(InputOutputItem):
    """
    :ivar value: causes the number of blank lines specified by the numeric expression to be generated.
    :type value: Expr
    """
    def __repr__(self):
        return "<Skip:%s>" % (repr(self.value))


class SkipTo(InputOutputItem):
    """
    :ivar value: may be used only during output to a report. This item causes blank lines to be generated up to but not including the line
                 having the line number specified by the numeric expression.
    :type value: Expr
    """
    def __init__(self, value, locations=None):
        InputOutputItem.__init__(self, value, locations=locations)

    def __repr__(self):
        return "<SkipTo:%s>" % (repr(self.value))


class WeekDay(BaseAST):
    """
        Days of the week: (MONDAY|TUESDAY|WEDNESDAY|THURSDAY|FRIDAY|SATURDAY|SUNDAY)
    """
    type = types.Day()

    def __init__(self, locations=None):
        self.locations = locations

    def get_child_nodes(self):
        return ()


class Monday(WeekDay):
    pass


class Tuesday(WeekDay):
    pass


class Wednesday(WeekDay):
    pass


class Thursday(WeekDay):
    pass


class Friday(WeekDay):
    pass


class Saturday(WeekDay):
    pass


class Sunday(WeekDay):
    pass
